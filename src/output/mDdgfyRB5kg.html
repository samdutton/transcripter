<!DOCTYPE html>

<! — 
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 — >

<html lang="en">
<head>
<meta charset="utf-8">
<meta name="author" content="//google.com">
<meta name="description" content="Chrome Dev Summit">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>mDdgfyRB5kg</title>
<link rel="stylesheet" href="css/main.css">
</head>

<body>

<div id="container">

<div id="video"></div>

<iframe class="w-youtube__embed" src="https://www.youtube.com/embed/Ai4aZ9Jbsys" allow="picture-in-picture" allowfullscreen=""></iframe>

<div id="google-translate"></div>

<section>
<span data-start="0">[MUSIC PLAYING]</span> </section>

<section><span data-start="5914"><span class="speaker">Shubhie Panicker</span>: My name is Shubhie Panicker.</span> <span data-start="7830">I'm a software engineer working on the web platform in Chrome.</span> </section>

<section><span data-start="10782"><span class="speaker">Jason Miller</span>: And I'm Jason Miller.</span> <span data-start="12240">I'm a [INAUDIBLE] for Chrome.</span> </section>

<section><span data-start="13920"><span class="speaker">Shubhie Panicker</span>: Our talk today is</span> <span data-start="15378">about a key strategy for runtime performance of web apps,</span> <span data-start="18960">and that is scheduling of JavaScript on the main thread,</span> <span data-start="22230">as well as approaches for moving script off the main thread.</span> <span data-start="26250">Jason and I have both been deep in this space</span> <span data-start="28950">exploring gaps in APIs for what we are calling achieving</span> <span data-start="33650">get responsiveness guarantees.</span> <span data-start="36042">We're excited about the opportunity</span> <span data-start="37500">here, both with existing primitives</span> <span data-start="40200">as well as the new APIs we will show in our talk.</span> </section>

<section><span data-start="43190"><span class="speaker">Jason Miller</span>: Right, so to get started,</span> <span data-start="45210">let's illustrate this problem space using a demo.</span> <span data-start="47560">So this is a simple application that searches through photos</span> <span data-start="50430">as you type.</span> <span data-start="51870">And you can see here with this JavaScript</span> <span data-start="53670">controlled red spinner animation,</span> <span data-start="55590">it's doing a fair amount of blocking work</span> <span data-start="57450">on the main thread.</span> <span data-start="58830">And while this is happening, the app can't respond to input.</span> <span data-start="61620">So typing gets queued.</span> <span data-start="63990">Looking closer, what we see if we pulled up the profiler</span> <span data-start="66770">is something like this —  a sequence of long tasks</span> <span data-start="70500">that block the main thread and cause that input queuing.</span> <span data-start="74460">We can see this on a simplified view here.</span> <span data-start="76600">So if we receive input and we start</span> <span data-start="79050">doing some processing in response to that input — </span> <span data-start="81470">say, searching photos rendering some list items — </span> <span data-start="84330">we're skipping frames already.</span> <span data-start="86400">But in addition to that, if we receive additional input</span> <span data-start="89100">while that task is running, it will get queued,</span> <span data-start="92460">and it only is able to execute once that has completed.</span> <span data-start="97050">So this is data captured from real users</span> <span data-start="99770">on real websites in the wild.</span> <span data-start="101470">And it shows a breakdown of where Chrome was spending</span> <span data-start="104270">its time while handling input.</span> <span data-start="106481">So there's a lot of interesting data here,</span> <span data-start="108230">but we don't really have time to get into it.</span> <span data-start="110105">The main thing to look at is the amount of time</span> <span data-start="112370">that we're spending in this V8.execute task.</span> <span data-start="115190">That is Chrome running JavaScript</span> <span data-start="117020">during touch handling.</span> <span data-start="118400">And it's clearly the biggest contributor</span> <span data-start="120200">to touch input latency, both on average and also in the worst</span> <span data-start="123680">case.</span> </section>

<section><span data-start="124652"><span class="speaker">Shubhie Panicker</span>: So a problem with our search as you</span> <span data-start="126860">type example app is that there's just</span> <span data-start="128930">a lot of different types of work happening here.</span> <span data-start="131890">And all of these different work have what</span> <span data-start="135010">we are calling rate deadlines.</span> <span data-start="137480">So for example, the user is typing in that search box.</span> <span data-start="140240">Their input has to be responsive.</span> <span data-start="142190">There's ongoing animations on the page.</span> <span data-start="144170">They have to render consistently and smoothly.</span> <span data-start="146954">And then there's the heavy lifting</span> <span data-start="148370">of fetching search results, post-processing, preparing,</span> <span data-start="151460">rendering these search results in time</span> <span data-start="153980">so that it's relevant to the user's typed in query.</span> <span data-start="157490">The difficulty is that it's hard for apps</span> <span data-start="160040">to balance these competing needs to reason</span> <span data-start="163040">about all these different deadlines and keeping</span> <span data-start="165410">everything meeting these timelines.</span> </section>

<section><span data-start="168256"><span class="speaker">Jason Miller</span>: Right, so we have a bunch</span> <span data-start="169880">of different types of work.</span> <span data-start="171140">And each of those types of work has a different deadline.</span> <span data-start="174440">And what we need to be able to work through this</span> <span data-start="176810">is priorities.</span> </section>

<section><span data-start="178119"><span class="speaker">Shubhie Panicker</span>: So there's a couple</span> <span data-start="179660">high level approaches to try and achieve</span> <span data-start="182420">responsiveness guarantees.</span> <span data-start="183680">The first approach can just be doing less work.</span> <span data-start="187250">And there are ways of doing this such as in an infinite feed,</span> <span data-start="190940">you might only render what's visible.</span> <span data-start="193250">We just saw a strategy with the virtual-scroller talk</span> <span data-start="195680">right now.</span> <span data-start="196790">Now this is not always possible.</span> <span data-start="199370">Modern apps often just have a ton of work to do.</span> <span data-start="202790">So a second strategy here is chunking up work</span> <span data-start="206120">and prioritizing these chunks of work.</span> <span data-start="210550">In practice, though, this is also very difficult.</span> <span data-start="214090">It can be impractical to achieve this manually on your own</span> <span data-start="217390">as an app developer.</span> <span data-start="218920">And we think there's a real opportunity here for frameworks</span> <span data-start="222130">to step in and help their users.</span> <span data-start="224380">Frameworks are in a great position</span> <span data-start="226480">to ensure chunking and prioritizing of work.</span> <span data-start="230860">So stepping back a bit, what we need here</span> <span data-start="233920">is some way to provide our chunks of work, our tasks,</span> <span data-start="238450">to a system that can hold them, say, in a task queue,</span> <span data-start="242410">and then the system can make good decisions</span> <span data-start="244690">about when to take tasks out of the task queue</span> <span data-start="247430">and execute them at an appropriate time based</span> <span data-start="250210">on everything that's going on.</span> <span data-start="252520">And this is the definition of a scheduler.</span> </section>

<section><span data-start="256301"><span class="speaker">Jason Miller</span>: So Google Maps is a really great example</span> <span data-start="258550">of an application that uses a scheduler to keep</span> <span data-start="260740">its interactions smooth.</span> <span data-start="262750">This app has to manage multiple different types of interactions</span> <span data-start="265960">and events.</span> <span data-start="266500">And these can all happen concurrently.</span> <span data-start="268510">They do this by scheduling all work</span> <span data-start="270730">and giving a much higher priority to input response</span> <span data-start="273310">tasks.</span> <span data-start="274100">We can see that here.</span> <span data-start="275030">So let's say I'm panning the map.</span> <span data-start="276760">And as I'm panning, additional tiles</span> <span data-start="278920">are coming into the viewport and need to be loaded.</span> <span data-start="281350">However, if I stop panning and I pull up</span> <span data-start="283810">the drawer at the bottom, all of a sudden,</span> <span data-start="285730">that is far and away the most high priority task to execute.</span> <span data-start="289490">So those map tiles being loaded need to be de-prioritized.</span> </section>

<section><span data-start="294142"><span class="speaker">Shubhie Panicker</span>: So a key aspect of a good scheduler</span> <span data-start="296350">is its ability to execute work at the best time.</span> <span data-start="300350">And this is an appropriate time based</span> <span data-start="302020">on everything that's going on, various factors like,</span> <span data-start="304660">what's the type of the task, what's important to the user</span> <span data-start="307390">right now, what's the overall state of the application,</span> <span data-start="310630">what's the internal state of the browser, et cetera.</span> <span data-start="314290">So to understand this notion of best time,</span> <span data-start="317110">we have to step down a level and look at the browser's rendering</span> <span data-start="321220">pipeline.</span> <span data-start="322360">The browser is periodically bumping frames, typically</span> <span data-start="325360">every 16 milliseconds for a 60 frames per second display rate.</span> <span data-start="329740">And each frame has a set of things that happen in sequence.</span> <span data-start="334330">For instance, we have request animation frames followed</span> <span data-start="337450">by style, layout, and paint.</span> <span data-start="339460">In Chrome, input handlers are aligned right</span> <span data-start="342250">before request animation frame callbacks.</span> <span data-start="344840">So the point here is that there is limited time</span> <span data-start="348550">to do the urgent work that needs to happen in the current frame.</span> <span data-start="353110">And then the app has to immediately start</span> <span data-start="354940">thinking about preparing for that next frame.</span> <span data-start="358120">And the third type of work here is idle work,</span> <span data-start="360520">which might be left over in the current frame</span> <span data-start="363190">or there might be plenty of idle time</span> <span data-start="365320">if no frames are being rendered.</span> <span data-start="369010">So this is the terminology we are using</span> <span data-start="370710">for these three types of work.</span> <span data-start="372390">We have user-blocking tasks for the current frame.</span> <span data-start="375750">This is typically to provide the user</span> <span data-start="378180">an immediate acknowledgment of what they are doing.</span> <span data-start="381090">So in our example app, this might be keeping that typing</span> <span data-start="385830">interactive in the search box, keeping those animations going</span> <span data-start="389100">on the page.</span> <span data-start="390030">Overall, keeping the page responsive overall — </span> <span data-start="392160">buttons should be toggleable.</span> <span data-start="394110">Default work is this next category of work.</span> <span data-start="396930">This is typically user visible.</span> <span data-start="398610">And this is preparing for the next frame or a future frame.</span> <span data-start="402690">And in our example, this would be</span> <span data-start="404370">the work of the post-processing, preparing the search results,</span> <span data-start="408770">rendering them in time.</span> <span data-start="410610">And finally, the third category, idle work.</span> <span data-start="413080">This is typically work that is not user visible.</span> <span data-start="416610">This can be at the end of the frame</span> <span data-start="418260">or if no frames are being rendered —  things</span> <span data-start="420480">like analytics, backups, syncs, or indexing.</span> <span data-start="426630">So on the right here, we've listed some existing</span> <span data-start="430990">primitives, existing ways how a developer might</span> <span data-start="434680">be able to submit work to the browser to target</span> <span data-start="438070">these priority levels.</span> <span data-start="439490">So for user-blocking, input handler, and request</span> <span data-start="442370">animation frames are great for this.</span> <span data-start="445210">It's also worth noting that micro tasks are suited</span> <span data-start="448300">for user-blocking urgent work.</span> <span data-start="450430">They do not yield to the event loop.</span> <span data-start="452920">And we've seen some bad cases where developers</span> <span data-start="455590">are accidentally doing non-urgent or large amounts</span> <span data-start="458230">of work without realizing it's blocking rendering.</span> <span data-start="461680">The second thing, default. We have</span> <span data-start="463780">things like setTimeout zero, postMessage.</span> <span data-start="466240">These are really hacks and work arounds.</span> <span data-start="468340">There isn't a real primitive here.</span> <span data-start="470890">And we are working to fill this gap.</span> <span data-start="472870">And finally, for idle, requestIdleCallback</span> <span data-start="475780">is a great API.</span> <span data-start="477580">So JavaScript schedulers can be built today</span> <span data-start="481840">using these primitives.</span> <span data-start="483780">Now while it's possible to build a scheduling</span> <span data-start="486130">system in JavaScript, they suffer from gaps</span> <span data-start="490210">primarily because they don't have enough control on signals</span> <span data-start="496310">to properly control scheduling.</span> <span data-start="498370">So we'll go through some examples.</span> <span data-start="501560">So for example, we've seen JavaScript schedulers</span> <span data-start="503920">are trying to estimate the frame deadline.</span> <span data-start="506744">So they're doing a whole bunch of bookkeeping,</span> <span data-start="508660">trying to guess at it.</span> <span data-start="509770">But they're doing it poorly because it's just not</span> <span data-start="511811">possible to do this well without knowing browser internals.</span> <span data-start="515260">So we are considering exposing an API for that.</span> <span data-start="519000">isInputPending is a really useful signal for schedulers,</span> <span data-start="523240">and we are actively exploring an API.</span> <span data-start="526270">Then there's other coordination work.</span> <span data-start="528490">So for example, handling fetch response priorities</span> <span data-start="532780">is pretty relevant.</span> <span data-start="534760">If you're doing urgent work for the current frame,</span> <span data-start="537190">you don't want your low priority fetch responses</span> <span data-start="540640">to come in and interrupt that.</span> <span data-start="542860">In practice, though, there's a lot of other work</span> <span data-start="545980">that's happening in the browser.</span> <span data-start="547850">The browser might initiate various callbacks</span> <span data-start="550270">such as ready state change for XHR</span> <span data-start="552820">or a postMessage might come in from a worker.</span> <span data-start="555220">There's internal work like [INAUDIBLE]..</span> <span data-start="557440">And it's just not possible to codify priorities</span> <span data-start="560770">for all of this and [INAUDIBLE] signals.</span> <span data-start="564350">So this got us thinking, how about moving the scheduler one</span> <span data-start="568840">level down and integrating it directly with the browser's</span> <span data-start="572770">event loop where we already have most of these signals</span> <span data-start="576550">and a lot of great information?</span> <span data-start="578620">And this would solve an additional problem.</span> <span data-start="581320">That is this coordination problem</span> <span data-start="583300">between multiple parties in the app.</span> <span data-start="585920">If you have third party content, or embedded libraries or legacy</span> <span data-start="589540">code, or even other frameworks, they can all co-exist and use</span> <span data-start="593290">the same day scheduling system with consistent priorities.</span> <span data-start="598930">So this is a very early sketch of what an API might look like.</span> <span data-start="604110">The key thing here is a set of global task use targeting</span> <span data-start="608520">each priority level.</span> <span data-start="609730">And so this is really simple and straightforward</span> <span data-start="611760">compared to using a myriad different APIs.</span> <span data-start="615540">The second thing is we think it will</span> <span data-start="617160">be useful to have a notion of user-defined task</span> <span data-start="620850">queues, a virtual task queues.</span> <span data-start="622470">And this would give developers more control</span> <span data-start="625380">over managing a group of tasks and doing bulk operations</span> <span data-start="630450">like updating priority, canceling all the tasks,</span> <span data-start="633600">or flushing the task used if the app is going away.</span> </section>

<section><span data-start="637440"><span class="speaker">Jason Miller</span>: Right, so here we can see a simplified</span> <span data-start="640077">version of that map scheduler that we looked</span> <span data-start="641910">at using this task queue API.</span> <span data-start="644700">So first, we hook into the user blocking and default task</span> <span data-start="648470">queues just to give ourselves a high and a low priority queue.</span> <span data-start="651610">And then we start listening for pointermoves events.</span> <span data-start="653940">And each time we receive one of these events,</span> <span data-start="655815">we enqueue a pan task with coordinates</span> <span data-start="658440">at that pointermove.</span> <span data-start="660060">The pan task translates the map tiles, obviously.</span> <span data-start="662610">And then it might, let's say, enqueue a low priority task</span> <span data-start="666090">to detect any tiles that have moved into the viewport</span> <span data-start="670110">and potentially load those tiles.</span> <span data-start="672360">The thing to note here is if we receive a new pointermove event</span> <span data-start="675780">before we've invoked this loadMoreTiles task, that</span> <span data-start="679290">would be given a higher priority than loading more tiles.</span> <span data-start="681870">And that's exactly what we want.</span> <span data-start="683203">We give higher priority to input-driven tasks.</span> <span data-start="686440">And let's say the team behind Maps</span> <span data-start="688332">needed to track analytics or do something in response</span> <span data-start="690540">to pan gestures, they'll be a good case for something</span> <span data-start="692790">like an idle priority task.</span> </section>

<section><span data-start="695637"><span class="speaker">Shubhie Panicker</span>: So here you can see most of the frames</span> <span data-start="697970">are in green and getting rendered in time.</span> <span data-start="700470">And this is what a well scheduled system looks like.</span> <span data-start="703310">The work is chunked up.</span> <span data-start="704840">There is high priority work happening</span> <span data-start="707150">at the beginning of every frame, followed by style,</span> <span data-start="710060">layout, paint in purple and green,</span> <span data-start="712070">just immediately followed by default priority work in yellow</span> <span data-start="715700">to prepare for the next frame, as well as idle priority work</span> <span data-start="719900">being properly interleaved.</span> <span data-start="721560">And this time is adequately utilized.</span> <span data-start="724580">Next.</span> <span data-start="726240">So all the APIs proposals we showed today</span> <span data-start="729650">are super early stage.</span> <span data-start="731330">We actually don't know what the end game here is going to be.</span> <span data-start="734750">This is a really great time to give us feedback and help</span> <span data-start="739730">us chart the course here.</span> <span data-start="742160">For web developers, we really think</span> <span data-start="743900">that there is an opportunity here with improved scheduling,</span> <span data-start="746660">even if they're just properly using existing primitives.</span> <span data-start="750320">For framework authors, we want to urge</span> <span data-start="752180">you to consider a scheduling system</span> <span data-start="754790">and collaborate with us now to develop the right set of APIs</span> <span data-start="758990">in this space.</span> <span data-start="760280">React's work on concurrent and time slicing</span> <span data-start="763760">has proven that frameworks can really</span> <span data-start="766010">play a good role in terms of helping apps</span> <span data-start="769340">improve responsiveness of apps.</span> <span data-start="772710">And we're already working with React</span> <span data-start="774450">and actively looking to form partnerships</span> <span data-start="777180">with other frameworks and apps.</span> <span data-start="779650">This is a link to our GitHub repo.</span> <span data-start="781770">Filing issues on the repo is a great way</span> <span data-start="784410">to get that feedback dialogue going.</span> </section>

<section><span data-start="786750"><span class="speaker">Jason Miller</span>: Right.</span> <span data-start="787710">So what about work that can't be chunked, though?</span> <span data-start="792120">What if we have a bunch of JavaScript we need to execute,</span> <span data-start="795210">and it's really difficult or even potentially impossible</span> <span data-start="798030">to break that work up?</span> <span data-start="800460">Here's an example that illustrates what I mean.</span> <span data-start="802891">Let's say we have a text editor that</span> <span data-start="804390">does something like live JavaScript bundling</span> <span data-start="806490">as you type.</span> <span data-start="807660">If I load in a decent amount of code here,</span> <span data-start="810630">things start to be a little bit slow.</span> <span data-start="812620">So every time the bundling process</span> <span data-start="814080">kicks in response to my input, it blocks the main thread.</span> <span data-start="817800">And this causes the cursor to freeze</span> <span data-start="819690">and it queues up my text input until bundling is completed.</span> <span data-start="822640">And this really disrupts the typing experience.</span> <span data-start="824880">You can see that in the CPU profile here on the right.</span> <span data-start="828480">So it would be really difficult to break</span> <span data-start="831600">that work up into 50 millisecond chunks,</span> <span data-start="833580">and that's for two reasons.</span> <span data-start="834760">First, I didn't write any of the Bundler code,</span> <span data-start="837990">so modifying that would be a lot of work, particularly for me.</span> <span data-start="841980">Plus there is a whole bunch of different libraries</span> <span data-start="844770">that are being used to actually make these things happen,</span> <span data-start="847530">those dependencies.</span> <span data-start="848400">And downloading, parsing, and evaluating those dependencies</span> <span data-start="851550">on the main thread blocks.</span> <span data-start="853650">So using background threads lets us offload that work and get it</span> <span data-start="857689">off the main thread so the main thread can sort of just</span> <span data-start="859980">keep handling input.</span> <span data-start="862620">There's a few use cases that lend themselves extremely</span> <span data-start="865020">well to this approach.</span> <span data-start="866340">If you're building a computer aided design tool, a game,</span> <span data-start="869190">or doing encoding, these are great places</span> <span data-start="871440">to just start with threads.</span> <span data-start="874050">Same thing for AI, machine learning, crypto.</span> <span data-start="877364">If these are the types of things you're doing,</span> <span data-start="879280">you should start here.</span> <span data-start="881220">In the browser, our primitive for threading is the worker.</span> <span data-start="884652">So if you haven't used Workers, you</span> <span data-start="886110">haven't used them in a while, they're basically threads.</span> <span data-start="889090">They have a simple messaging interface,</span> <span data-start="890715">so you can send a message to the worker,</span> <span data-start="892530">and you can receive a message back.</span> <span data-start="894330">They have no DOM access whatsoever and a very limited</span> <span data-start="897180">global scope, kind of just fetch and module stuff.</span> <span data-start="900709">And they shipped around 10 years ago,</span> <span data-start="902250">and they're available essentially everywhere.</span> <span data-start="905530">So the API for workers looks like this.</span> <span data-start="908040">You will instantiate the worker constructor</span> <span data-start="910110">and pass up the name of a script.</span> <span data-start="912260">And then we can listen for messages</span> <span data-start="913950">coming back out of that worker.</span> <span data-start="915760">And we can send messages down to the worker.</span> <span data-start="917680">So here, we're sending it a message that's an object.</span> <span data-start="920320">And this describes that we would like to, say, invoke</span> <span data-start="922725">a computeHash function.</span> <span data-start="924810">And we're going to pass it the contents of a file,</span> <span data-start="927300">expressed here as an array buffer.</span> <span data-start="929410">The second argument to postMessage is interesting.</span> <span data-start="931560">This tells the browser to, rather than</span> <span data-start="933350">structured cloning the array buffer, it will transfer it in.</span> <span data-start="937230">Finally once computeHash has completed,</span> <span data-start="939760">it will say, postMessage back to our thread</span> <span data-start="942690">and will be dropped into the message handler on line 3.</span> </section>

<section><span data-start="945727"><span class="speaker">Shubhie Panicker</span>: So under the covers,</span> <span data-start="947310">this postMessage of the data is incurring a serialization</span> <span data-start="950869">on the main thread.</span> <span data-start="951660">And it's getting queued up, hopping over</span> <span data-start="953520">to a worker thread, followed by deserialization.</span> <span data-start="956460">And end-to-end, this is called a thread hop.</span> <span data-start="959460">And this thread hop has a cost, and primarily</span> <span data-start="962370">from the data being subject to what</span> <span data-start="964470">is called structured cloning, which</span> <span data-start="966090">is a copying behavior while recursing the JavaScript</span> <span data-start="969060">object.</span> <span data-start="969840">The size of the data is relevant to the cost of the thread hop.</span> <span data-start="976270">So one downside of the postMessage API</span> <span data-start="979450">is that it doesn't have a notion of statefulness</span> <span data-start="982120">between the request and the response.</span> <span data-start="983935">So if you make a whole bunch of requests,</span> <span data-start="986290">you'll get a whole bunch of responses back.</span> <span data-start="988210">And it's hard to correlate those responses to requests.</span> </section>

<section><span data-start="992077"><span class="speaker">Jason Miller</span>: Right.</span> <span data-start="992910">So we've seen how to communicate with a worker using</span> <span data-start="995076">postMessage.</span> <span data-start="995970">There's actually a number of ways you can do this.</span> <span data-start="998190">A second way would be to use MessageChannel.</span> <span data-start="1000320">MessageChannel is something you can instantiate,</span> <span data-start="1002320">and you get back two ports.</span> <span data-start="1003560">You can pass your other port to some other contexts like a tab</span> <span data-start="1006830">or a frame or a worker, and you can message between the two.</span> <span data-start="1010550">They have the same interface, as we just saw.</span> <span data-start="1013370">Another one would be BroadcastChannel.</span> <span data-start="1015260">This is like a MessageChannel that's</span> <span data-start="1017090">shared to all contexts associated</span> <span data-start="1019160">with an origin, so all tabs, frames, workers,</span> <span data-start="1021440">service worker.</span> <span data-start="1022520">And all you do is you instantiate a BroadcastChannel</span> <span data-start="1024740">with a channel keyword.</span> <span data-start="1026579">And you message without having to pass ports around.</span> <span data-start="1029060">Soon we're actually going to have a fourth way</span> <span data-start="1030976">to communicate.</span> <span data-start="1031680">And this is transferable streams.</span> <span data-start="1033140">It lends itself really well to things like audio and video</span> <span data-start="1035597">where the format you would want to use to express these things</span> <span data-start="1038180">is streaming.</span> <span data-start="1039650">The thing with all of these APIs is that they're message-based.</span> <span data-start="1043520">And based on some of the common usage patterns that we've seen</span> <span data-start="1047210">and what we've heard from developers,</span> <span data-start="1049010">we think there might be a case here for a higher level API.</span> <span data-start="1052820">So we've seen solutions to this in userland through libraries</span> <span data-start="1056510">like comlink, greenlet, workerize, via.js.</span> <span data-start="1060170">These all help coordinate messaging across boundaries</span> <span data-start="1063320">by abstracting that postMessage using something</span> <span data-start="1065990">called proxying.</span> </section>

<section><span data-start="1067474"><span class="speaker">Shubhie Panicker</span>: So messaging certainly</span> <span data-start="1069140">improves over a postMessage.</span> <span data-start="1071941">I'm sorry.</span> <span data-start="1072440">Proxying improves over postMessage,</span> <span data-start="1073960">but it comes with a number of downsides.</span> <span data-start="1075950">Every method call to a proxied object</span> <span data-start="1078390">incurs the cost of a thread hop, and this can come as a surprise</span> <span data-start="1082280">to developers.</span> <span data-start="1083630">Platform gaps can cause memory leaks in these APIs.</span> <span data-start="1088070">These APIs don't really have a notion of a backing threadpool</span> <span data-start="1092270">or a concept of managing threads and resizing the pool.</span> <span data-start="1095480">Embedded libraries are not able to share the same thread</span> <span data-start="1099530">or threadpool.</span> <span data-start="1100690">And for complex APIs, it can be impractical to recreate</span> <span data-start="1104630">this API surface cross thread.</span> <span data-start="1108630">So this raises the question, is there</span> <span data-start="1110700">an opportunity here for better integration with the browser?</span> <span data-start="1114000">Is there an opportunity to provide a more compelling API?</span> </section>

<section><span data-start="1117620"><span class="speaker">Jason Miller</span>: Right.</span> <span data-start="1119054">We think there might be a use case here for something that</span> <span data-start="1121470">looks something like this.</span> <span data-start="1123370">So here, we're passing the name of a function</span> <span data-start="1125790">in some other context and some arguments</span> <span data-start="1127920">to a theoretical postTask method.</span> <span data-start="1130800">This postTask method would return a promise</span> <span data-start="1133170">that eventually resolves to the return value of that function</span> <span data-start="1135930">somewhere else.</span> <span data-start="1137690">This abstract code helps us move from a message passing model</span> <span data-start="1142620">to a more task-oriented model.</span> </section>

<section><span data-start="1146826"><span class="speaker">Shubhie Panicker</span>: So in looking at the requirements</span> <span data-start="1148950">for a better API, we considered other platforms.</span> <span data-start="1153090">We looked at iOS and Android, which</span> <span data-start="1155730">have plenty of precedent for usage of background threads.</span> <span data-start="1159240">In particular, iOS has an API called Grand Central Dispatch,</span> <span data-start="1162720">which is a very stable well-proven API that's</span> <span data-start="1164970">loved by iOS developers.</span> <span data-start="1167016">Android, amongst other things, has something called</span> <span data-start="1169140">AsyncTask, which is a very minimal, clean API.</span> <span data-start="1172440">We talked to framework developers and experts</span> <span data-start="1175800">in usage of these APIs who were deeply familiar</span> <span data-start="1179520">with the pitfalls, and we learned things.</span> <span data-start="1182560">Some key things we learned in terms of the basic requirements</span> <span data-start="1186220">we want for our model is, number one, good ergonomics,</span> <span data-start="1190390">a way for developers to offload work</span> <span data-start="1192590">by just thinking in terms of submitting</span> <span data-start="1194340">task versus coordinating over threads.</span> <span data-start="1198130">Secondly, a native threadpool that's</span> <span data-start="1199870">shareable with embedded libraries and other parties</span> <span data-start="1202990">in the app.</span> <span data-start="1204050">And finally, a system-controlled thread management,</span> <span data-start="1206860">where the system can be in control of making decisions</span> <span data-start="1210160">on resizing the threadpool or decisions on where to run which</span> <span data-start="1213590">tasks.</span> <span data-start="1216980">So we set off on a path towards building</span> <span data-start="1219170">a basic task queue-based API inspired by Grand Central</span> <span data-start="1223220">Dispatch.</span> <span data-start="1224480">And a naive API might look like this.</span> <span data-start="1226920">Let's say you have three tasks, A, B, and C.</span> <span data-start="1230080">And let's say each one depends on the results</span> <span data-start="1232040">of the previous task, and we can submit these tasks</span> <span data-start="1236300">from the main thread over to worker threads.</span> <span data-start="1238340">And then we'll start getting responses back.</span> <span data-start="1240620">So here for three tasks, we paid the cost of six thread hops.</span> <span data-start="1248020">There's a few downsides here and gotchas.</span> <span data-start="1250880">So for one, these thread hops can be</span> <span data-start="1253790">expensive on lower-end devices.</span> <span data-start="1255860">And depending on the data size, it</span> <span data-start="1257600">can be up to 15 milliseconds, and this can add up.</span> <span data-start="1261870">This means that if these hops are</span> <span data-start="1263660">in the path of user interaction, this</span> <span data-start="1265880">can add up to multiple frames worth of latency now.</span> <span data-start="1270020">On Android, we've actually seen this in practice</span> <span data-start="1272420">in the real world in their usage of AsyncTask.</span> <span data-start="1276080">So one conclusion here is this notion</span> <span data-start="1279320">of default posting back results to the main thread is not</span> <span data-start="1282770">a good idea.</span> <span data-start="1284420">Besides the latency issue, it can cause congestion</span> <span data-start="1287300">from queue buildups.</span> <span data-start="1288860">And then you might remember from our earlier main thread</span> <span data-start="1291260">scheduling talk, we're doing all this work</span> <span data-start="1293930">to carefully chunk up our work and execute our high priority</span> <span data-start="1297860">and our default priority work.</span> <span data-start="1299400">And all these postMessages coming in at random times</span> <span data-start="1302990">messes with main thread scheduling.</span> <span data-start="1305310">A second thing to note here is that default posting,</span> <span data-start="1308750">even to the current thread, can be pretty bad.</span> <span data-start="1312620">And we saw this in Grand Central Dispatch with their dispatch</span> <span data-start="1316620">at current queue API.</span> </section>

<section><span data-start="1319159"><span class="speaker">Jason Miller</span>: So this brings us to a new proposal</span> <span data-start="1321200">we have that incorporates some of our learnings</span> <span data-start="1324110">from other platforms.</span> <span data-start="1325850">It lets developers avoid sending data back to the main thread.</span> <span data-start="1329960">It lets you chain tasks together without data transfer,</span> <span data-start="1333830">and pay the return cost only once.</span> <span data-start="1336950">It also minimizes thread hops using</span> <span data-start="1339290">a built-in sticky threadpool.</span> <span data-start="1341600">What we want is the experience that you see up here</span> <span data-start="1343940">on the right.</span> <span data-start="1345431">So let's dive into that.</span> <span data-start="1346430">If we revisit the Code Editor that we showed earlier,</span> <span data-start="1348687">the one that bundles JavaScript as you</span> <span data-start="1350270">type, if we do this using Task Worklet,</span> <span data-start="1353240">we can leverage some of these features</span> <span data-start="1354830">to improve performance fairly considerably.</span> <span data-start="1358010">Because Task Worklet avoids transferring</span> <span data-start="1360080">data between threads, the bundling and minifying tasks</span> <span data-start="1363500">in this demo can actually all reuse</span> <span data-start="1365630">the same AST that is generated from that initial parse task.</span> <span data-start="1369230">In the end, only the resulting minified code,</span> <span data-start="1372200">which is a relatively small string,</span> <span data-start="1374030">actually gets sent back to the main thread.</span> <span data-start="1377530">So the implementation looks something like this.</span> <span data-start="1379530">First, we create a Worklet module,</span> <span data-start="1381530">and that registers named task processors.</span> <span data-start="1383830">These are just classes with a process method.</span> <span data-start="1386070">Then over on the main thread, we can</span> <span data-start="1387900">coordinate that data flow using this postTask.</span> <span data-start="1392730">So we're going to parse the code and then</span> <span data-start="1394710">pass that resulting AST through the bundle and minify tasks.</span> <span data-start="1397950">And the important thing to note here</span> <span data-start="1399450">is that none of these variables are actually holding values.</span> <span data-start="1403710">These are just pointers to data that exists in the threadpool.</span> <span data-start="1407070">Data transfer back to the main thread</span> <span data-start="1408720">only happens when we await the result</span> <span data-start="1411510">property of that last task.</span> <span data-start="1414870">So doing this in a typical workers implementation</span> <span data-start="1417210">would normally take six hops, as we saw.</span> <span data-start="1420060">We executed three tasks.</span> <span data-start="1421320">We need to pass a message down and backup for each of them.</span> <span data-start="1424170">In Task Worklet, this is only two thread</span> <span data-start="1426960">hops because we can transfer data between tasks.</span> <span data-start="1430800">Task Worklet is also backed by a threadpool.</span> <span data-start="1433390">So let's say we start off with a task that</span> <span data-start="1436050">produces a large set of images.</span> <span data-start="1438100">When we post a task with some of those images as its argument,</span> <span data-start="1442590">it will attempt to run in the thread</span> <span data-start="1444420">where that data is already available.</span> <span data-start="1446820">So data is never transferred between threads in this case,</span> <span data-start="1449370">and at least a few are thread hops.</span> <span data-start="1451500">To take advantage of pooling, though,</span> <span data-start="1453090">if there's no optimal thread available,</span> <span data-start="1455250">we will resort to transferring data between threads</span> <span data-start="1458130">in order to get parallelization.</span> <span data-start="1460890">And then finally, let's say the result</span> <span data-start="1462475">that we're looking for here is actually</span> <span data-start="1464100">just a comparison of the number of cats</span> <span data-start="1465870">versus the number of dog photos, since that's</span> <span data-start="1468000">what's important in the end.</span> <span data-start="1470520">In this case, the only thing we ever</span> <span data-start="1472230">transfer back to the main thread is a single integer.</span> <span data-start="1475200">And as you can imagine, that's extremely cheap.</span> <span data-start="1477925">So we've been thinking a lot about what</span> <span data-start="1479550">the future of web development off the main thread</span> <span data-start="1482010">might look like today we have libraries like Comlink that</span> <span data-start="1485100">use reflection to kind of emulate</span> <span data-start="1487470">the interface of some code running in a worker</span> <span data-start="1489390">so that it could be called from the main thread seamlessly.</span> <span data-start="1491848">In the future, we think we might move towards a Task Worklet</span> <span data-start="1495210">model where developers approach multi-threaded web programming</span> <span data-start="1498750">in sort of a different way.</span> <span data-start="1499890">You have a threadpool that's managed automatically, named</span> <span data-start="1502980">tasks, and this concept of a task graph</span> <span data-start="1505920">that optimizes execution and data flow.</span> <span data-start="1510430">So this is a really early proposal.</span> <span data-start="1512962">We are looking for feedback, and we are looking</span> <span data-start="1514920">for real-world use cases.</span> <span data-start="1516790">There is an implementation available in Chromium</span> <span data-start="1518820">behind the Experimental Web Platform Features flag.</span> <span data-start="1522320">And also we have Polyfill and some source code</span> <span data-start="1524580">and demos available at this GitHub repo.</span> <span data-start="1527390">There will be a link at the end of the presentation as well.</span> </section>

<section><span data-start="1530105"><span class="speaker">Shubhie Panicker</span>: So there's been</span> <span data-start="1531480">a lot of interest in this idea of multi-threaded JavaScript</span> <span data-start="1535140">over the last couple years.</span> <span data-start="1536620">There have been several independent explorations</span> <span data-start="1538620">by various frameworks and apps.</span> <span data-start="1540600">So we dug into this in the last few months</span> <span data-start="1543090">to understand how far can we get with just using the worker</span> <span data-start="1546510">API as a way to achieve threadedness.</span> <span data-start="1550170">And to set some context here, a new worker</span> <span data-start="1553860">doesn't just spin up a raw OS thread.</span> <span data-start="1556500">It actually creates its own JavaScript environment</span> <span data-start="1559380">on top of this.</span> <span data-start="1561650">And part of that is what's called a V8 isolate, which</span> <span data-start="1564540">has a non-trivial weight in addition</span> <span data-start="1567270">to the weight of the OS thread.</span> <span data-start="1569130">A key implication here is that the worker,</span> <span data-start="1572760">by creating its own JavaScript environment,</span> <span data-start="1575190">is not able to share data or code with the main thread.</span> <span data-start="1578550">And this is fundamentally different from background</span> <span data-start="1581160">threads on other platforms and other languages.</span> <span data-start="1586560">So this has implications in terms of using Workers</span> <span data-start="1590480">in a mainstream way.</span> <span data-start="1592320">And by that I mean when the worker is in the path of user</span> <span data-start="1595580">interaction.</span> <span data-start="1596600">In particular, we looked at two app development models</span> <span data-start="1599540">using worker.</span> <span data-start="1600800">The first one is doing state management in a worker,</span> <span data-start="1603850">and this is where you can do the heavy lifting, business</span> <span data-start="1606680">logic-y stuff in a worker.</span> <span data-start="1608480">And the second model goes even further</span> <span data-start="1611960">and does the bulk of rendering in the worker.</span> <span data-start="1614570">Now while worker doesn't have access to the DOM,</span> <span data-start="1617810">there are libraries like WorkerDOM.</span> <span data-start="1620000">So you can do virtual DOM updates in the worker</span> <span data-start="1622950">and then ferry the [? diffs ?] back to the main thread.</span> <span data-start="1626250">So real apps have been built using these models.</span> <span data-start="1630470">However, there are some significant challenges</span> <span data-start="1633230">that we want to highlight here if you're</span> <span data-start="1635990">planning to go down this route.</span> <span data-start="1638570">The first thing is that it's hard to have synchronous access</span> <span data-start="1644540">to a worker, but real apps need synchronous access</span> <span data-start="1647690">to their app state.</span> <span data-start="1648812">So what this means is sometimes you</span> <span data-start="1650270">want to look up your app state on the main thread,</span> <span data-start="1652353">and sometimes you might update that app state on a worker.</span> <span data-start="1655570">And this means you now have to maintain and replicate</span> <span data-start="1658880">this app state in both places and synchronize it</span> <span data-start="1662390">continuously.</span> <span data-start="1663630">And this has a cost in terms of thread hops.</span> <span data-start="1667640">The second thing here is that the worker has to be</span> <span data-start="1670910">bootstrapped with all the script and modules that it needs</span> <span data-start="1674420">because, like we said, it cannot share code with the main</span> <span data-start="1677300">thread.</span> <span data-start="1677960">And this has implications for startup delay.</span> <span data-start="1682630">So we run benchmarks to dig into this base cost of a worker.</span> <span data-start="1687460">And these are some numbers from a medium Android device.</span> <span data-start="1690790">Startup takes upwards of 10 millisecond.</span> <span data-start="1693250">And this is, again, a Chrome on Android.</span> <span data-start="1696050">A thread hop varies anywhere from one to 15 milliseconds,</span> <span data-start="1700240">depending on the device and the size and type of the data.</span> <span data-start="1705420">Look out for a blog post that will</span> <span data-start="1707890">be accompanying this talk in the next week or two.</span> <span data-start="1711250">And we will have some detailed links to our benchmarks</span> <span data-start="1713590">and data there.</span> <span data-start="1715820">We also set up more realistic benchmarks.</span> <span data-start="1719330">We built apps that were representing</span> <span data-start="1721220">the app development models we mentioned, that is,</span> <span data-start="1723800">the state management in a worker and rendering in a worker.</span> <span data-start="1727490">And we did a ton of runs on real mobile devices,</span> <span data-start="1731940">both with and without worker.</span> <span data-start="1733760">And we looked at a variety of metrics,</span> <span data-start="1736160">everything from loading metrics, memory metrics,</span> <span data-start="1739610">to rendering metrics, such as frame rate and input latency.</span> <span data-start="1743990">And we approximated input latency using cycle time.</span> <span data-start="1747600">So again, the blog post will have more details on this.</span> <span data-start="1751730">But I do want to highlight one bit of interesting data.</span> <span data-start="1756130">So this is basically showing runs</span> <span data-start="1759960">with an app that is representative</span> <span data-start="1762750">of rendering in a worker.</span> <span data-start="1764190">The red are runs with worker, and blue runs without worker.</span> <span data-start="1768630">So what we are seeing here is that on worker, we</span> <span data-start="1772140">are seeing a higher and more improved frame rate.</span> <span data-start="1775650">But on the flip side, we are also</span> <span data-start="1777720">seeing a higher input latency.</span> <span data-start="1781200">So there is a fundamental trade-off</span> <span data-start="1783150">here between improved smoothness versus user latency.</span> <span data-start="1789060">Workers are able to free up the main thread by offloading work.</span> <span data-start="1792880">And so they can free up that main thread</span> <span data-start="1794850">to focus on rendering, and less grip means fewer long task</span> <span data-start="1800070">hiccups on the main thread.</span> <span data-start="1801900">Again, on the flip side, input latency</span> <span data-start="1804780">suffers from thread hops.</span> <span data-start="1807000">And the worker environment is a limited environment</span> <span data-start="1809730">and doesn't have APIs.</span> <span data-start="1810870">And it's not just the DOM.</span> <span data-start="1812280">There are many other APIs as that are still not available,</span> <span data-start="1814930">like media, audio, et cetera.</span> </section>

<section><span data-start="1816450"><span class="speaker">Jason Miller</span>: Yeah.</span> <span data-start="1817260">So the key thing to take away from this</span> <span data-start="1818940">is, workers might be able to make your rendering smoother,</span> <span data-start="1823260">but they might do it at the expense of a bit of input</span> <span data-start="1826290">delay.</span> <span data-start="1827670">There's cases, though, where this is completely worth it.</span> <span data-start="1830400">So AMPscript is a great example.</span> <span data-start="1831910">AMPscript renders using workers in order</span> <span data-start="1834030">to sandbox, potentially misbehaving JavaScript.</span> <span data-start="1837330">Slower or problematic code that's</span> <span data-start="1839490">running in the worker in this emulated DOM</span> <span data-start="1842340">can't negatively impact the AMP document.</span> <span data-start="1845792">And so for AMP, the benefits they get out</span> <span data-start="1847500">of sandboxing untrusted code far outweigh the latency</span> <span data-start="1850920">that they get from transferring events.</span> <span data-start="1853890">So we wanted to summarize when they use workers,</span> <span data-start="1857040">but it turns out there's no perfect rubric for this.</span> <span data-start="1860920">So there's a couple of hints you can use though.</span> <span data-start="1863340">If you have code that blocks for a long time,</span> <span data-start="1865530">if you have code with small inputs and outputs,</span> <span data-start="1867810">or something that follows the simple request response model,</span> <span data-start="1870880">you might be in a position to start off with workers.</span> <span data-start="1873910">However, if you have code that relies on the DOM</span> <span data-start="1876360">or is directly in the path of input response,</span> <span data-start="1879090">or just code that needs really minimal overhead,</span> <span data-start="1882000">you might want to start off with a different solution.</span> <span data-start="1884250">You could approach workers later.</span> <span data-start="1886770">When adopting a threaded approach to state management,</span> <span data-start="1889500">make sure that your state management and business</span> <span data-start="1892200">logic outweighs the cost of creating a worker</span> <span data-start="1895620">and sending and receiving messages.</span> <span data-start="1897270">Make sure that your worker is pulling its own weight.</span> <span data-start="1901009">So we're at the beginning of a fairly</span> <span data-start="1902550">major shift in how applications are developed for the web.</span> <span data-start="1907140">We're excited to explore new possibilities</span> <span data-start="1910080">for effective scheduling and threading.</span> <span data-start="1912670">And we hope that all of you are too.</span> </section>

<section><span data-start="1914719"><span class="speaker">Shubhie Panicker</span>: And so we just want</span> <span data-start="1916260">to leave you with some of these key messages from our talk</span> <span data-start="1918690">today.</span> <span data-start="1919530">It's hard to achieve responsiveness guarantees</span> <span data-start="1921720">because there's so much work happening in modern apps.</span> <span data-start="1924210">And we think scheduling is a compelling strategy</span> <span data-start="1926400">for tackling this.</span> <span data-start="1927630">There's an opportunity here for improved scheduling</span> <span data-start="1930180">with existing primitives as well as new primitives.</span> <span data-start="1933570">And frameworks are in a good position</span> <span data-start="1935580">to play a big role here.</span> <span data-start="1937290">In terms of offloading work from the main thread,</span> <span data-start="1940620">you can think of using worker as an extension</span> <span data-start="1942930">to better main thread scheduling.</span> <span data-start="1945300">Some types of work are better suited to worker than others.</span> <span data-start="1948490">And we think new APIs like Task Worklet</span> <span data-start="1952020">are going to be compelling to utilize worker for scheduling.</span> <span data-start="1957060">So that's about it.</span> <span data-start="1959120">We'll have a blog post coming with more details.</span> <span data-start="1961950">These are, again, the links to the GitHub repos.</span> <span data-start="1965450">Issues on the repos are very welcome and appreciated</span> <span data-start="1969190">and a great way too for the feedback loop.</span> <span data-start="1972050">And do not hesitate to reach out to us on email or Twitter.</span> <span data-start="1976070">Thank you.</span> <span data-start="1976580">[MUSIC PLAYING]</span> </section>

</div>

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    },
    'google_translate_element');
}
/* eslint-enable */
</script>

  <script src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

  <script src="https://www.youtube.com/iframe_api"></script>
  <script src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

  <script src="https://www.youtube.com/iframe_api"></script>
</body>

</html>
