<!DOCTYPE html>

<! — 
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 — >

<html lang="en">
<head>
<meta charset="utf-8">
<meta name="author" content="//google.com">
<meta name="description" content="Chrome Dev Summit">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>25aCD5XL1Jk</title>
<link rel="stylesheet" href="css/main.css">
</head>

<body>

<div id="video"></div>

<iframe id="youtube" src="https://www.youtube.com/embed/Ai4aZ9Jbsys?enablejsapi=1"></iframe>

<div id="container">

<div id="google-translate"></div>

<section>
<span data-start="0">[MUSIC PLAYING]</span> </section>

<section><span data-start="7186"><span class="speaker">Phil Walton</span>: Hey, everyone.</span> <span data-start="8310">My name is Philip Walton.</span> <span data-start="9140">I'm an engineer on the Chrome team working on web performance</span> <span data-start="11681">and Service Worker tooling.</span> </section>

<section><span data-start="13310"><span class="speaker">Ewa Gasperowicz</span>: And I'm Ewa.</span> <span data-start="14518">I'm also an engineer on the Chrome team.</span> <span data-start="16360">Today we're going to talk about Service Worker from the speed</span> <span data-start="19820">and resilience perspective.</span> <span data-start="22130">We'll look into how our decisions regarding Service</span> <span data-start="24860">Worker implementation can influence,</span> <span data-start="27470">both positively and negatively, our site's performance.</span> <span data-start="31130">And we hope that by the end of this talk,</span> <span data-start="32930">you'll have a really good understanding</span> <span data-start="35150">of all the trade-offs involved in using this more and more</span> <span data-start="38690">mainstream technology.</span> </section>

<section><span data-start="40185"><span class="speaker">Phil Walton</span>: So Ewa, I noticed you said</span> <span data-start="41810">Service Worker was mainstream.</span> <span data-start="43060">What makes you say that?</span> </section>

<section><span data-start="44139"><span class="speaker">Ewa Gasperowicz</span>: Well, Service Worker</span> <span data-start="45680">is now supported in all modern browsers, which</span> <span data-start="48380">means you can move from treating this</span> <span data-start="50630">as a pure progressive enhancement</span> <span data-start="53510">and treat it as a core part of your site's architecture.</span> <span data-start="57050">Service Worker can do many things, but in this talk</span> <span data-start="59390">we'll focus especially on its caching capabilities.</span> <span data-start="63960">Often when we think about Service Worker and caching,</span> <span data-start="66900">we usually associate it with providing offline support.</span> <span data-start="70830">After all, one of the main achievements of Service Worker</span> <span data-start="73920">was that we finally could get rid of the offline downosaur</span> <span data-start="77730">and send him to the well-deserved retirement.</span> <span data-start="82170">But apart from that, Service Worker</span> <span data-start="85380">can also be a great tool for improving</span> <span data-start="88110">the performance of your online site,</span> <span data-start="91170">especially for your returning users.</span> <span data-start="93630">When used right, it can give you a serious boost in terms</span> <span data-start="96600">of speed on the repeated visit.</span> </section>

<section><span data-start="98997"><span class="speaker">Phil Walton</span>: That's right.</span> <span data-start="100080">And on the other hand, when used incorrectly</span> <span data-start="101913">or without proper analysis, it can actually</span> <span data-start="104280">hamper a site's performance, or even</span> <span data-start="106560">derail the whole experience altogether.</span> <span data-start="109470">So as developers, it's critical that we</span> <span data-start="111300">understand how Service Worker affects</span> <span data-start="113070">the performance of our site.</span> <span data-start="114510">As with any technology, there are both costs and benefits.</span> <span data-start="117211">And we want to maximize the benefits</span> <span data-start="118710">while minimizing the costs.</span> </section>

<section><span data-start="120939"><span class="speaker">Ewa Gasperowicz</span>: Well, using Service Worker</span> <span data-start="122730">brings a lot of benefits in terms of performance.</span> <span data-start="126040">In many cases it allows you to overcome the network latency</span> <span data-start="129750">entirely.</span> <span data-start="130350">For example, if you cache your entire app,</span> <span data-start="132270">you don't need to go to the network anymore.</span> <span data-start="136100">Also, if you have some cached content,</span> <span data-start="138820">you can show it immediately, even</span> <span data-start="140680">if a bit stale, and look for the updates in the background</span> <span data-start="144220">at the same time.</span> <span data-start="147740">It can also make your average requests smaller on average.</span> <span data-start="151590">For example, in the app show model</span> <span data-start="153530">where you're fetching just partial part of your page</span> <span data-start="156650">rather than the full HTML each time.</span> <span data-start="160590">Finally, there are some more subtle benefits.</span> <span data-start="163290">For example, we know that JavaScripts</span> <span data-start="165210">need to be parsed, compiled, and executed before it can be used.</span> <span data-start="169750">This can take time.</span> <span data-start="171130">So engines like V8 use some heuristics</span> <span data-start="174660">to see if they can actually store the bytecode</span> <span data-start="176990">from these phases to be used on repeated visits</span> <span data-start="179940">to avoid this cost.</span> <span data-start="182140">Now in Service Worker, the chances of a repeated visit</span> <span data-start="185010">are pretty high.</span> <span data-start="186220">So it can opt into that optimization</span> <span data-start="189120">automatically for you.</span> <span data-start="191160">This means that it stores the script as bytecode</span> <span data-start="194470">by default, making the repeated visits faster.</span> <span data-start="199020">All these are really good performance reasons</span> <span data-start="201480">to implement Service Worker on your page.</span> <span data-start="204160">But it's not for free.</span> <span data-start="205842">Phil, what are the costs of running</span> <span data-start="207300">Service Worker on your page?</span> </section>

<section><span data-start="208990"><span class="speaker">Phil Walton</span>: Yeah, so the first and arguably most often</span> <span data-start="211350">overlooked cost of Service Worker</span> <span data-start="213079">is that it can take time for the Service Worker process</span> <span data-start="215370">to start up if it's not already running.</span> <span data-start="217681">And this can happen if a user hasn't</span> <span data-start="219180">visited your site in a while.</span> <span data-start="221820">Let me show you what I mean.</span> <span data-start="223440">Consider a basic network first strategy</span> <span data-start="225570">in which the service worker just forwards the request</span> <span data-start="228030">from the web app onto the network</span> <span data-start="229710">and doesn't touch the cache at all.</span> <span data-start="231900">Since this web app is running a service worker,</span> <span data-start="234240">every request then has to go through that service worker,</span> <span data-start="236940">and if the service worker process isn't currently</span> <span data-start="239190">running, the web app has to wait for the browser to spin it up</span> <span data-start="242250">before it can make any request.</span> <span data-start="244927">So let's take a look at the total time</span> <span data-start="246510">it takes to make a request in various scenarios.</span> <span data-start="249750">In the case where the web app isn't using Service Worker,</span> <span data-start="252360">the total time is just the total of network latency.</span> <span data-start="255420">In the case where the web app is using Service Worker</span> <span data-start="257910">and that service worker is already running,</span> <span data-start="260321">there is a little bit of extra cost</span> <span data-start="261779">because it has to go through the service worker — </span> <span data-start="263520">the request has to go through the service worker — </span> <span data-start="265080">but that cost isn't usually too high.</span> <span data-start="266900">However, in the case where the service worker is not running</span> <span data-start="269400">and needs to boot up, that startup time</span> <span data-start="271470">can really delay the response.</span> </section>

<section><span data-start="273907"><span class="speaker">Ewa Gasperowicz</span>: So in cases like this</span> <span data-start="275490">where the service worker is actually not</span> <span data-start="277156">running on the page, how long does it usually</span> <span data-start="279780">take to boot up?</span> </section>

<section><span data-start="280447"><span class="speaker">Phil Walton</span>: So that's a good question.</span> <span data-start="282071">And the honest answer is it depends on the user's device,</span> <span data-start="284984">but fortunately there is an easy way you</span> <span data-start="286650">can measure this cost yourself.</span> <span data-start="289000">So this code here uses the performance timeline</span> <span data-start="290970">to get performance data for a particular URL.</span> <span data-start="293132">If the request for the URL went through the service worker,</span> <span data-start="295590">then the worker start property on the performance entry</span> <span data-start="297900">will mark the moment right before the service</span> <span data-start="299775">worker was run.</span> <span data-start="300930">And the request start property will</span> <span data-start="302430">mark the moment the service worker received</span> <span data-start="304230">the fetch event.</span> <span data-start="305134">So the difference between these two timestamps</span> <span data-start="307050">is the total time it took for the worker to start up.</span> <span data-start="310351">And if the service worker process was already running,</span> <span data-start="312600">this time will be usually zero or close to zero.</span> <span data-start="315299">And so I actually measure service worker start up</span> <span data-start="317340">time on my website, philipwalton.com, and here's</span> <span data-start="319950">what I found when looking at my own data.</span> <span data-start="322105">When users visits my site for the first time —  or, sorry,</span> <span data-start="324480">for the first time after installing the service worker — </span> <span data-start="326990">it's already running only about 25% of the time.</span> <span data-start="329870">That means 75% of the time the service worker is not running</span> <span data-start="332850">and needs to take some time to start up.</span> <span data-start="334980">For those cases, I found that on desktop it's</span> <span data-start="338010">usually between 20 and 100 milliseconds to start up,</span> <span data-start="340950">but on mobile it can be more like 100 to 500 milliseconds,</span> <span data-start="344010">and at the 95th percentile, sometimes it's</span> <span data-start="346170">more than a second.</span> <span data-start="347620">So let me reiterate, these are stats from my website.</span> <span data-start="349950">The numbers you see might be different,</span> <span data-start="351750">but this should give you a general idea</span> <span data-start="353880">of what's possible.</span> <span data-start="356011">Another cost of using Service Worker is that the cache reads</span> <span data-start="358510">aren't always instant.</span> <span data-start="360140">And this affects any caching strategy</span> <span data-start="361930">where the service worker has to wait for the cache</span> <span data-start="364013">to either miss or error before it can go to the network.</span> <span data-start="367559">We saw before that a network first strategy</span> <span data-start="369350">can be slow when you're not using Service Worker at all.</span> <span data-start="372157">But what about strategies that use cache, or start</span> <span data-start="374240">with the cache, anyway?</span> <span data-start="375519">A cache first strategy will initially</span> <span data-start="377060">look for a response in the cache, and if one is found</span> <span data-start="380060">it'll be used.</span> <span data-start="380924">But if it's not found or there's a timeout or error,</span> <span data-start="383090">like I mentioned, it will fall back to the network.</span> <span data-start="385799">So here's how the performance of cache first strategies</span> <span data-start="388090">break down in different scenarios.</span> <span data-start="390450">The most common case is going to be</span> <span data-start="391910">the one at the top, which is very fast when</span> <span data-start="393860">there's a cache hit.</span> <span data-start="395980">But this is not the only possibility.</span> <span data-start="397840">There could also be a cache miss,</span> <span data-start="399670">there could be a slow cache, you could have a timeout — </span> <span data-start="402617">remember, there's also the possibility</span> <span data-start="404200">of the service worker isn't running</span> <span data-start="405658">and so then that could delay it as well.</span> <span data-start="407840">All of these bad cases could happen at the same time.</span> <span data-start="411170">So while it's definitely possible to have a cache</span> <span data-start="413410">first strategy that's faster than not using a service</span> <span data-start="416080">worker, look at how many of these examples</span> <span data-start="418420">end up being slower.</span> </section>

<section><span data-start="419299"><span class="speaker">Ewa Gasperowicz</span>: So Phil.</span> <span data-start="420340">I'm wondering how likely is it that the slow cases actually</span> <span data-start="424300">occur.</span> <span data-start="425110">Is it measurable somehow?</span> </section>

<section><span data-start="426250"><span class="speaker">Phil Walton</span>: Yeah.</span> <span data-start="427000">So this is also measurable.</span> <span data-start="428920">It's a little bit trickier than the last example I was showing.</span> <span data-start="431950">So this, the same way, uses the performance timeline,</span> <span data-start="435700">and you can look at the entries transfer size property.</span> <span data-start="439120">If the transfer size is zero, that</span> <span data-start="440737">means the request either came from the cache</span> <span data-start="442570">or came from the service worker.</span> <span data-start="443952">For requests that you know are being handled by the service</span> <span data-start="446410">worker because you set up a route for that URL,</span> <span data-start="448660">you can look at the time between the response start</span> <span data-start="450784">property and the request start property</span> <span data-start="452830">and see the total strategy time.</span> <span data-start="455530">Of course, that doesn't tell you if it was just handled</span> <span data-start="458020">by the cache, if it was handled by cache and the network.</span> <span data-start="460900">If you need more granular timing data into that stuff,</span> <span data-start="464890">then you have to add these performance</span> <span data-start="466690">marks in your service worker itself.</span> <span data-start="468190">You can use something like performance.now.</span> <span data-start="470410">and then post message this data back to the window.</span> <span data-start="472535">It's a bit clunky at the moment, to be honest,</span> <span data-start="474460">but we have a new API proposal for fetch event work timing</span> <span data-start="477880">that should make this easier in the future.</span> <span data-start="479800">And it is a proposal right now.</span> <span data-start="481460">So if you want to offer feedback on the design,</span> <span data-start="483940">go to this short link here on the slide,</span> <span data-start="487000">and we love your feedback, and you can chime in.</span> <span data-start="490771">So the last call that we want to point out</span> <span data-start="492520">is that requests made from within the service worker</span> <span data-start="495240">can sometimes compete with higher priority</span> <span data-start="496990">requests on the window.</span> <span data-start="499280">And the cause of this is usually overaggressive pre-caching</span> <span data-start="502196">or pre-caching before the window has finished</span> <span data-start="504070">loading all of its resources.</span> <span data-start="505940">So for example, if you're pre-caching literally</span> <span data-start="508090">every single asset on your website,</span> <span data-start="510730">you could potentially get to a situation</span> <span data-start="512409">where those pre-cache requests get</span> <span data-start="514030">queued ahead of more important requests that the user needs.</span> <span data-start="518919">So while APIs like priority hints</span> <span data-start="520470">can solve this issue somewhat, the recommended approach right</span> <span data-start="523500">now is just to wait to register your service worker</span> <span data-start="526350">until after the load event.</span> </section>

<section><span data-start="529087"><span class="speaker">Ewa Gasperowicz</span>: OK.</span> <span data-start="529920">Thanks, Phil, for the thorough walkthrough through the costs.</span> <span data-start="533010">So once we know all this and we know how to measure it,</span> <span data-start="536550">how does this translate into the design of Service Worker?</span> <span data-start="540450">Well, usually there are three sources the service worker gets</span> <span data-start="543870">content from, either from network, either from the cache,</span> <span data-start="547620">or it can also generate it on the fly,</span> <span data-start="549480">for example, by using some templating logic.</span> <span data-start="552930">When designing Service Worker, your role</span> <span data-start="555240">is to find a combination of these three sources</span> <span data-start="558690">that is the most efficient for the use</span> <span data-start="560790">cases on your web pages.</span> <span data-start="562620">This is the serving strategy of Service Worker.</span> <span data-start="565860">Of course, in order to use anything from the cache,</span> <span data-start="568170">we need to populate it first with the resources first.</span> <span data-start="570540">And this is the caching strategy of Service Worker.</span> <span data-start="574690">Taking all these aspects into account can be quite daunting,</span> <span data-start="578140">but fortunately there are tools that make it easier.</span> <span data-start="581000">For example, Workbox is a set of libraries</span> <span data-start="583510">that make it easy to cache assets</span> <span data-start="585460">and take advantage of Service Worker features and related</span> <span data-start="588610">APIs.</span> <span data-start="590200">In this talk we'll focus on the general design principles</span> <span data-start="593770">that you can implement yourself in Service Worker.</span> <span data-start="596870">But we will also call out some of the Workbox features</span> <span data-start="600130">that can help you out in some common scenarios.</span> </section>

<section><span data-start="603037"><span class="speaker">Phil Walton</span>: OK, so let's start with looking</span> <span data-start="604870">at the serving strategies for Service Worker implementations.</span> <span data-start="608419">And given what we said about the costs that can be associated</span> <span data-start="610960">with using Service Worker, you're probably wondering,</span> <span data-start="613314">is it possible to avoid these costs entirely and make sure</span> <span data-start="615730">that my site actually loads faster than it would have</span> <span data-start="618250">without the service worker?</span> <span data-start="621130">So the first and arguably most important step</span> <span data-start="623390">in building a fast site with A Service worker</span> <span data-start="625970">is an understanding of which requests</span> <span data-start="628070">are most important to optimize.</span> <span data-start="629900">So broadly speaking, there are two types</span> <span data-start="631850">of requests, navigation requests and resource requests.</span> <span data-start="634880">Navigation requests are for your full HTML pages</span> <span data-start="637610">and resource requests are for the assets</span> <span data-start="639680">like JavaScript, CSS, and images that those pages then</span> <span data-start="643790">reference.</span> <span data-start="644810">So in my experience with talking to other developers</span> <span data-start="647300">about Service Worker implementations,</span> <span data-start="648987">I found that most people are generally</span> <span data-start="650570">pretty good at responding to resource requests</span> <span data-start="652820">from the cache, but unfortunately I</span> <span data-start="655310">don't see a lot of people responding to navigation</span> <span data-start="658220">requests from the cache.</span> <span data-start="659751">And that's really too bad, because navigation requests</span> <span data-start="662000">are typically where the biggest performance gains can be made.</span> <span data-start="665730">So here's why.</span> <span data-start="666767">The key difference between resource requests</span> <span data-start="668600">and navigation requests is that navigation requests are likely</span> <span data-start="672050">already being cached by the browser.</span> <span data-start="675000">In addition, you can already use APIs</span> <span data-start="676730">like link rel preload to warm the HTTP</span> <span data-start="679330">cache for future requests.</span> <span data-start="681080">So if all your service worker is doing</span> <span data-start="683180">is pre-caching static resources, you're</span> <span data-start="685430">essentially just recreating what the browser is already</span> <span data-start="688100">doing for you.</span> <span data-start="689660">Navigation requests, on the other hand,</span> <span data-start="691500">are completely different.</span> <span data-start="692750">In general it's not recommended to put caching headers on pages</span> <span data-start="696200">that you navigate to because, obviously the content might</span> <span data-start="698840">change but the URL doesn't, and so that can get you</span> <span data-start="701240">into trouble.</span> <span data-start="702471">Which means that navigation requests</span> <span data-start="703970">don't benefit from the HTTP cache in the same way</span> <span data-start="706910">that resource requests do.</span> <span data-start="708500">They also don't work with APIs like link rel preload.</span> <span data-start="711690">And to top all that off, navigation requests are</span> <span data-start="713690">typically the ones that will encounter a service</span> <span data-start="716630">worker that's not running, whereas resource requests,</span> <span data-start="719690">by the time the service worker starts up the navigation</span> <span data-start="722100">requests, it's already running and so those work just fine.</span> <span data-start="724980">So don't get me wrong.</span> <span data-start="726074">I'm not suggesting that you ignore resource requests</span> <span data-start="728240">and don't cache them.</span> <span data-start="729115">You should cache them, because that can give you more control</span> <span data-start="731962">and you can get the bytecode optimization</span> <span data-start="733670">that Ewa mentioned.</span> <span data-start="735081">But what I am suggesting is that if you want your site</span> <span data-start="737330">to be as fast as possible you have</span> <span data-start="739280">to respond to navigation requests from the cache</span> <span data-start="741560">as well.</span> <span data-start="743580">So here are three practical and concrete ways</span> <span data-start="745670">you can speed up navigation requests</span> <span data-start="747740">and avoid most of the Service Worker costs</span> <span data-start="749780">that I mentioned earlier.</span> <span data-start="751580">First, as I just said, respond to navigation requests</span> <span data-start="754670">from the cache.</span> <span data-start="755750">Even if you eventually need to go to the network,</span> <span data-start="757820">you should respond with something</span> <span data-start="759195">right away so the user understands</span> <span data-start="761960">that it's happening, that the request is working.</span> <span data-start="764990">A simple way to do this with Workbox</span> <span data-start="767060">is to use either a cache first strategy or a stale while</span> <span data-start="769700">revalidate strategy.</span> <span data-start="771140">Personally, I like stale while revalidate</span> <span data-start="772850">because it gives you an opportunity</span> <span data-start="773960">to check for updates in the background,</span> <span data-start="775880">and then you can notify the user if there's new content.</span> <span data-start="779570">In terms of performance, as you can see,</span> <span data-start="781760">responding from the cache is generally faster</span> <span data-start="783770">when not using a service worker.</span> <span data-start="785382">And that's even true in cases where the service</span> <span data-start="787340">worker's asleep and needs to start up, or in cases</span> <span data-start="789530">where the cache is slow.</span> <span data-start="791580">The only situation it's worse is when there's a cache miss</span> <span data-start="794142">and you have to go to the network anyway.</span> <span data-start="795850">But that's to be expected.</span> <span data-start="798160">So I know what many of you here are probably thinking.</span> <span data-start="800560">There's absolutely no way that I can respond to all navigation</span> <span data-start="805120">requests with cache content.</span> <span data-start="806800">I need my content to be up to date.</span> <span data-start="808300">I need it to be fresh.</span> <span data-start="809320">And this is true.</span> <span data-start="810028">Many apps just simply cannot provide value with stale</span> <span data-start="812811">content.</span> <span data-start="813310">They have to have fresh content.</span> <span data-start="815390">But just because you need to fetch something</span> <span data-start="817997">from the network doesn't mean that you</span> <span data-start="819580">need to fetch the entire HTML page from the network.</span> <span data-start="822640">So my second tip is that when the network content is truly</span> <span data-start="825580">required, fetch just the minimum amount of content you need,</span> <span data-start="829420">and then combine that content with other parts</span> <span data-start="832060">of the page, which should already be in the cache.</span> <span data-start="834280">And even better is if you can combine</span> <span data-start="835821">that content in the form of a streaming response to the user.</span> <span data-start="839200">So let me show you an example of what I mean by that.</span> <span data-start="842291">A lot of HTML pages have a structure</span> <span data-start="843790">that looks something like this.</span> <span data-start="845180">You have kind of a head section, a header, navigation, sidebar,</span> <span data-start="848110">footer, and lot of these sections of the page</span> <span data-start="850030">repeat on every single page throughout your site.</span> <span data-start="853660">The only thing that changes is often a single content area,</span> <span data-start="856360">like you can see here.</span> <span data-start="857880">So in these types of situations, clearly</span> <span data-start="860320">it's more efficient to just fetch</span> <span data-start="861970">the stuff that's changed rather than fetching all of that stuff</span> <span data-start="864700">every time.</span> <span data-start="865454">If you've ever built a single page application</span> <span data-start="867370">you're probably kind of familiar with this concept,</span> <span data-start="869495">though the streaming part might be new to you.</span> <span data-start="872300">So here's a visualization of the performance breakdown</span> <span data-start="874690">between traditional network responses</span> <span data-start="877060">and a streaming response that combines network</span> <span data-start="879070">content with cache content.</span> <span data-start="881720">So in the example on top, since the network request</span> <span data-start="884710">is for the full HTML page, you can see it takes a long time,</span> <span data-start="887806">and in the example on the bottom,</span> <span data-start="889180">the network request is for a smaller part of the HTML,</span> <span data-start="892349">and so there's less data to be transferred.</span> <span data-start="894140">So it will typically take less time.</span> <span data-start="896540">In addition, the cached content can be fetched in parallel</span> <span data-start="900010">with the network content so it doesn't</span> <span data-start="901780">add to the total time it takes to make the request.</span> <span data-start="905170">And lastly —  and this is the best part about streaming — </span> <span data-start="908470">since it is a stream, we don't have</span> <span data-start="909940">to wait until all the content is available to start</span> <span data-start="912370">sending something to the user.</span> <span data-start="914110">As soon as we have the cached content</span> <span data-start="916060">from the start of the page, the header section,</span> <span data-start="918130">we can send it to the user right away.</span> <span data-start="919847">And then we can just add to the stream</span> <span data-start="921430">once we get more network content in later.</span> <span data-start="924380">So the overall experience is a much faster time to first byte</span> <span data-start="927790">and then a faster time overall as well</span> <span data-start="931420">If you've never used streams before, you</span> <span data-start="933130">might be a little bit scared of the idea.</span> <span data-start="934846">You might think it's complicated.</span> <span data-start="936220">But actually, with Workbox it's really easy.</span> <span data-start="939230">So what you do is you just register a route like you would</span> <span data-start="941770">do with any Workbox strategy, and then</span> <span data-start="944830">you invoke the strategy function from the Workbox streams</span> <span data-start="947770">package.</span> <span data-start="949610">The strategy function takes an array of other Workbox</span> <span data-start="951920">strategies and each of these is expected</span> <span data-start="954260">to resolve to a response that you then stitch together,</span> <span data-start="956870">and Workbox stitches it together in the form of a stream.</span> <span data-start="960170">In this case, I'm using cache first</span> <span data-start="962540">for the header part and footer part,</span> <span data-start="964580">and I'm using network first for the content</span> <span data-start="966720">so I can make sure that it's fresh.</span> <span data-start="969075">And that's really it.</span> <span data-start="969950">Workbox takes care of merging this concept together</span> <span data-start="971990">in a stream, and if the browser doesn't support</span> <span data-start="973948">streams it automatically falls back to a single text response.</span> <span data-start="979180">And because the strategy requests</span> <span data-start="980556">less content from the network and because it</span> <span data-start="982388">can read from the cache in parallel,</span> <span data-start="984030">it's typically quite a bit faster</span> <span data-start="985740">than the no service worker case.</span> <span data-start="987356">Of course, the actual speed differences</span> <span data-start="988980">will depend on the size of the content area</span> <span data-start="991620">relative to the entire HTML page.</span> <span data-start="993439">And that will vary from site to site.</span> <span data-start="994980">But in general, streaming cache content with network content</span> <span data-start="997800">is one of the fastest ways to respond to navigation requests.</span> <span data-start="1001544">I say one of the fastest ways because there actually</span> <span data-start="1003710">is one more optimization that we can get this even faster.</span> <span data-start="1008160">So the last technique for speeding up</span> <span data-start="1009770">navigations that I want to talk about</span> <span data-start="1011330">is a new API called Navigation Preload, which</span> <span data-start="1014120">allows you to make the navigation request in parallel</span> <span data-start="1017240">with the service worker starting up,</span> <span data-start="1019250">essentially eliminating that Service Worker boot up cost</span> <span data-start="1021740">that I mentioned before.</span> <span data-start="1024240">So by now you've probably seen this chart many times.</span> <span data-start="1026690">You understand that the Service Worker boot up time can</span> <span data-start="1029359">extend the navigation request.</span> <span data-start="1031010">So with Navigation Preload, what you do is</span> <span data-start="1032810">you just do these requests in parallel.</span> <span data-start="1035920">And the way that this works is the browser that</span> <span data-start="1039369">sets this Service Worker navigation preload header</span> <span data-start="1043910">on the preload request, and then that allows your server</span> <span data-start="1047150">to respond to this request as it would have had the request</span> <span data-start="1050990">come directly from the service worker itself.</span> <span data-start="1053460">So for example, if you're using the streaming partials strategy</span> <span data-start="1056780">that I just discussed, you could respond</span> <span data-start="1059420">to the navigation preload request the same</span> <span data-start="1061340">as you would have if it had come from the service worker.</span> <span data-start="1065120">To use Navigation Preload, it's relatively easy.</span> <span data-start="1067790">All you have to do is enable it — </span> <span data-start="1069540">you probably want to feature detect first,</span> <span data-start="1071290">but then you enable it at any point in the lifecycle, really,</span> <span data-start="1074470">but it's often best to do it in the activate event.</span> <span data-start="1076990">And then once you've enabled it, fetch events</span> <span data-start="1078880">for navigation requests will have access</span> <span data-start="1080546">to a preload response property which you can then</span> <span data-start="1083440">use however you want.</span> <span data-start="1086419">And looking at the performance of this technique,</span> <span data-start="1088460">you'll see how navigation requests with Navigation</span> <span data-start="1091940">Preload are even faster than the already fast streaming example.</span> <span data-start="1098630">And one last thing I want to say about Navigation Preload</span> <span data-start="1101157">is that you really only want to use it</span> <span data-start="1102740">in cases where you know you're going to have to make a network</span> <span data-start="1107240">request on navigations.</span> <span data-start="1109170">If you can use just the cache first strategy to respond</span> <span data-start="1111500">to navigations, then that ends up being faster</span> <span data-start="1113850">and then you waste the network request.</span> <span data-start="1116420">So in general, only use it if you</span> <span data-start="1117920">know that you have to use content from the network.</span> <span data-start="1120860">So to summarize everything I've said so far, even though there</span> <span data-start="1123579">are definitely some costs associated with using Service</span> <span data-start="1125870">Worker, with the proper serving strategy you can easily</span> <span data-start="1128720">overcome these costs and you can end up</span> <span data-start="1130550">with a even faster loading site than what you could have</span> <span data-start="1133790">done without Service Worker.</span> </section>

<section><span data-start="1136750"><span class="speaker">Ewa Gasperowicz</span>: OK.</span> <span data-start="1138070">Now let's talk a bit about the caching part of the Service</span> <span data-start="1140841">Worker.</span> <span data-start="1144050">When we think about cache management,</span> <span data-start="1146090">we usually want to achieve the following.</span> <span data-start="1148340">We want to start the right resources at the right time</span> <span data-start="1151310">while controlling the overall size of our application.</span> <span data-start="1154280">We definitely want to prevent quota overflow,</span> <span data-start="1156530">because as developers, we do have quite a bit of storage</span> <span data-start="1159860">space on users' device, but it's not unlimited,</span> <span data-start="1162380">so we need to stick to that.</span> <span data-start="1164130">And we also want our resources to be</span> <span data-start="1165920">as fresh as possible, which means we</span> <span data-start="1167840">need to have efficient updates.</span> <span data-start="1171140">Now when it comes to right resources,</span> <span data-start="1173602">it's good to understand what you actually</span> <span data-start="1175310">want to put in the cache in the first place.</span> <span data-start="1178340">Resources are a little bit like food, you know.</span> <span data-start="1180740">There are the critical ones, really important ones</span> <span data-start="1183500">like some HTML core scripts or basic styles.</span> <span data-start="1187310">This should really get the highest priority</span> <span data-start="1189260">in terms of cache.</span> <span data-start="1190940">Then there are non-critical ones, for example,</span> <span data-start="1194240">images that are not visible straight away,</span> <span data-start="1196640">or some big media files or some additional widgets.</span> <span data-start="1200430">We cache them on the best effort basis.</span> <span data-start="1203460">And finally, there's trash, which</span> <span data-start="1205790">means stuff that should not be there in the first place.</span> <span data-start="1209390">This is the bloat, the unnecessary parts of your page,</span> <span data-start="1211850">like unoptimized images, dead code, unused script, and so on.</span> <span data-start="1217160">Why do we have trash in our pages?</span> <span data-start="1219890">Well, because we're humans and sometimes</span> <span data-start="1222470">our projects are simply not perfect.</span> <span data-start="1226070">This moment, when you're considering</span> <span data-start="1227570">how to shape your caching strategy for Service Worker,</span> <span data-start="1230620">is a great time to stop for a while,</span> <span data-start="1233090">make an audit of your page, and get</span> <span data-start="1235130">rid of all that unnecessary part before they end up</span> <span data-start="1238550">clogging your user's device.</span> <span data-start="1242070">So reviewing your app and understanding</span> <span data-start="1244040">which resources are critical and which are not so critical</span> <span data-start="1247370">will really help you later in designing and updating</span> <span data-start="1250360">your cache in an efficient manner.</span> <span data-start="1253110">Now what about timing?</span> <span data-start="1255550">Usually we cache assets either in the install event of Service</span> <span data-start="1258700">Worker — </span> <span data-start="1259240">that's usually pre-caching —  or later during the runtime</span> <span data-start="1262510">of our application.</span> <span data-start="1264230">Let's compare these two.</span> <span data-start="1265780">So pre-caching is very similar to installing</span> <span data-start="1268570">a ready-made package with your app.</span> <span data-start="1271180">It's great for caching the critical content,</span> <span data-start="1274000">since we know it's most probably going to be needed anyways.</span> <span data-start="1278800">It's relatively easy to implement and to manage</span> <span data-start="1281620">and to update, because you can just replace the whole package</span> <span data-start="1284560">with the new version when needed,</span> <span data-start="1286900">and also because the size of such package</span> <span data-start="1289060">is known beforehand.</span> <span data-start="1291350">On the other hand, when using pre-caching,</span> <span data-start="1293180">you need to make a lot of arbitrary decisions</span> <span data-start="1295820">about what your user is going to need even before they start</span> <span data-start="1299030">interacting with the page, which might lead to the situation</span> <span data-start="1302780">where you cache many more resources than necessary.</span> <span data-start="1307380">Also, as we mentioned before, it can cause network congestion</span> <span data-start="1310970">and compete with the other network requests</span> <span data-start="1313550">from the window.</span> <span data-start="1316240">Runtime caching, on the other hand,</span> <span data-start="1318110">is really great for non-critical assets</span> <span data-start="1320320">because you can draw conclusions from your user's behavior.</span> <span data-start="1323530">For example cache only images they already</span> <span data-start="1326350">accessed, or cache different parts of your app</span> <span data-start="1331480">depending on the user's entry point.</span> <span data-start="1334860">On the other hand, the problem with runtime</span> <span data-start="1336870">is that you need to be really careful about updates</span> <span data-start="1339870">because assets might end up in cache</span> <span data-start="1341940">at different moments in time.</span> <span data-start="1344170">For example, if resources depend on each other,</span> <span data-start="1346440">like you have a script that depends on the markup</span> <span data-start="1349080">and you end up caching incompatible versions of them,</span> <span data-start="1351690">you run into trouble.</span> <span data-start="1352630">So you need to be very careful about versioning.</span> <span data-start="1355800">Also, important thing is that in this case,</span> <span data-start="1358390">the cache will grow over time.</span> <span data-start="1360200">The size is not known beforehand.</span> <span data-start="1362370">So as the user interacts with the app,</span> <span data-start="1365280">the size will be different.</span> <span data-start="1368350">Here's an example.</span> <span data-start="1369580">This is a very simple e-commerce app I built recently.</span> <span data-start="1372780">If I cache pages in this app at runtime</span> <span data-start="1376470">and the homepage is fully cached,</span> <span data-start="1378390">it takes about 150 kilobytes with all the images.</span> <span data-start="1382200">But later when the user navigates to a new category,</span> <span data-start="1384600">like accessories page, it gets added to the cache,</span> <span data-start="1388230">and the overall size grows to 300 kilobytes.</span> <span data-start="1391500">And so on and so on.</span> <span data-start="1392490">As the user interacts with my app, the overall size grows.</span> <span data-start="1396456">If the app is really big it might</span> <span data-start="1397830">be really hard to predict ahead of time how much space it</span> <span data-start="1401010">will take on users' device.</span> <span data-start="1403020">This is why it's so important to control the size of your app</span> <span data-start="1406920">through the runtime.</span> <span data-start="1408770">Phil, can we do it programmatically somehow?</span> </section>

<section><span data-start="1411570"><span class="speaker">Phil Walton</span>: You can.</span> <span data-start="1413220">If you ever need to check your app's current storage usage,</span> <span data-start="1417030">you can use the Storage Manager API which</span> <span data-start="1419640">has an estimate method that returns, both the total quota</span> <span data-start="1423480">as well as the current amount that's being used.</span> </section>

<section><span data-start="1426824"><span class="speaker">Ewa Gasperowicz</span>: Well, it's really</span> <span data-start="1428240">cool that we can estimate that, because it</span> <span data-start="1430620">allows us to proactively control the app size</span> <span data-start="1433410">and prevent quota overflow.</span> <span data-start="1435680">Quota is limited and depends both on users' device</span> <span data-start="1439170">and also on the amount of currently available space</span> <span data-start="1442530">on the device.</span> <span data-start="1443920">So you can't just throw assets into the cache</span> <span data-start="1446460">and assume it will never fill up.</span> <span data-start="1448830">You always need to have a plan on how to remove</span> <span data-start="1451680">old or unnecessary assets.</span> <span data-start="1453589">After all, you don't want a situation</span> <span data-start="1455130">where you can't update some critical script</span> <span data-start="1457830">because your cache is full of cat videos.</span> <span data-start="1463500">Here are some things that can help</span> <span data-start="1465000">you to stay below the quota.</span> <span data-start="1467160">As we mentioned before, you can store</span> <span data-start="1469440">partials of your pages instead of full HTML</span> <span data-start="1472710">to avoid duplication and save some space.</span> <span data-start="1475920">You can also separate your critical and non-critical</span> <span data-start="1478740">assets into different caches with different names,</span> <span data-start="1481920">so that you can evict the non-critical ones when needed</span> <span data-start="1485220">without touching the rest.</span> <span data-start="1488150">Finally, you can also cache some resources</span> <span data-start="1491150">only if there is plenty of space, like conditionally.</span> <span data-start="1494210">Or you can put size or maximum number of entries constraints</span> <span data-start="1498080">on your cache.</span> <span data-start="1499340">I think this is something Workbox can help us with.</span> </section>

<section><span data-start="1501620"><span class="speaker">Phil Walton</span>: Yeah.</span> <span data-start="1502370">With Workbox you can easily manage the rules</span> <span data-start="1504620">for how and when cache entries should expire with the Cache</span> <span data-start="1507890">Expiration plugin.</span> <span data-start="1509210">And you can use it with any of the Workbox strategies.</span> <span data-start="1512630">So you configure both a max number of entries per cache</span> <span data-start="1515450">or a max age for each entry.</span> <span data-start="1517770">You can also configure the plugin</span> <span data-start="1520000">to automatically purge all entries if there</span> <span data-start="1522207">is any kind of quota error or anything</span> <span data-start="1523790">like that, which is usually a good thing</span> <span data-start="1525456">to do when you have a non-critical asset cache.</span> </section>

<section><span data-start="1529590"><span class="speaker">Ewa Gasperowicz</span>: OK, now a few words about updating the cache.</span> <span data-start="1533220">The simplest solution is what I call the nuke approach, which</span> <span data-start="1536670">means you clear all your caches and start fresh every time</span> <span data-start="1539640">your service worker updates.</span> <span data-start="1541440">It's very easy to implement, but it's not</span> <span data-start="1543930">very efficient nor kind to your user's data plans.</span> <span data-start="1547740">So you should be more granular about what you update and when.</span> <span data-start="1550990">And if you want to be more granular,</span> <span data-start="1553230">you need to properly tag your assets</span> <span data-start="1555450">so that you know which ones are compatible with each other.</span> <span data-start="1559450">You can use the content-based hashes</span> <span data-start="1561210">in the file name of the given resource,</span> <span data-start="1563790">or provide revision data on each asset</span> <span data-start="1566130">so that you can manage it in Service Worker later on.</span> <span data-start="1569550">This process can be very error-prone when done manually,</span> <span data-start="1572370">so fortunately we have tools to help with that as well.</span> </section>

<section><span data-start="1574770"><span class="speaker">Phil Walton</span>: Yeah, with the Workbox pre-caching package,</span> <span data-start="1577680">you don't have to manually manage the update</span> <span data-start="1580350">process yourself at all.</span> <span data-start="1581400">It has an asset manifest that maps file URLs</span> <span data-start="1584970">to their revision hashes, and that</span> <span data-start="1587280">allows it to remove old assets and fetch</span> <span data-start="1589350">new ones without having to touch any of the unchanged assets.</span> <span data-start="1592860">It makes the upgrade process really efficient.</span> <span data-start="1595880">Workbox also has both Gulp and Webpack plugins, as well as</span> <span data-start="1599970">a CLI, so you can easily generate</span> <span data-start="1601920">this asset manifest yourself.</span> </section>

<section><span data-start="1605210"><span class="speaker">Ewa Gasperowicz</span>: As you can see, Workbox makes a lot of things</span> <span data-start="1608000">easier for us as developers so that we</span> <span data-start="1610370">can focus on what matters most, and that's the user.</span> <span data-start="1614300">And users can really vary.</span> <span data-start="1618110">They can be of different background,</span> <span data-start="1619610">they can use our app at home or on the go,</span> <span data-start="1622550">they can use more or less advanced devices</span> <span data-start="1624860">or have different access to data and connectivity.</span> <span data-start="1628790">There are some things we can do to accommodate</span> <span data-start="1631820">those differences.</span> <span data-start="1634280">First of all, when working on performance,</span> <span data-start="1636030">never assume the environment you work in</span> <span data-start="1638190">is representative of your whole user base.</span> <span data-start="1640559">For example, you should always throttle your network</span> <span data-start="1642725">to 3G speed when testing to get a more realistic feel</span> <span data-start="1646320">for your performance.</span> <span data-start="1649060">Secondly, keep in mind those underpowered devices</span> <span data-start="1652120">with little storage and really control the size of your app.</span> <span data-start="1655630">Remember that the overall size of your app</span> <span data-start="1657490">might grow over time if you use runtime caching,</span> <span data-start="1660070">and plan accordingly.</span> <span data-start="1662750">Also, sometimes there are actually</span> <span data-start="1664630">explicit hints from the user that you can</span> <span data-start="1667060">use in your decision making.</span> <span data-start="1669280">For example, you can refrain from speculatively pre-caching</span> <span data-start="1672970">future resources if the Data Saver mode is turned on.</span> <span data-start="1677080">When user enables this feature in Chrome,</span> <span data-start="1679690">the save data header is being sent with each request.</span> <span data-start="1682310">So you can detect it and, for example,</span> <span data-start="1684760">refrain from aggressive pre-caching</span> <span data-start="1686240">a lot of future assets.</span> <span data-start="1688900">Similarly, you can use the Network Information API</span> <span data-start="1692320">effective type method to differentiate your strategy</span> <span data-start="1695500">based on the current network condition of the user.</span> <span data-start="1699580">Finally, you can also consider scenarios</span> <span data-start="1702340">where you give the user the full control over the experience.</span> <span data-start="1705590">For example, you provide save for later button, where</span> <span data-start="1708640">a user can explicitly opt in and decide to get something stored</span> <span data-start="1712570">for future use.</span> <span data-start="1714980">Putting the user first can really</span> <span data-start="1716450">benefit the quality of your app, especially</span> <span data-start="1719420">in the long term development horizon.</span> </section>

<section><span data-start="1722754"><span class="speaker">Phil Walton</span>: So to wrap up, I know</span> <span data-start="1724170">we've presented a lot of content today,</span> <span data-start="1725910">and we don't expect you to remember everything.</span> <span data-start="1729027">If you want to learn more about Service Worker best practices,</span> <span data-start="1731610">we've launched a new section on web.dev</span> <span data-start="1733980">with content dedicated to building fast and resilient web</span> <span data-start="1736696">applications with Service Worker.</span> <span data-start="1738070">So definitely check that out.</span> <span data-start="1740170">Also, we've just released a V4 beta of Workbox</span> <span data-start="1743100">with lots of cool new features, and we'd</span> <span data-start="1745260">love your feedback on GitHub before the public release.</span> <span data-start="1748740">And finally, just a few key points</span> <span data-start="1750750">we want to leave you with.</span> <span data-start="1751990">First, definitely have a plan.</span> <span data-start="1754740">You can't just assume that adding Service Worker to a site</span> <span data-start="1757290">will magically make it faster, because without an optimization</span> <span data-start="1760800">plan it probably won't.</span> <span data-start="1763200">Second, don't just reinvent the HTTP cache</span> <span data-start="1766110">inside of your service worker, and don't just</span> <span data-start="1768690">cache static resources.</span> <span data-start="1770212">If that's all you're doing, you're not actually</span> <span data-start="1772170">optimizing your site for Service Worker</span> <span data-start="1773940">and you might even be making it slower.</span> <span data-start="1776460">Third, remember that navigation requests are</span> <span data-start="1778770">the most important requests to optimize,</span> <span data-start="1781830">and you should always try to respond to them from the cache.</span> <span data-start="1785310">Fourth, measure the real user performance</span> <span data-start="1788280">of your implementations and make future performance decisions</span> <span data-start="1791550">based on data.</span> <span data-start="1792660">Don't just guess.</span> <span data-start="1794400">Fifth, control the size of your app</span> <span data-start="1796470">and how much you store on the user's device.</span> <span data-start="1799450">And last but definitely not least, respect the user,</span> <span data-start="1802050">respect their data, and respect their preferences.</span> <span data-start="1805720">Thank you.</span> <span data-start="1806220">If you have any questions, feel free to find either of us</span> <span data-start="1808595">afterwards, or hit us up on Twitter and ask questions.</span> <span data-start="1812130">That's it, yeah.</span> </section>

<section><span data-start="1813060"><span class="speaker">Ewa Gasperowicz</span>: Thank you.</span> <span data-start="1814184">[MUSIC PLAYING]</span> </section>

</div>

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="js/main.js"></script>

</body>

</html>
