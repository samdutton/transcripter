<!DOCTYPE html>

<! — 
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 — >

<html lang="en">
<head>
<meta charset="utf-8">
<meta name="author" content="//google.com">
<meta name="description" content="Chrome Dev Summit">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>reztLS3vomE</title>
<link rel="stylesheet" href="css/main.css">
</head>

<body>

<div id="video"></div>

<iframe id="youtube" src="https://www.youtube.com/embed/Ai4aZ9Jbsys??enablejsapi=1"></iframe>

<div id="container">

<div id="google-translate"></div>

<section>
<span data-start="0">[MUSIC PLAYING]</span> </section>

<section><span data-start="6482"><span class="speaker">Katie Hempenius</span>: Today, Houssein and I</span> <span data-start="8065">are going to talk with you about how</span> <span data-start="9564">you can make your site fast.</span> <span data-start="11060">We're going to focus on three things, images,</span> <span data-start="15200">web fonts, and JavaScript.</span> <span data-start="18550">We've chosen to focus on these three things</span> <span data-start="20560">because they are the three largest</span> <span data-start="22150">components of most websites.</span> <span data-start="25540">In addition, they're likely to be the three largest components</span> <span data-start="28900">of your performance budget.</span> <span data-start="32980">We hope that after this presentation,</span> <span data-start="34700">you'll go home and make changes to your website.</span> <span data-start="37310">Know that during this process, you</span> <span data-start="38860">can lean on both Lighthouse and web.dev</span> <span data-start="41260">for additional resources.</span> <span data-start="43090">Almost everything we cover today can be audited by Lighthouse.</span> <span data-start="46360">In addition, at web.dev can find guides, code samples, and demos</span> <span data-start="50650">of everything we cover today.</span> <span data-start="53850">So let's start by talking about images.</span> <span data-start="56800">Images are taking over the web.</span> <span data-start="59070">On many sites, images alone would consume</span> <span data-start="61750">the entire performance budget.</span> <span data-start="64720">On some sites, it would far exceed that.</span> <span data-start="68200">I think the reason why these numbers are so bad</span> <span data-start="70450">lies in the fact that performant images are</span> <span data-start="72670">the result of many steps and optimizations.</span> <span data-start="75610">As a result, they're not going to happen accidentally.</span> <span data-start="80150">A performant image is the appropriate format,</span> <span data-start="83810">is appropriately compressed, is appropriate for the display,</span> <span data-start="89200">and is loaded only when necessary.</span> <span data-start="92650">To be successful with images, it's</span> <span data-start="94450">imperative that you automate and systematize these things.</span> <span data-start="98270">Not only is this going to save you time,</span> <span data-start="100030">but it's going to ensure that these things actually get done.</span> <span data-start="104310">There's much more to images than meets the eye.</span> <span data-start="107240">At a bits and bytes level, an image</span> <span data-start="109010">is as much a byproduct of its image format</span> <span data-start="111320">and its compression as its visual subject matter.</span> <span data-start="115250">You can think about image formats</span> <span data-start="116840">as choosing the right tool for the job.</span> <span data-start="119439">The image format that you choose will</span> <span data-start="120980">determine what features and image has, for instance,</span> <span data-start="123540">whether it supports transparency or animation,</span> <span data-start="126290">as well as how it can be compressed.</span> <span data-start="129770">The first image format that I want to talk about today</span> <span data-start="132290">is the animated GIF.</span> <span data-start="134210">You should not be fooled by their crappy image quality.</span> <span data-start="137200">They're actually huge in file size.</span> <span data-start="140700">This 1 and 1/2 second clip is 6.8 mgs as a GIF.</span> <span data-start="145970">As a video, however, is 16 times smaller, at 420 megabytes.</span> <span data-start="152660">This is not uncommon.</span> <span data-start="154220">Animated GIFs can be anywhere from five to 20 times</span> <span data-start="157280">larger than the same content served as a video.</span> <span data-start="162280">This is why if you've ever inspected your Twitter feed,</span> <span data-start="164610">you may have noticed that the content labeled</span> <span data-start="166590">as GIF is not actually a GIF.</span> <span data-start="169200">Twitter does not serve animated GIFs.</span> <span data-start="171120">If you upload an animated GIF, they will automatically</span> <span data-start="173370">convert it to video.</span> <span data-start="175930">The reason for the drastic difference</span> <span data-start="177490">in file sizes between videos and animated GIFs</span> <span data-start="180220">lies in the differences between their compression algorithms.</span> <span data-start="183100">Video compression algorithms are far more sophisticated.</span> <span data-start="186040">Not only do they compress the contents of each frame,</span> <span data-start="188350">what they do what is known as inner frame compression.</span> <span data-start="190644">And you can think of this as compression</span> <span data-start="192310">that looks at the difs between the different frames.</span> <span data-start="197010">The first step in switching from animated GIFs to video</span> <span data-start="199890">is to convert your content.</span> <span data-start="201510">You can use the ffmpeg command line tool for this.</span> <span data-start="205980">Next, you'll need to update your HTML,</span> <span data-start="207870">and replace image tags with video tags.</span> <span data-start="210300">The code I have up on the screen is technically correct,</span> <span data-start="213160">but it's probably not what you want to use.</span> <span data-start="215727">Instead, you want to make sure to add the four attributes I've</span> <span data-start="218310">highlighted up on the screen.</span> <span data-start="220110">That's going to give your video that GIF look</span> <span data-start="222450">and feel even though it's not a GIF.</span> <span data-start="228830">Now, we'll switch gears and talk about a much more modern image</span> <span data-start="231620">format, and that, of course, is WebP.</span> <span data-start="235060">WebP is no longer a Chrome only technology.</span> <span data-start="238970">Last month, Microsoft Edge shipped support for WebP.</span> <span data-start="243230">In addition, Mozilla Firefox announced their intent</span> <span data-start="246230">to ship WebP.</span> <span data-start="248600">Currently, 72% of global web users have support for WebP.</span> <span data-start="255410">And given these recent developments,</span> <span data-start="256910">you can expect this number to only increase.</span> <span data-start="263470">This is a big deal because WebP images</span> <span data-start="265490">are 25% to 35% smaller than the equivalent JPEG or PNG.</span> <span data-start="270570">And this translates into some really awesome improvements</span> <span data-start="273590">in page speed.</span> <span data-start="275030">When the Trib united support for WebP,</span> <span data-start="276860">they found there was a 30% improvement in page load times</span> <span data-start="280520">on WebP supported browsers.</span> <span data-start="285320">By far the biggest hesitation I see around adopting WebP</span> <span data-start="288350">is a fear that you can't both serve WebP and support</span> <span data-start="291200">non-WebP browsers.</span> <span data-start="292370">And this is not true.</span> <span data-start="294170">The picture and the source tags make it</span> <span data-start="296130">possible to do precisely this.</span> <span data-start="298400">You can think of the picture tag as a container for the source</span> <span data-start="301430">and image tags that it contains.</span> <span data-start="304010">The source tag is used to specify multiple image</span> <span data-start="307340">formats of the same image.</span> <span data-start="309140">The browser will download the first, and only the first,</span> <span data-start="312200">image that is in a format that it supports.</span> <span data-start="314660">So in this example I have up on the screen,</span> <span data-start="316520">the Chrome browser would download the WebP version,</span> <span data-start="319220">a Safari browser would download the JPEG version.</span> <span data-start="322970">The great thing about this is that even</span> <span data-start="324920">though all major browsers have supported picture and source</span> <span data-start="328670">tag since 2015, however, if say, a 2014 browser were</span> <span data-start="332560">to encounter this, it would still work,</span> <span data-start="334310">because those browsers would just</span> <span data-start="335684">download the image specified by the image tag.</span> <span data-start="339815">If you haven't noticed, I've been</span> <span data-start="341190">talking about image formats.</span> <span data-start="342379">But I want to kind of go on a tangent</span> <span data-start="343920">and squeeze in a mention of the AV1 video format.</span> <span data-start="347007">And the reason why I wanted to squeeze it in</span> <span data-start="348840">is that it is the future of video on the web.</span> <span data-start="353010">The reason why it's the future of video on the web</span> <span data-start="355290">is that it compresses video 45% to 50% better than what</span> <span data-start="359760">is currently typically used on the web.</span> <span data-start="362640">It is still fairly new, so it's not really practical</span> <span data-start="365670">for you to be implementing it on your site yet.</span> <span data-start="367840">However, I encourage you to attend Francois and Angie's</span> <span data-start="370170">talk at 3:30 today, where they're</span> <span data-start="371730">going to be diving into AV1 in more detail.</span> <span data-start="376610">Image compression is a topic that's</span> <span data-start="378170">tightly coupled to image formats.</span> <span data-start="380420">Image compression algorithms are specific to the image format</span> <span data-start="383460">that they compress.</span> <span data-start="385960">However, all image compression algorithms</span> <span data-start="387850">can be broken down into lossless and lossy compression.</span> <span data-start="391570">Lossless compression results no loss of data.</span> <span data-start="394495">Lossy compression does result in loss of data,</span> <span data-start="397160">however can achieve greater file size savings.</span> <span data-start="400690">At a minimum, all sites should be using lossless compression,</span> <span data-start="403840">no questions asked.</span> <span data-start="405200">However, for most people, it's going</span> <span data-start="406837">to make sense to be slightly more aggressive</span> <span data-start="408670">and use lossy compression instead.</span> <span data-start="412110">The trick with lossy compression is</span> <span data-start="413610">finding that sweet spot between file size savings</span> <span data-start="416310">and image quality for your particular use case.</span> <span data-start="420180">Many lossy compression tools use the scale of zero to 100</span> <span data-start="423810">to represent the image quality of the compressed image,</span> <span data-start="426750">with zero being the worst, and 100 being the best.</span> <span data-start="430047">If you're looking for a place to start with lossy compression,</span> <span data-start="432630">we recommend trying out a quality level of 80 to 85.</span> <span data-start="436710">This typically reduces file size by 30% to 40%,</span> <span data-start="440190">while having a minimal effect on image quality.</span> <span data-start="445290">By far, the most popular tool for image compression</span> <span data-start="447750">is Imagemin, and it can be used with just about everything.</span> <span data-start="452460">Imagemin is used in conjunction with various Imagemin plugins.</span> <span data-start="455724">And you can think of these plugins</span> <span data-start="457140">as implementations of different image compression algorithms.</span> <span data-start="460590">Up on the screen, I've put the most popular Imagemin plugins</span> <span data-start="463560">for various use cases.</span> <span data-start="465120">However, these are by no means the only Imagemin plugins</span> <span data-start="467520">available.</span> <span data-start="470890">Image sizing is something I think many sites could</span> <span data-start="473080">be doing a much better job at.</span> <span data-start="475030">We have so many types of devices,</span> <span data-start="477130">and specifically sizes of devices that access</span> <span data-start="479320">the web these days.</span> <span data-start="480570">However, we insist on serving them all the exact same size</span> <span data-start="483235">of image.</span> <span data-start="484999">Not only does this have transmission costs,</span> <span data-start="486790">but it also creates additional work for the CPU.</span> <span data-start="491492">A solution, of course, is to serve</span> <span data-start="493160">multiple sizes of an image.</span> <span data-start="495030">Most sites find success serving anywhere</span> <span data-start="496790">from three to five sizes of an image.</span> <span data-start="499190">And in fact, this is exactly what Instagram does.</span> <span data-start="503820">Instagram uses this technique throughout their site.</span> <span data-start="506260">However, one use case where they were able to measure its impact</span> <span data-start="509190">was with their Instagram embeds.</span> <span data-start="511110">For context, Instagram embeds allow third-party sites</span> <span data-start="514110">to display Instagram content on their own site.</span> <span data-start="517169">As a result of serving multiple image sizes,</span> <span data-start="519360">Instagram was able to reduce image transfer</span> <span data-start="521520">size by 20% for their Instagram embeds.</span> <span data-start="528910">Two popular tools for imagery resizing are Sharp and Jimp.</span> <span data-start="532697">The biggest difference between the two</span> <span data-start="534280">is that Sharp is faster, and when I say faster,</span> <span data-start="536840">I mean faster at image processing.</span> <span data-start="538940">However, it requires that you compile C and C++ to install</span> <span data-start="542390">it.</span> <span data-start="545820">In addition to creating multiple sizes of your images,</span> <span data-start="548550">you'll need to update your HTML.</span> <span data-start="551340">You'll want to add the source set and sizes attributes.</span> <span data-start="554730">The source set attribute allows you</span> <span data-start="556530">to list multiple versions of the same image.</span> <span data-start="559230">In addition to including the file path,</span> <span data-start="561210">you'll also want to include the width of the image.</span> <span data-start="563737">This saves the browser from having to download the image</span> <span data-start="566070">to figure out how large it is.</span> <span data-start="568890">The size attribute tells the browser the width</span> <span data-start="571220">that the image will be displayed at.</span> <span data-start="573150">By using the information contained in the source set</span> <span data-start="575560">and sizes attribute, the browser can then figure out</span> <span data-start="577950">which image to download.</span> <span data-start="584240">Lazy loading is the last image technique</span> <span data-start="586020">that I'll be talking about today.</span> <span data-start="588030">Lazy loading is a strategy of waiting to download</span> <span data-start="590370">a resource until it is needed.</span> <span data-start="592510">In addition to images, it can be applied to resource types</span> <span data-start="595110">like JavaScript.</span> <span data-start="597060">Image lazy loading helps performance</span> <span data-start="598870">by using that bottleneck that occurs on initial page load.</span> <span data-start="601950">In addition, it saves user data by not downloading</span> <span data-start="604470">images that may never be used.</span> <span data-start="606840">Spotify is an example of a website</span> <span data-start="608730">that uses this technique very effectively.</span> <span data-start="610920">On this particular page that I pulled up,</span> <span data-start="612889">image lazy loading was the difference</span> <span data-start="614430">between loading a mg of images on initial page load</span> <span data-start="617400">and 18 mgs of an image on initial page load.</span> <span data-start="620100">That's a huge difference.</span> <span data-start="624050">Two tools to look into for image lazy loading</span> <span data-start="626660">are lazysizes and lozad.</span> <span data-start="628490">And you implement them both more or less the same way.</span> <span data-start="631700">Add the script your site, and then</span> <span data-start="633290">indicate which images should be lazy loaded.</span> <span data-start="636410">However, just because this is a fairly simple to use technique</span> <span data-start="640010">does not mean that's not important.</span> <span data-start="642710">In fact, it is so important that native lazy loading</span> <span data-start="646580">is coming to Chrome.</span> <span data-start="648161">[APPLAUSE]</span> <span data-start="654599">Native lazy loading means that you'll</span> <span data-start="656140">be able to take advantage of lazy loading</span> <span data-start="657880">without having to add third-party scripts</span> <span data-start="660250">on your site.</span> <span data-start="661600">It'll be available for both images</span> <span data-start="663340">and cross origin I-frames.</span> <span data-start="666520">And you can truly be lazy when it comes to implementing it.</span> <span data-start="669790">If you make no changes to your HTML,</span> <span data-start="671680">the browser will simply decide which resources</span> <span data-start="673840">should be lazy loaded.</span> <span data-start="675220">If you do care, however, you can use the lazy load attribute</span> <span data-start="678280">to specify which attributes should or should not</span> <span data-start="680830">be lazy loaded.</span> <span data-start="685330">Fonts can cause performance problems</span> <span data-start="686994">because they are typically large files that are downloaded</span> <span data-start="689410">from third-party sites.</span> <span data-start="691090">As a result, they can take a while to load.</span> <span data-start="694294">This leads to the phenomenon known</span> <span data-start="695710">as the flash of invisible text.</span> <span data-start="697690">And shockingly, this affects two out of every five mobile sites.</span> <span data-start="703190">Flash of invisible text looks like this.</span> <span data-start="705110">Instead of a user being greeted with text on your site,</span> <span data-start="707530">they're greater with invisibleness.</span> <span data-start="710360">Not only is this frustrating, but it also looks bad.</span> <span data-start="713294">What you want to encourage instead</span> <span data-start="714710">is the flash of unstyled text.</span> <span data-start="717240">And this is when the browser initially displays</span> <span data-start="719420">text using a system font and then</span> <span data-start="722210">swaps it out for the custom font once it has arrived.</span> <span data-start="725540">The good news here is that this fix is literally a one-liner.</span> <span data-start="729050">Everywhere in your CSS where you declare a font face,</span> <span data-start="731720">add the line font display swap.</span> <span data-start="733940">This tells the browser to use that swapping behavior</span> <span data-start="736250">that I just talked about in the previous slide.</span> <span data-start="739924">Now I'm going to hand the mic over</span> <span data-start="741340">to Houssein who's going to talk with you about techniques</span> <span data-start="743650">you can use with your JavaScript.</span> <span data-start="745025">[MUSIC PLAYING]</span> </section>

<section><span data-start="753825"><span class="speaker">Houssein Djirdeh</span>: So Katie showed</span> <span data-start="755200">a number of techniques that could</span> <span data-start="756575">be quite useful for the images and web fonts in your site,</span> <span data-start="759930">as well the few exciting things coming to the Chrome platform</span> <span data-start="763570">in the near future, like native lazy loading.</span> <span data-start="767024">For the rest of this talk, we'll go over</span> <span data-start="768690">some other important things you should</span> <span data-start="770273">be doing before the JavaScript that makes up your application.</span> <span data-start="777540">Earlier in this session, we saw how</span> <span data-start="779010">images can make up the majority of a site with regards</span> <span data-start="782340">to number of bytes sent.</span> <span data-start="784750">However, we also send a significant amount</span> <span data-start="786900">of JavaScript to browsers.</span> <span data-start="790040">If we take a look at HTTP archive data</span> <span data-start="792130">once again, as of last month, the median amount</span> <span data-start="796060">of JavaScript that we shipped to mobile web pages</span> <span data-start="799270">was about 370 kilobytes.</span> <span data-start="803170">For desktop, the number was about 420.</span> <span data-start="807910">Now JavaScript code still needs to be uncompressed, parsed,</span> <span data-start="811780">and executed by the browser.</span> <span data-start="814340">So in reality, we're looking at about a megabyte</span> <span data-start="817030">of uncompressed code that needs to be sent — </span> <span data-start="820220">that needs to be for an application of this size.</span> <span data-start="823120">Users who try to access this with low-end mobile devices</span> <span data-start="826780">will notice a much poorer performance.</span> <span data-start="832830">But why are we, as developers, shipping way more</span> <span data-start="835500">JavaScript code than we've ever done before?</span> <span data-start="838930">There are a number of reasons.</span> <span data-start="840400">One of them being the amount of dependencies</span> <span data-start="842910">that we pull into our applications</span> <span data-start="844770">and how easy that process has become.</span> <span data-start="848880">Front-end tooling has come a long way in the past decade,</span> <span data-start="851940">but there has been some cost.</span> <span data-start="857140">So what can we do to continue to try and build</span> <span data-start="859780">robust and fully fledged applications,</span> <span data-start="862300">but not at the expense of user experience?</span> <span data-start="866050">The very first thing we can and should consider doing is</span> <span data-start="869410">splitting our bundle .</span> <span data-start="871510">The idea behind code splitting is</span> <span data-start="873190">instead of sending all the JavaScript code to your users</span> <span data-start="876190">as soon as they load the very first page of your application,</span> <span data-start="879710">is to only send them what they need for their initial state.</span> <span data-start="883250">And then allow them to fetch future chunks on demand.</span> <span data-start="889130">The easiest way to get started with code splitting</span> <span data-start="891620">is by using dynamic imports.</span> <span data-start="894330">Now dynamic imports has been supported</span> <span data-start="896180">in Webpack for quite some time.</span> <span data-start="898600">And it allows you to import a module asynchronously</span> <span data-start="901600">where a promise gets returned.</span> <span data-start="904400">Once that promise finishes resolving,</span> <span data-start="906980">you can do what you need to do with that piece of code.</span> <span data-start="911560">The idea behind dynamic imports is</span> <span data-start="913450">you want to make sure that it fires on certain user</span> <span data-start="916210">interactions.</span> <span data-start="917530">And you want to do this to make sure that you only fetch code</span> <span data-start="920980">when it's actually needed.</span> <span data-start="923890">If you happen to be using another module bundler,</span> <span data-start="926560">like parcel or roll up, you can still</span> <span data-start="929470">use dynamic import to code split where you see fit.</span> <span data-start="936510">Now, a number of JavaScript libraries and frameworks</span> <span data-start="938990">have provided abstractions on top of dynamic imports</span> <span data-start="942440">to make the process of code splitting</span> <span data-start="944090">easier with your current tooling.</span> <span data-start="947450">With view, for example, you can define async components.</span> <span data-start="951260">And they're just functions that return a promise that</span> <span data-start="953960">resolve to the set components.</span> <span data-start="956900">By using that with dynamic imports,</span> <span data-start="958970">you can attach async opponents into</span> <span data-start="961160">your routing configurations.</span> <span data-start="963230">So that only when a certain route is reached,</span> <span data-start="965510">only then will the code and lives in that component</span> <span data-start="968540">be fetched.</span> <span data-start="972010">Angular has a very similar pattern.</span> <span data-start="974920">In its router, you can use the load children attribute</span> <span data-start="977800">and you can use it to connect a feature</span> <span data-start="979480">module to a specific route.</span> <span data-start="983050">With load children, you can define a dynamic import</span> <span data-start="986410">with Ivy.</span> <span data-start="987280">And Ivy's a new rendering engine that the Angular team</span> <span data-start="989830">is working on.</span> <span data-start="991900">When you do this approach, all the code, all the components,</span> <span data-start="995260">all the services that live in the feature module</span> <span data-start="997720">will only get loaded when that route is reached.</span> <span data-start="1000810">In the meantime, you can use load children,</span> <span data-start="1003090">but you just need to use a relative file</span> <span data-start="1004800">path to the feature module.</span> <span data-start="1009280">With React, libraries like React Loadable</span> <span data-start="1012070">and loadable components have allowed</span> <span data-start="1014080">us to code split on the component level</span> <span data-start="1016504">while taking care of other things,</span> <span data-start="1017920">like showing a loading indicator, or an error state,</span> <span data-start="1021220">where applicable.</span> <span data-start="1023140">However, with React 16.6, the lazy method was introduced.</span> <span data-start="1028500">And this allows you to code split while using suspense.</span> <span data-start="1032540">Now suspense is a feature that the react team has been</span> <span data-start="1035260">working on for quite some time.</span> <span data-start="1037460">And it allows you to suspend how certain component trees update</span> <span data-start="1040660">your state or update the DOM, depending</span> <span data-start="1043119">on how all of its children components</span> <span data-start="1045241">have fetched their data.</span> <span data-start="1050890">Another very useful technique that ties in well to code</span> <span data-start="1053637">splitting your bundle is by using preload.</span> <span data-start="1057960">Preload allows us to tell the browser</span> <span data-start="1059850">that if we have a late discovered resource</span> <span data-start="1062820">or a resource that's fetched late in the request chain</span> <span data-start="1066480">that we'd like to download it sooner because it's important.</span> <span data-start="1070770">So by doing this, we're telling the browser to prioritize.</span> <span data-start="1076410">To use preload, you only need to add a link element</span> <span data-start="1079060">to the head of your HTML document</span> <span data-start="1081560">and you need to have a rel attribute</span> <span data-start="1083530">with a value of preload.</span> <span data-start="1085530">The as attribute is used to define what type of file</span> <span data-start="1089230">you'd like to load.</span> <span data-start="1094050">Now as developers, it's also important to make sure</span> <span data-start="1096680">that the code that we write works well</span> <span data-start="1099020">in all the browsers people use to access our site.</span> <span data-start="1103460">So if we happen to include ES 2015, 2016, or later syntax,</span> <span data-start="1109280">we also want to include backwards compatible formats</span> <span data-start="1112250">so all the browsers can still understand them.</span> <span data-start="1116610">This usually involves adding transforms for any newer syntax</span> <span data-start="1119610">that we use and polyfills for any newer features.</span> <span data-start="1124330">Now because transpiling means we're</span> <span data-start="1126210">adding code on top of our bundle,</span> <span data-start="1128510">or application ends up being larger</span> <span data-start="1130199">than it was originally written.</span> <span data-start="1135320">One way to make sure that we only transpile the code</span> <span data-start="1137960">that's actually needed is by using babel/preset-EMV.</span> <span data-start="1142520">This preset takes the hassle out of us</span> <span data-start="1145100">trying to micromanage which plugins and polyfills</span> <span data-start="1148850">we need to add.</span> <span data-start="1150330">And it does this by allowing us to specify</span> <span data-start="1152750">a target list of browsers and letting babel handle the rest.</span> <span data-start="1158560">You can add this preset into your list of presets</span> <span data-start="1161250">in your babel configuration, and you</span> <span data-start="1164320">can use the target's attributes to define that set of browsers</span> <span data-start="1167920">that you'd like to reach.</span> <span data-start="1169930">Now this is a browser list query.</span> <span data-start="1172700">So if you use tools like order auto prefix or before,</span> <span data-start="1175360">you may already be familiar with it.</span> <span data-start="1178630">Using a percentage, like here, is one type of query</span> <span data-start="1181390">you can use.</span> <span data-start="1182440">And it allows you to target browsers that cross</span> <span data-start="1184990">a certain global market share.</span> <span data-start="1189450">The use built-in attribute allows us to tell babel</span> <span data-start="1192520">how to handle adding polyfills.</span> <span data-start="1195580">The usage value means that babel only automatically</span> <span data-start="1198930">include polyfills to files when it's actually</span> <span data-start="1201900">needed for features that need to be transpiled.</span> <span data-start="1205820">Now this is the behavior we all want, to only transpile code</span> <span data-start="1210419">when it's required.</span> <span data-start="1216930">So although babel/preset-EMV means that we can limit</span> <span data-start="1220050">the amount of transpiled code that we have to make sure that</span> <span data-start="1223200">we only include what's necessary for all the browsers we plan</span> <span data-start="1226650">to target, what if there was a way to differentially serve two</span> <span data-start="1230580">different types of bundles?</span> <span data-start="1232600">One, that's largely un-transpiled,</span> <span data-start="1235110">for newer browsers that don't need nearly as many polyfills,</span> <span data-start="1239100">and another legacy bundle, that contains more polyfills,</span> <span data-start="1242370">is a bit larger, but is needed for older browsers.</span> <span data-start="1247060">We can do this by using JavaScript modules.</span> <span data-start="1250780">Now JavaScript modules or ES modules</span> <span data-start="1253410">allow us to write blocks of code that import and export</span> <span data-start="1256590">from other modules.</span> <span data-start="1258420">But the amazing thing about using modules with</span> <span data-start="1260700">babel/present-EMV is that we can have it as a target,</span> <span data-start="1264690">instead of a specific browser query.</span> <span data-start="1269350">One site that's actually using this module approach today</span> <span data-start="1273460">is "The New York Times."</span> <span data-start="1275219">And they're using it for one of their flagship articles</span> <span data-start="1277510">of the year, piling in real time for the 2018 midterm elections.</span> <span data-start="1282990">They're using Sapper as their client-side framework, which</span> <span data-start="1285900">contains a number of progressive enhancements baked in,</span> <span data-start="1288780">like automatic code splitting.</span> <span data-start="1290850">But they're also using roll up to emit module chunks as well.</span> <span data-start="1295820">They're using a fairly simple heuristic</span> <span data-start="1297680">to make sure that users who have older browsers download</span> <span data-start="1301610">a larger more polyfilled bundle, but users who</span> <span data-start="1304550">are using newer browsers can only download</span> <span data-start="1306740">smaller and slimmer module.</span> <span data-start="1313110">A very simple way to make sure that users</span> <span data-start="1316160">who access your app only download one or the other</span> <span data-start="1319370">is by using the module, no module technique.</span> <span data-start="1323680">When you define a script element with type module,</span> <span data-start="1326890">browsers that understand modules will download that normally.</span> <span data-start="1331020">But they'll know to ignore any script element that</span> <span data-start="1333700">has the no module attribute.</span> <span data-start="1336980">Similarly, browsers that don't understand modules</span> <span data-start="1340700">will ignore any script elements that have type module.</span> <span data-start="1344570">But since they can't identify what no module means,</span> <span data-start="1347480">they'll download that bundle as well.</span> <span data-start="1350340">So here, we can get the best of both worlds.</span> <span data-start="1352640">Shipping the right bundle to our users,</span> <span data-start="1354960">depending on what browser they use.</span> <span data-start="1361290">If you happen to have critical modules that you'd</span> <span data-start="1363680">like to download sooner, you could do that</span> <span data-start="1365940">by also preloading them as well.</span> <span data-start="1368930">And you just need to specify a module preload value</span> <span data-start="1372030">to the rel attribute.</span> <span data-start="1376574">So we've talked about a few things</span> <span data-start="1377990">you can do to improve the code that you ship to your users,</span> <span data-start="1382370">but if you're thinking of adding any of these optimizations,</span> <span data-start="1385280">it could be useful to try and keep an eye on things.</span> <span data-start="1388519">And there are tools out there that could actually</span> <span data-start="1390560">make this easier.</span> <span data-start="1392810">The code coverage tab within Chrome DevTools</span> <span data-start="1395990">allows you to see the size of all your bundles,</span> <span data-start="1398900">as well as how much of it is actually being used.</span> <span data-start="1403060">You can access it by opening the Command menu</span> <span data-start="1405550">and just typing in coverage.</span> <span data-start="1410870">If you're using Webpack, Webpack bundle analyzer</span> <span data-start="1413870">can be a very handy tool.</span> <span data-start="1416280">And it gives you a nice heat map visualization</span> <span data-start="1418880">of your entire bundle.</span> <span data-start="1420470">You can zoom in, see which parts of your bundle are larger</span> <span data-start="1423680">and which parts of your bundle are smaller.</span> <span data-start="1429890">And if you've ever wanted to find</span> <span data-start="1431330">the cost of a specific library, you can use bundle phobia.</span> <span data-start="1435800">You could type the name of a package</span> <span data-start="1438110">and see how large it is, as well as how much of an impact</span> <span data-start="1441710">it can make to your application in terms of download time.</span> <span data-start="1446180">You can also scan your packages on file</span> <span data-start="1449000">to see how much of an impact all your packages make.</span> <span data-start="1456760">Now as useful as it is to use tools to manually keep</span> <span data-start="1460180">an eye on how things are doing with your bundle size,</span> <span data-start="1463180">it can be especially useful to also include checks into your</span> <span data-start="1466510">build workflow.</span> <span data-start="1468460">One tool that could actually help here,</span> <span data-start="1470140">that can allow you to set performance budgets,</span> <span data-start="1472770">is the Lighthouse CI.</span> <span data-start="1474920">So instead of only running a Lighthouse in the Chrome audits</span> <span data-start="1478360">panel, or as a Chrome extension, you</span> <span data-start="1481120">can also run Lighthouse in CI and have</span> <span data-start="1484180">it included as a status check into your workflow.</span> <span data-start="1488030">You could specify certain Lighthouse categories and set</span> <span data-start="1491050">scores for them so that merges and pull requests only</span> <span data-start="1494920">get included if those scores are met.</span> <span data-start="1501940">Now a site that's actually taking steps</span> <span data-start="1503760">to add a number of these optimizations is UniQlo.</span> <span data-start="1507250">They're a clothing retailer base out of Japan.</span> <span data-start="1509620">And they're taking steps to improve their entire web</span> <span data-start="1512250">architecture, beginning with their Canadian site.</span> <span data-start="1516600">They've identified a number of critical resources</span> <span data-start="1519450">and decided to try and download them sooner,</span> <span data-start="1522420">and they're doing this by preloading them.</span> <span data-start="1524730">They've done this with some images,</span> <span data-start="1526200">some core fonts, as well as a number of cross origin fetches.</span> <span data-start="1531260">They then also identified that they</span> <span data-start="1532940">can code split and try to get some wins that way as well.</span> <span data-start="1537810">They took the correct first step of code splitting</span> <span data-start="1540320">at the route level.</span> <span data-start="1541790">And just by doing that alone, they</span> <span data-start="1543640">noticed an almost half size reduction in their bundle size.</span> <span data-start="1548390">They also moved on to code split their localization package.</span> <span data-start="1551600">And noticed that they can get their bundle size down</span> <span data-start="1553790">to 200 kilobytes.</span> <span data-start="1556110">After this, they even added more optimizations,</span> <span data-start="1558900">such as using a pre-act compatibility</span> <span data-start="1560880">layer for the react bindings, to get their bundle size</span> <span data-start="1563970">to about 170 kilobytes.</span> <span data-start="1569664">While doing all of this, they made</span> <span data-start="1571080">sure to also set budgets so their whole team can</span> <span data-start="1574020">stay in sync.</span> <span data-start="1575480">And they're using another open source tool to help here,</span> <span data-start="1577820">called Bundle Size.</span> <span data-start="1580020">They've set 80 kilobyte budgets for each one of the chunks,</span> <span data-start="1583540">and then allowed them to stay under a 200 kilobyte total</span> <span data-start="1586920">for all of their scripts.</span> <span data-start="1593566">While adding these optimizations,</span> <span data-start="1594940">they noticed a two-second time to interactive reduction</span> <span data-start="1598450">for users that use low-end mobile devices</span> <span data-start="1601210">and have weak connections.</span> <span data-start="1603280">Now you might think two seconds is not that much.</span> <span data-start="1606560">But it can make an impact for your customers.</span> <span data-start="1611090">After these optimizations were added,</span> <span data-start="1612860">they notice a 14% reduction in bounce rate,</span> <span data-start="1616790">a 31% increase in average duration,</span> <span data-start="1620390">and a 25% increase in pages viewed per session.</span> <span data-start="1624980">Now there were other things also being</span> <span data-start="1626660">added to the site at the same time,</span> <span data-start="1629090">but they know that performance played a very huge factor here.</span> <span data-start="1638070">So we've talked about quite a few things</span> <span data-start="1639840">that you can do today to improve how your site performs.</span> <span data-start="1644320">But what can Chrome do as a browser as well?</span> <span data-start="1648450">For users that opt in to Data Saver mode,</span> <span data-start="1651870">Chrome will try show a lightweight version of the page</span> <span data-start="1655260">where possible.</span> <span data-start="1656730">And it does this by minimizing data used</span> <span data-start="1659460">as well as showing cache content whenever it can.</span> <span data-start="1663740">Now as developers, you can also tap into this as well.</span> <span data-start="1667310">And you could do this by using the network information API.</span> <span data-start="1672180">If you look at the navigator connection save data</span> <span data-start="1674490">attribute you can identify whether your users actually</span> <span data-start="1677880">have data saver enabled.</span> <span data-start="1679580">And you could try and serve a slightly different experience</span> <span data-start="1682320">to make sure things are fast for them as well.</span> <span data-start="1686820">You can also use the effective type attribute,</span> <span data-start="1689990">and use that to actually be able to serve different assets</span> <span data-start="1693650">conditionally depending on what connection your user is having.</span> <span data-start="1701810">The very last thing that I do want to mention</span> <span data-start="1703820">is although me and Katie have talked</span> <span data-start="1705680">about a lot of the things that you</span> <span data-start="1707100">can do to improve your site, every application</span> <span data-start="1710970">is built differently.</span> <span data-start="1712660">Every team is different.</span> <span data-start="1714290">Every tool chain is different.</span> <span data-start="1716112">So this isn't something you need to start</span> <span data-start="1717820">doing wholesale and including everything at once.</span> <span data-start="1721480">By setting budgets and keeping an eye on your bundle size</span> <span data-start="1724280">from the very beginning, you can include performance</span> <span data-start="1727420">enhancements as a step by step procedure</span> <span data-start="1730600">and make sure your site never regresses.</span> <span data-start="1733060">Performance doesn't need to be an afterthought.</span> <span data-start="1739210">Almost everything we've talked about is in web.dev,</span> <span data-start="1742660">so I highly suggest you take a look if you haven't already.</span> <span data-start="1746320">We hope you enjoyed this talk as much as we enjoyed giving it.</span> <span data-start="1749110">Thank you.</span> <span data-start="1749920">[MUSIC PLAYING]</span> </section>

</div>

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="js/main.js"></script>

</body>

</html>
