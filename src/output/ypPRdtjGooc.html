<!DOCTYPE html>

<! — 
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 — >

<html lang="en">
<head>
<meta charset="utf-8">
<meta name="author" content="//google.com">
<meta name="description" content="Chrome Dev Summit">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ypPRdtjGooc</title>
<link rel="stylesheet" href="css/main.css">
</head>

<body>

<div id="container">

<section>
<span data-start="0">[MUSIC PLAYING]</span> </section>

<section><span data-start="6765"><span class="speaker">Justin Fagnani</span>: So my name is Justin Fagnani.</span> <span data-start="8640">And I work in Chrome on things like Web Components, polymer,</span> <span data-start="11370">and lit-html.</span> <span data-start="12477">And right now, I'm going to talk about the virtue of laziness.</span> <span data-start="18120">Next slide.</span> <span data-start="19670">Advance.</span> <span data-start="21160">Today is the day.</span> <span data-start="23207">That happened.</span> <span data-start="23790">Yeah, OK.</span> <span data-start="25320">So we're going to look at how to do less, be lazy, and take</span> <span data-start="29670">breaks, and end up with a better web application for it.</span> <span data-start="33480">And when I say better, I'm really</span> <span data-start="35490">talking about four overlapping goals here.</span> <span data-start="38130">We want to deliver great user experiences.</span> <span data-start="40310">And we want our apps to be fast and to respond quickly</span> <span data-start="42690">to input and changes.</span> <span data-start="44580">And more than just making fast apps</span> <span data-start="46080">or making it possible to build fast apps,</span> <span data-start="48120">we want to make this easy, so easy</span> <span data-start="50250">hopefully that it's the default. Because this</span> <span data-start="52440">is going to make our users happy, our developers happy.</span> <span data-start="54900">And happy developers will make better user experiences</span> <span data-start="57450">in the long run.</span> <span data-start="59470">So with these four general goals in mind,</span> <span data-start="62307">I'm going to walk through several techniques</span> <span data-start="64140">for leveraging asynchronous programming for building better</span> <span data-start="66970">UIs.</span> <span data-start="68310">So we're going to look at batching work</span> <span data-start="69960">for better performance and developer experience,</span> <span data-start="72540">keeping our UIs responsive with non-blocking rendering,</span> <span data-start="75840">managing async state for a better user</span> <span data-start="78630">experience and developer experience, and then finally,</span> <span data-start="82290">coordinating async UIs once we have all this asynchronicity</span> <span data-start="85530">throughout our application.</span> <span data-start="87394">And this makes for a handy little talk outline right here.</span> <span data-start="89810">So I'm going to give some background</span> <span data-start="91380">and then jump right into it.</span> <span data-start="93670">But first, a quick note.</span> <span data-start="95010">This is day two of the Dev Summit</span> <span data-start="96390">so it's a little more future forward looking.</span> <span data-start="99900">And the stuff I've made here, the demos and helper code</span> <span data-start="103440">is a little bit experimental.</span> <span data-start="105390">But it's only using current browser features,</span> <span data-start="108200">and so all of these techniques still work today.</span> <span data-start="112140">So now for a little background.</span> <span data-start="114630">I mentioned that I work on web components and lit-html,</span> <span data-start="117300">so we're going to use these things as the basis</span> <span data-start="120150">for the demos in the talk.</span> <span data-start="123270">So if you haven't used web components before,</span> <span data-start="125820">Web Components lets you define your own HTML element tags.</span> <span data-start="130169">So it really refers to two specs here,</span> <span data-start="132810">custom elements and Shadow DOM.</span> <span data-start="135052">And combined, they let you define your own tags</span> <span data-start="137010">with custom implementation and UI.</span> <span data-start="139622">So to create a custom element, you simply</span> <span data-start="141330">extend from HTML element, a built in class,</span> <span data-start="144480">you add your implementation, and then you</span> <span data-start="146730">register your class with a specific tag</span> <span data-start="148620">name with the browser.</span> <span data-start="149652">And from there, you can use this element and that tag</span> <span data-start="151860">name anywhere you can use HTML, so in your main page document,</span> <span data-start="155340">inner HTML, document create element,</span> <span data-start="158580">even in other frameworks.</span> <span data-start="161520">So next, lit-html, lit-html is a way</span> <span data-start="164670">to write declarative HTML templates in JavaScript.</span> <span data-start="168560">And we use tagged template literals to write them.</span> <span data-start="171330">This is a feature that came out in ES 6.</span> <span data-start="174280">And these are strings that are denoted with backticks instead</span> <span data-start="177000">of quotes, and they can have a template tag in front of them.</span> <span data-start="180551">And we're going to use the lit-html template tag here,</span> <span data-start="182800">which is just going to allow us to process this template</span> <span data-start="185133">to make it more efficient.</span> <span data-start="186515">And then inside of our template, we can have expressions.</span> <span data-start="188890">And these are just plain JavaScript expressions.</span> <span data-start="191277">Once you have a template, if you want to render it to the DOM,</span> <span data-start="193860">you simply pass it to the lit-html render function</span> <span data-start="196830">and give it a node to render to.</span> <span data-start="198540">And it's going to make that DOM appear there.</span> <span data-start="201182">And the nice thing is that if you call this render function</span> <span data-start="203640">multiple times at the same template but different data,</span> <span data-start="206390">lit-html is going to take care to only update</span> <span data-start="209250">the expressions that changed.</span> <span data-start="210600">It will never update the rest of the DOM in the template.</span> <span data-start="214767">And then finally, if you take web components</span> <span data-start="216600">and lit-html and combine them together,</span> <span data-start="218380">you end up with LitElement.</span> <span data-start="220300">So LitElement is a convenient way to write web components.</span> <span data-start="224264">Because this is day two and a little more forward looking,</span> <span data-start="226680">I'm using some future JavaScript features here</span> <span data-start="229290">like decorators and class fields.</span> <span data-start="231860">And LitElement really gives you two features.</span> <span data-start="234550">One is the ability to declare observable properties.</span> <span data-start="237520">So these decorators here are going</span> <span data-start="239820">to create getters and setters instead of a field here.</span> <span data-start="242797">And the setters are going to recognize</span> <span data-start="244380">when this property changes and then tell the element</span> <span data-start="246546">that it needs to update.</span> <span data-start="248310">The other feature is that it lets</span> <span data-start="249720">you write a render method that returns a lit-html result.</span> <span data-start="253650">And so when the element knows that it needs to update,</span> <span data-start="256070">it's going to call this render method, take the result</span> <span data-start="258319">and render it to the shadow root of this custom element.</span> <span data-start="261465">And then finally, we give you a little helper here,</span> <span data-start="263590">so you can use a decorator to register the element.</span> <span data-start="266639">So once you do that, and you create your element,</span> <span data-start="268680">then you can use it anywhere you would HTML,</span> <span data-start="271080">and it will render as you expect.</span> <span data-start="274004">So that brings us to our first technique</span> <span data-start="275670">here, which is batching work.</span> <span data-start="278040">And if we go back to our element definition,</span> <span data-start="280350">you'll see that in the render method here</span> <span data-start="283800">this is called for us automatically by the LitElement</span> <span data-start="286620">base class.</span> <span data-start="288000">But the question that comes up here</span> <span data-start="289860">is, when is this method called?</span> <span data-start="292010">So to look at that, let's take a look at a little example here.</span> <span data-start="295800">We're going to use this element imperatively,</span> <span data-start="298140">but this also applies if you used it in the main HTML</span> <span data-start="300980">or if you used it with a framework.</span> <span data-start="302620">So we're going to create an element instance,</span> <span data-start="304590">and then we're going to set a property.</span> <span data-start="306600">So the question is, should we render now?</span> <span data-start="310420">We could render now.</span> <span data-start="311254">But we don't know that we're not going</span> <span data-start="312836">to set another property right after we</span> <span data-start="314560">set this property here.</span> <span data-start="316880">And if we did render after every property set,</span> <span data-start="319180">we would be rendering multiple times potentially</span> <span data-start="321370">for every element as we update the data.</span> <span data-start="323519">We don't want to do that.</span> <span data-start="324560">So instead, we're going to enqueue a task.</span> <span data-start="327650">And then, in the future, that task</span> <span data-start="329110">is going to run and actually render that element.</span> <span data-start="331629">And so that we know when the element has rendered</span> <span data-start="333670">and when it's complete, we add this promise hanging off</span> <span data-start="337840">the element here called update complete.</span> <span data-start="339912">And this is going to resolve when the element has rendered.</span> <span data-start="342370">And if you wait for it, you know that you</span> <span data-start="344078">have a fully rendered element.</span> <span data-start="346306">And the way that this works is we</span> <span data-start="347680">have an asynchronous update pipeline</span> <span data-start="349960">under the hood in the element.</span> <span data-start="351650">So when a setter is called for a property,</span> <span data-start="353590">it's going to call this request update method.</span> <span data-start="356080">That's going to schedule an update task,</span> <span data-start="357982">but it's only going to schedule one</span> <span data-start="359440">if there isn't one existing.</span> <span data-start="360737">If there is one, we're just going to use that same task,</span> <span data-start="363070">and that's how we get the batching.</span> <span data-start="364535">When that task runs, it's going to call the update method</span> <span data-start="366910">on the element.</span> <span data-start="367810">And that's where the actual work is done to render to the DOM.</span> <span data-start="372560">So we do this for two reasons.</span> <span data-start="373920">One is performance, like I mentioned.</span> <span data-start="375800">And the other is developer ergonomics.</span> <span data-start="377820">So if we go back to the template here,</span> <span data-start="379820">we see that this template renders</span> <span data-start="381320">two different properties in the same template.</span> <span data-start="383684">And it's much easier to reason about these templates</span> <span data-start="385850">if we don't have to worry about the order in which</span> <span data-start="388310">these properties are set or whether or not they've both</span> <span data-start="390860">been set together or not.</span> <span data-start="392300">So we'd like to take all the changes that</span> <span data-start="394490">are incoming for an element, batch them together, and then</span> <span data-start="397010">let you write a simple declarative template to render</span> <span data-start="399218">your element.</span> <span data-start="401212">And so an interesting implication of this</span> <span data-start="402920">is that LitElement rendering is always async.</span> <span data-start="406670">You never opt into being async, and you can't opt out</span> <span data-start="409730">to being synchronous.</span> <span data-start="411812">And when we explain this to people,</span> <span data-start="413270">sometimes, we get a question, won't the UI partially update?</span> <span data-start="417110">And the answer is no.</span> <span data-start="418560">And I built a little animation here to try to show this.</span> <span data-start="421200">So here, we have a tree of elements.</span> <span data-start="423154">Let's assume these are all lit elements,</span> <span data-start="424820">and they're passing data down the tree via properties.</span> <span data-start="428545">And so that's our component tree.</span> <span data-start="429920">And then right here, we have the microtask queue.</span> <span data-start="432200">So hopefully in other talks they've talked about this.</span> <span data-start="434450">We have a queue of microtasks that the browser</span> <span data-start="436940">runs through to completion before it will paint or handle</span> <span data-start="440570">user input.</span> <span data-start="442130">The yellow box here is our current microtask.</span> <span data-start="445170">And so if we have some code that runs</span> <span data-start="446870">that's going to set a property on A,</span> <span data-start="448670">that's going to cause its microtask to be enqueued.</span> <span data-start="451935">And then when A gets to run, it might set some properties</span> <span data-start="454310">on B and C. So their tasks are going to be enqueued.</span> <span data-start="457160">And B is going to set some properties on D</span> <span data-start="459020">and E. C is going to set some on F and so forth.</span> <span data-start="462560">And we get to run through this entire queue until it's empty.</span> <span data-start="466640">Once it's empty, then the browser can paint.</span> <span data-start="470160">And to show this with a demo, I made a demo</span> <span data-start="473300">here of a tree of elements.</span> <span data-start="475337">And each one takes an artificially long time</span> <span data-start="477170">to render.</span> <span data-start="478200">And so normally, you might expect,</span> <span data-start="481591">if you don't know how the microtask queue works,</span> <span data-start="483590">that these might paint in individually.</span> <span data-start="485680">And we'll see here that if we click the render button here,</span> <span data-start="488810">that they all snap in at once.</span> <span data-start="490490">So even though each one takes 50 milliseconds</span> <span data-start="492380">and the whole thing takes 750 milliseconds,</span> <span data-start="494900">we don't see the intermediate states.</span> <span data-start="497470">And this is great if your UI is painting fast, if it's not</span> <span data-start="500690">taking 750 milliseconds.</span> <span data-start="503270">But if you have a very complex tree</span> <span data-start="505790">and UI is rendering slowly, then we've</span> <span data-start="507860">just introduced jank, which we don't want.</span> <span data-start="510840">So this brings us to the next technique,</span> <span data-start="512750">which is non-blocking rendering to keep a responsive UI.</span> <span data-start="517340">So we just saw that we can have async rendering,</span> <span data-start="519640">but still block paint and input.</span> <span data-start="521123">And we know we can have complex UIs that</span> <span data-start="522789">take a long time to render.</span> <span data-start="524034">And we know we need to render in less than 10 milliseconds</span> <span data-start="526450">to keep our 60 frame per second target.</span> <span data-start="530537">And one way to look at this is that we</span> <span data-start="532120">have all these microtasks here in the blue rectangles,</span> <span data-start="535360">and they fill out a complete task.</span> <span data-start="537460">And this task blocks rendering.</span> <span data-start="539350">And as long as the complete task fits within our 10</span> <span data-start="542910">millisecond budget, we're fine.</span> <span data-start="544750">Right?</span> <span data-start="545570">But as soon as the task exceeds the budget,</span> <span data-start="547670">we're going to introduce jank.</span> <span data-start="549010">So our technique here is to break this up.</span> <span data-start="551752">So that instead of having a whole bunch of microtasks</span> <span data-start="553960">in one long task, we just give a task per component to render.</span> <span data-start="558250">And now, these will hopefully fit in under 10 milliseconds.</span> <span data-start="561050">And we will get smooth updates.</span> <span data-start="563480">So the way we're going to do this is we're</span> <span data-start="565540">going to tap into this asynchronous update pipeline</span> <span data-start="568360">that LitElement has.</span> <span data-start="569770">And we're going to customize the schedule update task</span> <span data-start="572120">step right here.</span> <span data-start="573890">So that brings us to our first experimental helper</span> <span data-start="576340">that we're calling for the moment LazyLitElement.</span> <span data-start="579940">The way this works is that under the hood in LitElement,</span> <span data-start="583360">there's a method called scheduleUpdate.</span> <span data-start="585460">And by default, this thing just waits for a microtask,</span> <span data-start="588280">and then it calls validate, which</span> <span data-start="589930">does the work of rendering.</span> <span data-start="592132">And so what we do in LazyLitElement</span> <span data-start="593590">is we override this.</span> <span data-start="594490">And instead of waiting for a microtask,</span> <span data-start="596590">we wait for a promise that's resolved on setTimeout timing.</span> <span data-start="599807">It's a very simple thing to do, but it</span> <span data-start="601390">lets the browser paint and handle input before we render.</span> <span data-start="605355">So now if we go back to this demo here,</span> <span data-start="606980">we can turn on lazy rendering.</span> <span data-start="609590">And now, everything is going to render on setTimeout timing.</span> <span data-start="612620">And you can see that we paint the intermediate steps here</span> <span data-start="615470">as we go.</span> <span data-start="616460">And so we've reduced jank by showing</span> <span data-start="619310">some intermediate state.</span> <span data-start="621770">And so a lot of frameworks have been</span> <span data-start="623270">working on asynchronous rendering over the years,</span> <span data-start="626510">and especially React recently.</span> <span data-start="629120">And they have created a demo that I quite like,</span> <span data-start="631250">which is a Sierpinski triangle demo.</span> <span data-start="634040">And the way this works is that you have a large tree</span> <span data-start="636560">of components here.</span> <span data-start="637502">And each one of these has also been</span> <span data-start="638960">written to take an artificially long amount of time,</span> <span data-start="641627">and they all have a label.</span> <span data-start="642710">And this label represents data flowing down the tree.</span> <span data-start="645346">So to update the label on all the components,</span> <span data-start="647220">it's going to take a little bit of time.</span> <span data-start="649220">And while we're updating the label,</span> <span data-start="650960">we're going to animate the size of the tree.</span> <span data-start="652910">And we want this animation to be smooth,</span> <span data-start="654980">and it's driven from JavaScript.</span> <span data-start="656390">So if we take a long time to update the tree,</span> <span data-start="658730">we're going to get jank.</span> <span data-start="660470">This is a nice demo because it highlights</span> <span data-start="662527">some subtleties that you need to take care of when</span> <span data-start="664610">doing asynchronous rendering.</span> <span data-start="666240">So we have an expensive subtree to render.</span> <span data-start="668270">We want this continuous script driven animation to be smooth.</span> <span data-start="671242">And then on top of that, we have these high priority inputs</span> <span data-start="673700">that we also want to handle.</span> <span data-start="675710">So I implemented this here with regular Element</span> <span data-start="678080">that uses the microtask queue.</span> <span data-start="680000">And you can see that as the triangle updates in size,</span> <span data-start="683210">we get some jank in the middle there.</span> <span data-start="685240">And we want to avoid that.</span> <span data-start="686910">So it's very simple to re implement this just</span> <span data-start="689120">by changing the base class to LazyLitElement.</span> <span data-start="691430">And now you can see that we get a smooth animation even</span> <span data-start="694910">as we update the labels here.</span> <span data-start="697886">But next, I mentioned we want to have these high priority</span> <span data-start="700260">inputs.</span> <span data-start="701220">So this brings us to the idea of urgent updates.</span> <span data-start="704250">If you defer rendering, it's possible</span> <span data-start="706464">that you have situations where you</span> <span data-start="707880">want to render sooner than you've scheduled yourself</span> <span data-start="710046">to be rendered.</span> <span data-start="711730">And so with these urgent updates what we've done</span> <span data-start="714600">is we've created in LazyLitElement,</span> <span data-start="716660">we don't just override the schedule update method.</span> <span data-start="719220">We add a new method on here called requestUrgentUpdate.</span> <span data-start="722300">And that's going to be called and make your element</span> <span data-start="725490">render sooner.</span> <span data-start="727974">It's a very simple implementation.</span> <span data-start="729390">I wanted to show it, because it's a little bit interesting.</span> <span data-start="731848">So instead of waiting for a promise that resolves with</span> <span data-start="734100">setTimeout —  we still do that, but we also store — </span> <span data-start="738880">Let me go back here.</span> <span data-start="740930">Maybe not.</span> <span data-start="741430">OK.</span> <span data-start="741929">Well, we restore the resolve function</span> <span data-start="746050">on the instance of the element when we schedule an update.</span> <span data-start="750820">And then we can go back and we can call that resolve function,</span> <span data-start="755270">which will cause our promise to resolve earlier</span> <span data-start="757249">than it was scheduled to.</span> <span data-start="758290">So in essence, we're jumping from the task queue</span> <span data-start="760637">over to the microtask queue, and we're going</span> <span data-start="762470">to render as soon as possible.</span> <span data-start="766760">OK, so this is how you would use it.</span> <span data-start="768350">So we have a partial implementation</span> <span data-start="769960">of our DotElement here.</span> <span data-start="772890">And these are some event callbacks</span> <span data-start="774550">that might be called from on mouse over and on mouse out.</span> <span data-start="777655">And they're simply going to set the state that our rendering is</span> <span data-start="780280">based on, and then they're going to call</span> <span data-start="782050">requestUrgentUpdate to kick us to the faster timing.</span> <span data-start="786500">And so once we do that, you can see that we</span> <span data-start="789577">have our smooth animation.</span> <span data-start="790660">Our labels update.</span> <span data-start="791830">And we get a fast hover over effect</span> <span data-start="793450">here by calling requestUrgentUpdate.</span> <span data-start="797990">And let me talk real quick about scheduling.</span> <span data-start="800030">So in that demo there I did a very simple thing.</span> <span data-start="803210">I said instead of using a microtask,</span> <span data-start="804800">we're going to use a full task.</span> <span data-start="807290">And I actually didn't expect that to work</span> <span data-start="809296">as well as it did when I made the demo,</span> <span data-start="810920">but it did work very well.</span> <span data-start="812390">The browser ends up doing a very good job</span> <span data-start="814760">of executing as many tasks as it can</span> <span data-start="817430">before it has to paint a frame.</span> <span data-start="819634">But it's pretty naive, and it leaves off a lot of features</span> <span data-start="822050">that we would like, like different priority queues,</span> <span data-start="824810">the ability to cancel work, the ability to coordinate</span> <span data-start="827990">long chains of tasks that are all related together.</span> <span data-start="831320">So that schedule update method is exactly where</span> <span data-start="833660">we would like to plug into a native platform scheduler API,</span> <span data-start="837390">like Shubhie and Jason talked about earlier.</span> <span data-start="840170">So the important point is that with web components,</span> <span data-start="842310">we don't have a overarching framework that can coordinate</span> <span data-start="845660">and schedule our components for us,</span> <span data-start="847430">and we might get components from different vendors.</span> <span data-start="849980">So being able to plug into a global platform</span> <span data-start="852740">vendored API for scheduling is going to help us tremendously</span> <span data-start="855510">here.</span> <span data-start="860230">OK, there we go.</span> <span data-start="861220">Let's move on to talking about managing async state.</span> <span data-start="864350">So far we've talked about being asynchronous on a per component</span> <span data-start="867870">level, so yielding to the browser</span> <span data-start="869580">and letting it paint in between components.</span> <span data-start="872370">But sometimes, we need to manage data</span> <span data-start="873990">that itself is asynchronous.</span> <span data-start="875820">And lit-html rendering is synchronous by nature.</span> <span data-start="878246">When you give the render function a template,</span> <span data-start="880120">it's going to do all the work immediately to render that.</span> <span data-start="882867">So what do we do if we want to render asynchronous data inside</span> <span data-start="885450">of a synchronous template?</span> <span data-start="888100">So we can look at how we handle data normally here.</span> <span data-start="890650">And if we have a string and just a plain reference</span> <span data-start="893760">to that string, it's pretty easy to use.</span> <span data-start="896401">We just use it as a template, and we get the rendering</span> <span data-start="898650">that we wanted.</span> <span data-start="901210">And if we change this instead to load off the network,</span> <span data-start="905950">it turns out that lit-html handles promises already.</span> <span data-start="909280">And so what we'll get is a blank screen here.</span> <span data-start="911722">And then when the promise resolves,</span> <span data-start="913180">we'll render hello world.</span> <span data-start="914860">So this is kind of nice.</span> <span data-start="915890">We get some behavior that we might</span> <span data-start="917306">expect right out of the box.</span> <span data-start="919970">But we might not want to render a blank screen</span> <span data-start="922600">as our initial state.</span> <span data-start="924170">So this brings us to the idea of directives,</span> <span data-start="926820">and these are functions that are a little bit special</span> <span data-start="929509">and they're able to customize how templates</span> <span data-start="931300">are rendered by lit-html.</span> <span data-start="933209">And one of the more useful directives</span> <span data-start="934750">that lit-html ships with is called until.</span> <span data-start="937950">What until does is it takes a promise</span> <span data-start="940120">and it will render the result of that promise when it resolves,</span> <span data-start="942790">but it will render a placeholder until that promise does</span> <span data-start="945370">resolve.</span> <span data-start="946960">So we can use that here.</span> <span data-start="948920">And you see that in the template,</span> <span data-start="950710">we call the until directive with our promise in the loading</span> <span data-start="954460">place holder.</span> <span data-start="955180">And that's going to show first.</span> <span data-start="956680">And then when it resolves, we're going</span> <span data-start="958270">to render our content there.</span> <span data-start="961069">So this example is a little bit too simple,</span> <span data-start="962860">because it assumes that we have this promise available already</span> <span data-start="965443">that we want to use.</span> <span data-start="966670">And a lot of times, instead, we want</span> <span data-start="969160">to run some tasks when we need to render.</span> <span data-start="972040">And we might have some operation that's</span> <span data-start="973900">dependent on some instant state.</span> <span data-start="976370">So in this version of the example here,</span> <span data-start="978280">we have a file name property.</span> <span data-start="979810">And we want to fetch some data based on that file name.</span> <span data-start="982880">Now we might be tempted to call fetch</span> <span data-start="984840">in line with the template, so that we'll</span> <span data-start="987040">fetch the correct file and then render it.</span> <span data-start="990320">And this does work, but it has a problem where every time you</span> <span data-start="994540">render this template, we're going to call fetch.</span> <span data-start="996730">And we might be rendering the template</span> <span data-start="998313">because some other properties change.</span> <span data-start="1000110">And in this case, we're going to flood the network</span> <span data-start="1002193">with lots of fetch requests.</span> <span data-start="1003810">And we also might show an alternating loading</span> <span data-start="1006720">and resolved state in our UI.</span> <span data-start="1010550">But it's almost the mental model that we want.</span> <span data-start="1012900">Right?</span> <span data-start="1014190">So what we really want to do is we</span> <span data-start="1016350">want to be able to run a task that's dependent on some data</span> <span data-start="1020790">only when that data changes.</span> <span data-start="1022330">So that brings us to the next experimental helper</span> <span data-start="1024690">here that we call runAsync.</span> <span data-start="1027900">And what runAsync does is it performs an async operation,</span> <span data-start="1030660">but only when the data it depends on changes.</span> <span data-start="1033369">And it's actually a directive factory.</span> <span data-start="1036175">So the way it works is that you give it</span> <span data-start="1037800">in async function that takes some data</span> <span data-start="1040140">and produces a result, and it returns to you</span> <span data-start="1042150">a directive that you can use inside your lit-html template.</span> <span data-start="1045880">So if we want to reproduce the previous example here using</span> <span data-start="1050370">this fetch, we can just create a fetch content directive</span> <span data-start="1053970">by passing runAsync a function that takes a file name</span> <span data-start="1056980">and calls fetch for us.</span> <span data-start="1060089">And when we go to use it, we can just</span> <span data-start="1061630">use it inside of our template.</span> <span data-start="1063130">And we pass it the file name here,</span> <span data-start="1065650">and then we pass it another template that's</span> <span data-start="1067690">going to render when we have successfully</span> <span data-start="1070270">resolved that promise.</span> <span data-start="1072350">So this lets us get part of the way to our goal here.</span> <span data-start="1076780">We can render some asynchronous data,</span> <span data-start="1078910">but it turns out that asynchronous data</span> <span data-start="1080710">can be in a number of different states.</span> <span data-start="1083740">For any async operation, you can be in initial state, which</span> <span data-start="1087220">means you haven't started it.</span> <span data-start="1088510">You can be pending.</span> <span data-start="1089950">It can have successfully completed or ended in failure.</span> <span data-start="1093260">And so it really helps us if we model and think</span> <span data-start="1095230">about all of these states explicitly,</span> <span data-start="1097630">so that we make sure we handle them.</span> <span data-start="1099377">We can see that our directive actually</span> <span data-start="1100960">takes templates for all of the different states</span> <span data-start="1104140">that our UI can be in.</span> <span data-start="1105130">So we have a success template, a pending template,</span> <span data-start="1108040">a initial state template, and an error template.</span> <span data-start="1111150">And to make this a little bit more realistic,</span> <span data-start="1113300">I made a demo that searches the NPM package repository.</span> <span data-start="1117350">And this is a basic search as you</span> <span data-start="1118960">type live search result demo.</span> <span data-start="1121510">And it has a simple UI.</span> <span data-start="1122650">We just have a search box and a results panel down here.</span> <span data-start="1125720">OK, so we're going to build this demo in two parts, hopefully.</span> <span data-start="1129130">So first, we're going to define a searchPackages directive</span> <span data-start="1131710">using runAsync.</span> <span data-start="1133630">And so here's our initial starting point</span> <span data-start="1135520">for this directive.</span> <span data-start="1136870">Our async task function here is going</span> <span data-start="1139390">to generate a URL for the NPM search service</span> <span data-start="1143950">here and then get the results by fetching it.</span> <span data-start="1146979">And then here, we're going to handle the response</span> <span data-start="1149020">and just do a little bit of due diligence</span> <span data-start="1150880">and make sure that we have a 200 response and return that.</span> <span data-start="1154300">Otherwise, we throw the message we got back.</span> <span data-start="1158470">And I wanted to make this task able to trigger</span> <span data-start="1162280">that initial state template.</span> <span data-start="1164340">And the way we do that in runAsync, we</span> <span data-start="1168980">throw an initial state error.</span> <span data-start="1170500">So here, I'm just going to check to make sure we</span> <span data-start="1171940">have a query we can execute.</span> <span data-start="1173190">And if not, I'm going to throw this error.</span> <span data-start="1174940">And runAsync is going to render the initial state template.</span> <span data-start="1179470">And then it turns out that the NPM registry</span> <span data-start="1181360">is a little difficult to get it to trigger an error.</span> <span data-start="1183820">Usually, it just returns empty results.</span> <span data-start="1185870">So to be able to show the error state template,</span> <span data-start="1188440">I just do some prevalidation here of the query</span> <span data-start="1190480">and make sure we don't start with the dot or underscore.</span> <span data-start="1193090">And then finally, to make this even more realistic, if you're</span> <span data-start="1196330">doing a search as you type UI, you're</span> <span data-start="1198462">going to have a lot of requests that you initiate where you</span> <span data-start="1200920">don't care about the results, because you've</span> <span data-start="1203320">typed in a different query by the time the result gets back.</span> <span data-start="1207180">So the fetch API is able to take something</span> <span data-start="1208930">called an abort signal, so that we can cancel the request.</span> <span data-start="1211840">And so runAsync will generate an abort signal for you.</span> <span data-start="1214780">And then you get it in this options argument here</span> <span data-start="1217180">and you can forward this on to the fetch API.</span> <span data-start="1220600">And so this is our entire searchPackages directive</span> <span data-start="1223390">here built with runAsync.</span> <span data-start="1226040">And so next, we just need to use it.</span> <span data-start="1228250">Here's a little snippet of the demo UI.</span> <span data-start="1230660">We have an input element here, which</span> <span data-start="1233660">just simply displays the query and updates the query on input.</span> <span data-start="1237260">And then down here, we use the searchPackages directive.</span> <span data-start="1241430">And so we use it by passing it to query.</span> <span data-start="1243364">And then, we give it a success template.</span> <span data-start="1245030">Here, we just iterate over the results</span> <span data-start="1246613">and display little cards.</span> <span data-start="1248400">And then we give it the pending, initial,</span> <span data-start="1251150">and error state templates here.</span> <span data-start="1254690">And so when we go to use this demo,</span> <span data-start="1257085">we see that we have the initial state template rendering.</span> <span data-start="1259460">Sorry that's small.</span> <span data-start="1260360">It says enter a search term.</span> <span data-start="1262340">When we type, it turns into loading.</span> <span data-start="1264750">And then we get our results back.</span> <span data-start="1267110">And if we were to go back and enter a query that</span> <span data-start="1269480">starts with an invalid character,</span> <span data-start="1271282">you're going to see the error template there, and that even</span> <span data-start="1273740">updates as you type.</span> <span data-start="1275840">And if you realize your mistake, and go in</span> <span data-start="1277850">and type in a new term, you're going</span> <span data-start="1279570">to get all the intermediate async state</span> <span data-start="1283880">templates as you type.</span> <span data-start="1285270">So that's the demo, and you really</span> <span data-start="1286820">did see most of the implementation there.</span> <span data-start="1288528">So it was quite easy to do with that directive.</span> <span data-start="1291470">And the key takeaway here is that we</span> <span data-start="1292970">want to explicitly model our asynchronous operation state.</span> <span data-start="1296870">If we do that, we're more sure to take care of all the states</span> <span data-start="1300020">that we can be in.</span> <span data-start="1301220">And if we build a UI for each state,</span> <span data-start="1302790">then we're going to accurately let</span> <span data-start="1304460">our users know what is going on with the application.</span> <span data-start="1307010">And they're going to have a better user experience.</span> <span data-start="1310620">OK, so finally, once we have an application</span> <span data-start="1313100">and a UI built up of all these asynchronous components,</span> <span data-start="1316300">we might need to coordinate them.</span> <span data-start="1318000">Right?</span> <span data-start="1318500">So if you have a lot of async children in your page,</span> <span data-start="1323580">how do we ensure a consistent UI if you want to?</span> <span data-start="1326630">Or how do we avoid a sea of spinners?</span> <span data-start="1330230">And so to demonstrate the sea of spinners problem,</span> <span data-start="1334610">I added to the demo a little feature here</span> <span data-start="1337040">where when you search, the cards are</span> <span data-start="1339270">going to do their own query to bring up the disk</span> <span data-start="1341270">tag of your NPM packages.</span> <span data-start="1343195">And you can see there that we saw a lot of spinners</span> <span data-start="1345320">on the page, and this can be a distracting UI.</span> <span data-start="1348556">So we want to give developers an option</span> <span data-start="1350180">to not have to deal with the sea of spinners.</span> <span data-start="1352947">And the way we're going to handle this</span> <span data-start="1354530">is that we're going to coordinate the components here</span> <span data-start="1356738">with events.</span> <span data-start="1357840">So what we're going to do is we're</span> <span data-start="1359256">going to fire a promise carrying event.</span> <span data-start="1361250">And that promise is going to resolve when some work is done.</span> <span data-start="1363780">So an async child component creates a promise,</span> <span data-start="1366260">fires this event, and then resolves the promise.</span> <span data-start="1369267">And so that's going to look like this.</span> <span data-start="1370850">A is going to be our container up there.</span> <span data-start="1373300">And E and F are our async children.</span> <span data-start="1374927">And they're going to fire this pending state</span> <span data-start="1376760">event that holds a promise.</span> <span data-start="1379490">The container is going to handle the event</span> <span data-start="1381320">and wait for that promise.</span> <span data-start="1382437">And then the children when the work is done,</span> <span data-start="1384270">they're going to resolve the promise.</span> <span data-start="1385811">And finally, when all the promises have settled,</span> <span data-start="1389510">we're going to update the UI.</span> <span data-start="1391580">So that brings us to our last experimental prototype</span> <span data-start="1395960">here called PendingContainer.</span> <span data-start="1397960">And PendingContainer takes care of all this plumbing for you.</span> <span data-start="1402410">And it's a class mix in, so you can apply this</span> <span data-start="1404390">to a superclass like LitElement.</span> <span data-start="1406550">And this has two features too.</span> <span data-start="1409310">We have the has pending children property.</span> <span data-start="1411934">So this indicates whether or not there's</span> <span data-start="1413600">async work happening below you.</span> <span data-start="1415550">And when this property changes, it's</span> <span data-start="1417050">going to cause a rerender of the element.</span> <span data-start="1419324">And then we have an event listener</span> <span data-start="1420740">that listens for the pending state event</span> <span data-start="1423200">and then triggers the bookkeeping</span> <span data-start="1424580">so that we know if we have any extra work pending below us.</span> <span data-start="1428840">And to use it, you can just apply this mix</span> <span data-start="1430700">in to the superclass here, to LitElement.</span> <span data-start="1434090">And once you do that, you get available</span> <span data-start="1436070">the has pending children property that</span> <span data-start="1437690">can be used in your template.</span> <span data-start="1439830">And so now we're going to add a spinner,</span> <span data-start="1442220">and this is a top level spinner, to the UI that's</span> <span data-start="1445100">triggered based on whether or not</span> <span data-start="1447080">there's any pending children.</span> <span data-start="1448740">And so the runAsync helper is going</span> <span data-start="1450610">to fire these events for us.</span> <span data-start="1451850">And this container mix in is going to capture them.</span> <span data-start="1454760">And so what we're going for here is</span> <span data-start="1456260">a UI where we have a spinner — </span> <span data-start="1459460">and it happened again.</span> <span data-start="1461960">There we go.</span> <span data-start="1462460">OK.</span> <span data-start="1463120">Might just be a faulty button here.</span> <span data-start="1465740">So what we want to add here is a spinner at the top of the UI</span> <span data-start="1468530">that's going to be going whenever there are pending</span> <span data-start="1471760">search results coming back from the server,</span> <span data-start="1473860">or we have children that need to update.</span> <span data-start="1476360">So now you see we get the spinner as we type.</span> <span data-start="1478512">We don't get the spinner on the children,</span> <span data-start="1480220">but we can see the top level spinner is still going.</span> <span data-start="1483050">And then the results come in and the spinner stops.</span> <span data-start="1485836">And so that's the UI we were going for,</span> <span data-start="1487460">and it was pretty straightforward to build</span> <span data-start="1489340">with these directives.</span> <span data-start="1492160">So when you have an asynchronous UI,</span> <span data-start="1493834">there's a lot of different options</span> <span data-start="1495250">that you have for how to handle this.</span> <span data-start="1497480">You could try to block the UI while you have pending work.</span> <span data-start="1501610">You could show the raw incremental updates.</span> <span data-start="1504070">You could have individual spinners on your page,</span> <span data-start="1506140">or you could try to replace that all with top level</span> <span data-start="1508510">placeholders and spinners.</span> <span data-start="1510670">So what you want to do depends on the UX and the UI</span> <span data-start="1514904">that you're trying to build.</span> <span data-start="1516070">But the key here is to provide the plumbing and the framework</span> <span data-start="1519460">and the nice API so that you can build</span> <span data-start="1521860">whatever you choose to build.</span> <span data-start="1524690">And that went two slides forward.</span> <span data-start="1526510">All right, well, this is my wrap up.</span> <span data-start="1529960">So we're very excited about some additional work that's</span> <span data-start="1532480">going to be done in this area.</span> <span data-start="1533830">So Jason and Shubhie talked about the native scheduler</span> <span data-start="1536080">API, which we're extremely excited about.</span> <span data-start="1538900">Display locking is a new proposal</span> <span data-start="1540490">where you're going to be able to lock</span> <span data-start="1541390">an entire portion of your screen so that you</span> <span data-start="1543223">can update it incrementally and then</span> <span data-start="1545080">flip it to the new version.</span> <span data-start="1546605">And Greg talked about virtual scroller,</span> <span data-start="1548230">which is going to let us handle large amounts of data as well.</span> <span data-start="1551324">And then on our end, we're going to be working on more libraries</span> <span data-start="1553990">and examples of how to do things like lazy load</span> <span data-start="1556000">components, background rendering, and viewport base</span> <span data-start="1559522">visibility rendering, so that things only render when</span> <span data-start="1561730">they show up on the screen.</span> <span data-start="1564270">I have a few links here.</span> <span data-start="1565270">These will probably be easier to get to from the video.</span> <span data-start="1568300">And then I'm going to be over in the Ask Chrome area</span> <span data-start="1571240">doing Q&A after this, if you'd like to ask any questions.</span> <span data-start="1574750">OK, thank you.</span> <span data-start="1576490">[MUSIC PLAYING]</span> </section>

</div>

</body>

</html>
