WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.395
[MUSIC PLAYING]

00:00:05.372 --> 00:00:06.830
HOUSSEIN DJIRDEH:
Hello, everybody.

00:00:06.830 --> 00:00:09.340
My name's Houssein Djirdeh, and
I'm a web developer advocate

00:00:09.340 --> 00:00:10.038
here at Google.

00:00:10.038 --> 00:00:11.330
SHUBHIE PANICKER: Hi, everyone.

00:00:11.330 --> 00:00:12.760
My name is Shubhie Panicker.

00:00:12.760 --> 00:00:16.060
I'm a software engineer working
on the web platform in Chrome.

00:00:16.060 --> 00:00:17.560
HOUSSEIN DJIRDEH:
And our talk today

00:00:17.560 --> 00:00:20.380
will cover how we at Chrome
have been advancing the web

00:00:20.380 --> 00:00:23.600
framework ecosystem in a
number of different ways.

00:00:26.820 --> 00:00:30.750
Engineers, managers, advocates,
and everybody on the Chrome

00:00:30.750 --> 00:00:33.750
team share a very
common goal, and that

00:00:33.750 --> 00:00:36.690
is answering the question
of how we can collectively

00:00:36.690 --> 00:00:39.060
make the web better.

00:00:39.060 --> 00:00:40.770
Now there's a number
of different ways

00:00:40.770 --> 00:00:44.740
that we try and
make this possible.

00:00:44.740 --> 00:00:47.430
We continue to improve the
core JavaScript and WebAssembly

00:00:47.430 --> 00:00:50.690
engine that powers Chrome.

00:00:50.690 --> 00:00:53.870
We also continue to improve
the API surface provided

00:00:53.870 --> 00:00:55.640
by the browser so
that developers

00:00:55.640 --> 00:00:57.890
are better equipped
with APIs that they

00:00:57.890 --> 00:01:03.530
can use to improve how their
sites function and load.

00:01:03.530 --> 00:01:05.209
And at another
angle, we also try

00:01:05.209 --> 00:01:09.610
to improve websites that are
already in production today.

00:01:09.610 --> 00:01:11.570
But things get a
little tricky here.

00:01:11.570 --> 00:01:13.540
How exactly should we do this?

00:01:16.920 --> 00:01:18.450
For the most part,
we can probably

00:01:18.450 --> 00:01:20.640
agree that most web
developers do not

00:01:20.640 --> 00:01:24.390
build entirely custom
infrastructure and tooling.

00:01:24.390 --> 00:01:26.580
Where possible,
developers usually

00:01:26.580 --> 00:01:30.730
prefer to rely on
open source tools.

00:01:30.730 --> 00:01:34.620
So one way to improve actual
websites that developers ship

00:01:34.620 --> 00:01:37.470
are to improve the actual
tools that are being

00:01:37.470 --> 00:01:40.270
used to build those sites.

00:01:40.270 --> 00:01:42.460
Better open-source
tooling can directly

00:01:42.460 --> 00:01:44.140
result in a better web.

00:01:47.070 --> 00:01:51.130
But what exactly do we mean
by open-source tooling?

00:01:51.130 --> 00:01:54.550
Well, when it comes to building
a brand new site from scratch,

00:01:54.550 --> 00:01:56.890
developers today
have many options.

00:01:59.490 --> 00:02:01.260
Client-side
frameworks can be used

00:02:01.260 --> 00:02:05.480
to build dynamic and fully
fledged single page apps.

00:02:05.480 --> 00:02:08.479
Static site generators are
tools many people use to build

00:02:08.479 --> 00:02:11.850
static sites and applications.

00:02:11.850 --> 00:02:14.220
People also have the option
to use a content management

00:02:14.220 --> 00:02:15.950
system.

00:02:15.950 --> 00:02:17.450
And there are also
website builders,

00:02:17.450 --> 00:02:21.510
like Wix and Squarespace.

00:02:21.510 --> 00:02:23.550
For the purpose of
this talk, we want

00:02:23.550 --> 00:02:27.150
to focus on one of these
categories specifically.

00:02:27.150 --> 00:02:30.621
Namely, client-side
frameworks and UI libraries.

00:02:34.310 --> 00:02:37.100
MDN will soon release the first
edition of their developer

00:02:37.100 --> 00:02:39.470
and designer survey
to try and learn more

00:02:39.470 --> 00:02:43.560
about the needs and
frustrations of web developers.

00:02:43.560 --> 00:02:47.400
With over 28,000 responses,
one interesting result

00:02:47.400 --> 00:02:51.450
from this survey was
that 72% of respondents

00:02:51.450 --> 00:02:55.950
actively use React, Angular,
or Vue for their sites.

00:02:59.693 --> 00:03:01.110
We also tried to
look at this data

00:03:01.110 --> 00:03:03.660
from a slightly different
angle and find out

00:03:03.660 --> 00:03:07.340
how many sites that use
frameworks make up the top 100

00:03:07.340 --> 00:03:10.760
URLs by time spent.

00:03:10.760 --> 00:03:13.800
And we found that 30
of the top 100 URLs

00:03:13.800 --> 00:03:16.860
use React, Angular, or Vue.

00:03:16.860 --> 00:03:19.770
And this does not take into
account many other frameworks

00:03:19.770 --> 00:03:21.181
that are available.

00:03:24.500 --> 00:03:26.000
We also wanted to
get an idea of how

00:03:26.000 --> 00:03:30.770
many actual sites in the
wild use a tool like React.

00:03:30.770 --> 00:03:35.990
By using HTTP Archive, we
found that over 350,000 origins

00:03:35.990 --> 00:03:37.990
use React in some form.

00:03:41.590 --> 00:03:43.450
All this data shows
that frameworks

00:03:43.450 --> 00:03:45.670
are used in a lot of sites.

00:03:45.670 --> 00:03:49.460
So it's not really just about
advancing the ecosystem itself,

00:03:49.460 --> 00:03:51.460
but by doing that, we
would ultimately be

00:03:51.460 --> 00:03:53.750
advancing the web as a whole.

00:03:57.833 --> 00:04:00.250
SHUBHIE PANICKER: So we've
identified our target audience,

00:04:00.250 --> 00:04:01.830
but how can we help?

00:04:01.830 --> 00:04:05.250
Most concerns here fall
into two broad categories--

00:04:05.250 --> 00:04:08.020
user experience and
developer experience.

00:04:08.020 --> 00:04:11.070
So that's UX and DX.

00:04:11.070 --> 00:04:13.880
Most of our talk today is
going to be focused on user

00:04:13.880 --> 00:04:15.470
experience and performance.

00:04:19.750 --> 00:04:21.300
This is an important problem.

00:04:21.300 --> 00:04:24.480
Frameworks are struggling
to meet Chrome's targets

00:04:24.480 --> 00:04:28.350
for user-centric metrics, like
first contentful paint, largest

00:04:28.350 --> 00:04:31.620
contentful paint,
first input delay.

00:04:31.620 --> 00:04:33.010
Paul and Elizabeth's
talk covered

00:04:33.010 --> 00:04:34.880
what these metrics mean.

00:04:34.880 --> 00:04:38.220
Our tooling emphasizes
the initial page a lot.

00:04:38.220 --> 00:04:40.630
And this is challenging
for these apps.

00:04:40.630 --> 00:04:43.270
On the other hand, they do
well on route transition,

00:04:43.270 --> 00:04:44.800
subsequent interactions.

00:04:44.800 --> 00:04:48.370
But our metrics don't
reflect this yet.

00:04:48.370 --> 00:04:51.550
So how should we invest
in the framework ecosystem

00:04:51.550 --> 00:04:56.123
to address both DX
and UX challenges?

00:04:56.123 --> 00:04:57.540
We think there's
a big opportunity

00:04:57.540 --> 00:05:01.200
here for tooling to help
with both of these problems.

00:05:01.200 --> 00:05:03.810
In particular, by
bringing good defaults

00:05:03.810 --> 00:05:06.360
and by being opinionated.

00:05:06.360 --> 00:05:08.540
So I want to take a
moment here to define

00:05:08.540 --> 00:05:11.720
this notion of what we decided
to call a web framework.

00:05:11.720 --> 00:05:15.080
It's an end-to-end system
that controls every aspect,

00:05:15.080 --> 00:05:19.020
from getting started, everyday
development, to deployment.

00:05:19.020 --> 00:05:22.460
It's directly positioned
to impact both UX and DX

00:05:22.460 --> 00:05:25.040
by controlling the
server and the client,

00:05:25.040 --> 00:05:29.280
the build and the serve, the
dev and the prod environments.

00:05:29.280 --> 00:05:32.690
And this is a core premise
of our work in this space.

00:05:32.690 --> 00:05:34.700
Through these web
frameworks, we want

00:05:34.700 --> 00:05:38.600
to enable developers to
successfully build and maintain

00:05:38.600 --> 00:05:40.520
high quality production apps.

00:05:43.070 --> 00:05:47.120
So a web framework helps a
developer to be productive.

00:05:47.120 --> 00:05:49.640
Building a production
app just requires

00:05:49.640 --> 00:05:52.400
too many different moving
parts that the developer

00:05:52.400 --> 00:05:55.370
has to reason about
and string together.

00:05:55.370 --> 00:05:59.630
This list is just a small subset
of the concerns of a production

00:05:59.630 --> 00:06:00.740
app.

00:06:00.740 --> 00:06:03.050
And if you are
thinking that I want

00:06:03.050 --> 00:06:06.440
to minimize opinions and
integration so I can maximize

00:06:06.440 --> 00:06:10.130
my flexibility, consider
embedding yourself

00:06:10.130 --> 00:06:13.280
in a team of developers who
are on the hook for shipping

00:06:13.280 --> 00:06:14.990
a business critical app.

00:06:14.990 --> 00:06:19.380
Developers want to-- and
should-- focus on features.

00:06:19.380 --> 00:06:22.550
And I know this from my personal
experience working at Google,

00:06:22.550 --> 00:06:25.490
being on the hook on infra
teams for shipping products

00:06:25.490 --> 00:06:29.660
like Google Search,
Google Photos.

00:06:29.660 --> 00:06:31.700
In addition to
developer productivity,

00:06:31.700 --> 00:06:34.310
web frameworks are also
directly positioned

00:06:34.310 --> 00:06:36.790
to impact performance and UX.

00:06:36.790 --> 00:06:38.750
And this is because
they bring opinions

00:06:38.750 --> 00:06:41.000
on things like
server-side rendering,

00:06:41.000 --> 00:06:43.880
flushing early HTML
chunks, streaming.

00:06:43.880 --> 00:06:48.040
They control how and when
exactly to fetch JavaScript,

00:06:48.040 --> 00:06:50.830
CSS, data, and images.

00:06:50.830 --> 00:06:53.660
They unlock features,
like progressive delivery,

00:06:53.660 --> 00:06:54.590
lazy fetching.

00:06:54.590 --> 00:06:58.365
All of this directly impacts
those user-centric performance

00:06:58.365 --> 00:06:58.865
metrics.

00:07:02.320 --> 00:07:04.170
So I want to take a
moment here to clarify

00:07:04.170 --> 00:07:08.070
the distinction between,
on the left, a UI framework

00:07:08.070 --> 00:07:12.780
or library versus what I just
defined as a web framework.

00:07:12.780 --> 00:07:15.360
UI frame libraries
like React and Vue,

00:07:15.360 --> 00:07:17.910
they tend to be agnostic to a
lot of the concerns I mentioned

00:07:17.910 --> 00:07:19.140
before.

00:07:19.140 --> 00:07:21.780
On the right, we have
fuller featured frameworks

00:07:21.780 --> 00:07:26.160
in the ecosystem, like
Next, Nuxt, Gatsby.

00:07:26.160 --> 00:07:29.370
Angular and Ember kind
of blurred the line here

00:07:29.370 --> 00:07:31.810
by playing both roles.

00:07:31.810 --> 00:07:34.710
So if you're starting
to build a new app,

00:07:34.710 --> 00:07:38.400
I recommend reaching for a
full-featured web framework

00:07:38.400 --> 00:07:40.410
so that developers
on your team can

00:07:40.410 --> 00:07:42.720
focus on what matters
most to them, which

00:07:42.720 --> 00:07:44.040
is building features.

00:07:44.040 --> 00:07:46.110
Starting with a
bare-bones UI framework

00:07:46.110 --> 00:07:48.750
means reinventing the
wheel and building

00:07:48.750 --> 00:07:49.950
a lot of your own infra.

00:07:52.870 --> 00:07:55.360
So we're excited
for all the strides

00:07:55.360 --> 00:08:00.470
being made by web frameworks
and UI frameworks in this space.

00:08:00.470 --> 00:08:02.110
These are all the
accomplishments

00:08:02.110 --> 00:08:04.180
from various frameworks--

00:08:04.180 --> 00:08:09.310
Angular, Vue, Svelte,
Ember, Gatsby, and React.

00:08:11.950 --> 00:08:14.300
We are in close contact
with the Angular team

00:08:14.300 --> 00:08:18.950
and really excited for their
achievements on both UX and DX.

00:08:18.950 --> 00:08:21.860
In particular, they share
differential loading,

00:08:21.860 --> 00:08:25.460
which reduces polyfill
in modern browsers,

00:08:25.460 --> 00:08:27.500
and they have
automatic deployments

00:08:27.500 --> 00:08:30.050
to different platforms, to
name a couple of things.

00:08:32.682 --> 00:08:34.390
Also, [? Dion ?]
mentioned in the keynote

00:08:34.390 --> 00:08:36.490
that we have funded
a number of projects

00:08:36.490 --> 00:08:37.600
with the framework fund.

00:08:37.600 --> 00:08:39.799
We'll have funding
again next year.

00:08:39.799 --> 00:08:42.370
So if you're playing a role
in the framework ecosystem,

00:08:42.370 --> 00:08:46.240
providing something of value,
please apply for funding.

00:08:46.240 --> 00:08:50.500
This is just another way to
scale beyond our own small team

00:08:50.500 --> 00:08:51.760
by helping other teams.

00:08:54.620 --> 00:08:57.150
At Google I/O, I mentioned
that we kicked off

00:08:57.150 --> 00:09:01.800
an effort in the space directly
collaborating with Next.js.

00:09:01.800 --> 00:09:04.600
In particular, we are starting
with performance improvements

00:09:04.600 --> 00:09:05.640
first.

00:09:05.640 --> 00:09:07.530
Both because this is
an important problem

00:09:07.530 --> 00:09:09.720
needing attention,
but also, it wasn't

00:09:09.720 --> 00:09:11.295
overlapping with other efforts.

00:09:14.040 --> 00:09:16.320
So hopefully at this
point, the choice of React

00:09:16.320 --> 00:09:17.820
might be clearer.

00:09:17.820 --> 00:09:19.740
It has a huge
developer mindshare,

00:09:19.740 --> 00:09:22.860
it's heavily used in
apps where Chrome and web

00:09:22.860 --> 00:09:25.230
users are spending their time.

00:09:25.230 --> 00:09:27.810
And we found Next.js was the
most production ready web

00:09:27.810 --> 00:09:31.320
framework for building a
general purpose React app.

00:09:31.320 --> 00:09:35.832
Plus, we're a small team, so
we had to start somewhere.

00:09:35.832 --> 00:09:38.040
And finally, we're definitely
counting on and working

00:09:38.040 --> 00:09:40.830
towards having ripple
effects and inspired

00:09:40.830 --> 00:09:43.890
copying in other parts
of the web frameworks,

00:09:43.890 --> 00:09:49.600
like Gatsby, Nuxt,
Angular, Ember, et cetera.

00:09:49.600 --> 00:09:52.420
So this investment in
the framework ecosystem

00:09:52.420 --> 00:09:56.230
is an additional
space that we missed.

00:09:56.230 --> 00:09:58.420
This helps bring the
web platform work

00:09:58.420 --> 00:10:00.700
to a lot more developers.

00:10:00.700 --> 00:10:02.830
And we realized
as an organization

00:10:02.830 --> 00:10:05.530
that our efforts are
better spent collaborating

00:10:05.530 --> 00:10:08.320
and contributing to the
framework ecosystem,

00:10:08.320 --> 00:10:11.570
instead of competing and
pushing our own frameworks.

00:10:11.570 --> 00:10:15.310
And it is in this spirit that
we are contributing to Next.js

00:10:15.310 --> 00:10:17.770
instead of building our
own thing from scratch.

00:10:21.180 --> 00:10:23.770
So I mentioned that we'll
have a performance focus, both

00:10:23.770 --> 00:10:25.370
for our work and this talk.

00:10:25.370 --> 00:10:28.130
So which problems should
be addressed specifically?

00:10:28.130 --> 00:10:31.400
To understand what's going on
and why [INAUDIBLE] targets

00:10:31.400 --> 00:10:34.400
are not being met for
these user-centric metrics,

00:10:34.400 --> 00:10:38.420
we did deep tracing on
25 Next and React apps.

00:10:38.420 --> 00:10:40.430
And I want to share
some insights,

00:10:40.430 --> 00:10:42.950
as it directly informs
the projects that we

00:10:42.950 --> 00:10:45.960
are undertaking in this space.

00:10:45.960 --> 00:10:49.050
By far, the big issue
that stands out in traces

00:10:49.050 --> 00:10:54.480
is this delay in servicing
the first user interaction.

00:10:54.480 --> 00:10:58.010
And this is typically from
fetching lots of JavaScript.

00:10:58.010 --> 00:11:02.060
So that's all the network
from [? HTTP/2 ?] in yellow

00:11:02.060 --> 00:11:04.730
on the left, and
then executing all

00:11:04.730 --> 00:11:07.700
of that code on the main thread.

00:11:07.700 --> 00:11:10.000
And that's in pink.

00:11:10.000 --> 00:11:14.160
And as you can see, that long
execution on the main thread

00:11:14.160 --> 00:11:17.170
is blocking the
user's interaction.

00:11:17.170 --> 00:11:18.960
So in this case,
it's taking a couple

00:11:18.960 --> 00:11:21.750
of seconds on the network and
another two to three seconds

00:11:21.750 --> 00:11:23.290
on the main thread.

00:11:23.290 --> 00:11:25.680
This is a long
window during which

00:11:25.680 --> 00:11:27.608
the user is unable to interact.

00:11:27.608 --> 00:11:29.400
This is one reason why
a lot of our efforts

00:11:29.400 --> 00:11:31.500
have been focused on JavaScript.

00:11:34.182 --> 00:11:35.890
First interaction
isn't the only problem.

00:11:35.890 --> 00:11:39.400
We're also seeing slow times
for first contentful paint,

00:11:39.400 --> 00:11:41.190
largest contentful paint.

00:11:41.190 --> 00:11:44.380
And there's a number
of reasons for this.

00:11:44.380 --> 00:11:46.050
For example, the
time to first byte

00:11:46.050 --> 00:11:48.710
is low and takes over a second.

00:11:48.710 --> 00:11:52.170
We're often seeing sync scripts
in [? head ?] that are render

00:11:52.170 --> 00:11:54.720
blocking, including
third party scripts that

00:11:54.720 --> 00:11:57.190
tend to sneak in here.

00:11:57.190 --> 00:12:00.840
Web fonts are slow, hero images
are slow, and sometimes not

00:12:00.840 --> 00:12:03.130
optimized.

00:12:03.130 --> 00:12:05.290
And finally, the third
problem I want to mention

00:12:05.290 --> 00:12:07.520
is the problem of data.

00:12:07.520 --> 00:12:09.910
Data is as important
as JavaScript

00:12:09.910 --> 00:12:13.010
for rendering content,
getting the page hydrated.

00:12:13.010 --> 00:12:16.000
And we are seeing a lot
of fetching raw data

00:12:16.000 --> 00:12:19.880
from REST endpoints, a lot of
post-processing of the results.

00:12:19.880 --> 00:12:22.660
And this is a lot of
JavaScript work on the client,

00:12:22.660 --> 00:12:26.860
in addition to all the code
that's needed to execute this.

00:12:26.860 --> 00:12:29.570
And finally, there
is this waterfall

00:12:29.570 --> 00:12:32.650
from cascading fetches
of JavaScript and data.

00:12:32.650 --> 00:12:34.150
So I'm going to
hand off to Houssein

00:12:34.150 --> 00:12:37.910
to talk about what we are doing
about all of this in Next.js.

00:12:43.560 --> 00:12:45.060
HOUSSEIN DJIRDEH:
So one thing we've

00:12:45.060 --> 00:12:48.390
been doing the past six months
has been working closely

00:12:48.390 --> 00:12:51.300
with the Next.js team
to improve the framework

00:12:51.300 --> 00:12:53.490
in a number of different ways.

00:12:53.490 --> 00:12:55.410
And we've approached
this by identifying

00:12:55.410 --> 00:12:57.660
areas of improvement
along with the team

00:12:57.660 --> 00:13:01.283
and slowly incrementing and
adding optimizations one

00:13:01.283 --> 00:13:01.950
after the other.

00:13:06.160 --> 00:13:07.730
And this was a team effort.

00:13:07.730 --> 00:13:09.350
There were quite a
few of us involved

00:13:09.350 --> 00:13:12.050
that worked alongside many
amazing folks in the Next.js

00:13:12.050 --> 00:13:15.060
team that made it possible to
see a lot of these features

00:13:15.060 --> 00:13:15.560
land.

00:13:17.957 --> 00:13:19.540
For things that we
worked on, we tried

00:13:19.540 --> 00:13:22.790
to find the lowest hanging fruit
that will result in the biggest

00:13:22.790 --> 00:13:24.340
impact.

00:13:24.340 --> 00:13:27.610
This included improving the
Webpack chunking strategy used

00:13:27.610 --> 00:13:31.070
in Next.js, differential
loading to minimize

00:13:31.070 --> 00:13:34.100
the amount of polyfilled code
shipped to browsers that don't

00:13:34.100 --> 00:13:38.830
need it, a number of
JavaScript optimizations,

00:13:38.830 --> 00:13:41.860
improved performance tracking
by instrumenting a few custom

00:13:41.860 --> 00:13:45.580
metrics, and roles exploring
our conformance story

00:13:45.580 --> 00:13:47.680
to see if we can
generate better errors

00:13:47.680 --> 00:13:50.514
and warnings for common
developer [INAUDIBLE]..

00:13:53.403 --> 00:13:55.070
To begin, let's start
talking about what

00:13:55.070 --> 00:13:58.280
we've been doing to improve
how chunks get generated

00:13:58.280 --> 00:14:03.030
in every Next.js application.

00:14:03.030 --> 00:14:06.270
We began by leveraging
Webpack's SplitChunksPlugin

00:14:06.270 --> 00:14:10.320
to modify how a Next.js app
gets chunked and outputted

00:14:10.320 --> 00:14:11.880
to the browser.

00:14:11.880 --> 00:14:14.880
We did this by making
sure a separate chunk is

00:14:14.880 --> 00:14:19.490
outputted for every third-party
dependency of a certain size.

00:14:19.490 --> 00:14:23.290
All framework-specific libraries
like React and ReactDOM

00:14:23.290 --> 00:14:27.060
are output in their own
fixed, cacheable chunk.

00:14:27.060 --> 00:14:28.790
And the rest of the
application code

00:14:28.790 --> 00:14:32.750
is outputted in multiple small
shared chunks that minimize

00:14:32.750 --> 00:14:36.240
duplicate code across routes.

00:14:36.240 --> 00:14:38.430
The main purpose of
this new strategy

00:14:38.430 --> 00:14:41.700
is specifically to limit
code shipped to the browser

00:14:41.700 --> 00:14:44.715
to only what is actually
needed for the route itself.

00:14:48.690 --> 00:14:50.250
We tried our new
chunking strategy

00:14:50.250 --> 00:14:52.710
with a few major
Next.js sites, one

00:14:52.710 --> 00:14:56.550
of them being Barnebys.com,
a large search engine

00:14:56.550 --> 00:14:59.130
for antiques and collectibles.

00:14:59.130 --> 00:15:01.890
Almost immediately we
saw some amazing wins

00:15:01.890 --> 00:15:03.240
with granular chunking enabled.

00:15:05.790 --> 00:15:08.590
And here you can see a side
by side of the same site

00:15:08.590 --> 00:15:11.560
with and without
the feature enabled.

00:15:11.560 --> 00:15:14.680
The biggest wins were
noticed after navigating

00:15:14.680 --> 00:15:18.288
to multiple routes throughout
the entire application.

00:15:25.130 --> 00:15:27.920
You can see that after
navigating through six pages,

00:15:27.920 --> 00:15:30.770
the difference in the amount
of JavaScript code fetched

00:15:30.770 --> 00:15:32.420
was substantial.

00:15:32.420 --> 00:15:34.190
Over a hundred
kilobytes of duplicate

00:15:34.190 --> 00:15:37.550
code was shaved using a
better and more nuanced

00:15:37.550 --> 00:15:38.330
chunking strategy.

00:15:42.340 --> 00:15:45.850
With Barnebys.com, a
23% app size reduction

00:15:45.850 --> 00:15:49.490
was noticed with much faster
navigations and improved cache.

00:15:53.850 --> 00:15:56.650
And if we take a look at things
in terms of the largest bundle,

00:15:56.650 --> 00:15:58.480
the biggest
JavaScript chunk alone

00:15:58.480 --> 00:16:02.790
was cut down in size by 30%.

00:16:02.790 --> 00:16:05.130
SumUp, another
major Next.js site

00:16:05.130 --> 00:16:07.130
that we tested our
chunking strategy on,

00:16:07.130 --> 00:16:12.290
saw a reduction in their largest
JavaScript bundle by 64%.

00:16:12.290 --> 00:16:14.530
And again, the amazing
thing about these changes

00:16:14.530 --> 00:16:17.770
is that it involved no actual
change to the user's code

00:16:17.770 --> 00:16:19.220
whatsoever.

00:16:19.220 --> 00:16:20.860
This is all by
just turning a flag

00:16:20.860 --> 00:16:23.740
on that changed the
chunking strategy to use

00:16:23.740 --> 00:16:25.780
our newer granular approach.

00:16:29.840 --> 00:16:32.530
Now differential loading
was another optimization

00:16:32.530 --> 00:16:35.003
that we worked on.

00:16:35.003 --> 00:16:36.670
And the idea behind
differential loading

00:16:36.670 --> 00:16:40.060
is to serve modern JavaScript
to modern browsers, which

00:16:40.060 --> 00:16:43.960
is often 80% to 90% of traffic.

00:16:43.960 --> 00:16:45.820
To do this, we
leveraged the fact

00:16:45.820 --> 00:16:48.910
that modern browsers
recognize and load script tags

00:16:48.910 --> 00:16:51.850
with type module
and ignore scripts

00:16:51.850 --> 00:16:54.700
with a nomodule attribute.

00:16:54.700 --> 00:16:57.890
Older browsers don't
recognize these attributes,

00:16:57.890 --> 00:17:00.130
so they load the more
aggressively transpiled

00:17:00.130 --> 00:17:04.200
and polyfilled nomodule scripts.

00:17:04.200 --> 00:17:06.450
By just applying this
simple technique,

00:17:06.450 --> 00:17:09.810
we saw a 7% reduction
in the total JavaScript

00:17:09.810 --> 00:17:13.020
for Barnebys and other sites.

00:17:13.020 --> 00:17:16.200
And that number jumps
to 15% when you look

00:17:16.200 --> 00:17:19.932
at only first-party JavaScript.

00:17:19.932 --> 00:17:21.390
There is a potential
here to reduce

00:17:21.390 --> 00:17:25.770
the size of your JavaScript
by up to 20% with no change

00:17:25.770 --> 00:17:28.339
to your code.

00:17:28.339 --> 00:17:31.980
So shipping modern code has
some great performance benefits.

00:17:31.980 --> 00:17:34.430
However, we wanted to
find ways to optimize

00:17:34.430 --> 00:17:37.890
this modern code even further.

00:17:37.890 --> 00:17:40.410
And to do this, we've been
working with the Babel team

00:17:40.410 --> 00:17:45.160
to improved support for
transpiling modern JavaScript.

00:17:45.160 --> 00:17:48.280
Many of us have used Babel
to transpile modern code

00:17:48.280 --> 00:17:51.040
so that it works
well in all browsers.

00:17:51.040 --> 00:17:54.970
More recently, it's become
common to use Babel preset-env

00:17:54.970 --> 00:17:57.650
to target modern browsers.

00:17:57.650 --> 00:17:59.650
And we do this by
transpiling code

00:17:59.650 --> 00:18:03.700
so that it runs in all browsers
that support script type module

00:18:03.700 --> 00:18:05.740
since that gives us
a nice way to send

00:18:05.740 --> 00:18:08.910
the code to those browsers.

00:18:08.910 --> 00:18:11.890
Today, we're excited to
introduce a new Babel

00:18:11.890 --> 00:18:16.700
preset that optimizes
specifically for this case.

00:18:16.700 --> 00:18:18.820
It's called
babel/preset-modules,

00:18:18.820 --> 00:18:22.577
and it's available
on npm right now.

00:18:22.577 --> 00:18:24.160
Let me show you how
it actually works.

00:18:27.260 --> 00:18:29.320
Let's say we have this
simple function written

00:18:29.320 --> 00:18:31.450
in modern JavaScript.

00:18:31.450 --> 00:18:34.210
Compiling this for
modern browsers using

00:18:34.210 --> 00:18:40.090
preset-env's target ES modules
outputs a fair bit of code.

00:18:40.090 --> 00:18:43.120
But running the same code
through preset-modules

00:18:43.120 --> 00:18:44.720
produces this.

00:18:44.720 --> 00:18:47.520
It's a lot smaller.

00:18:47.520 --> 00:18:48.390
Here's the thing.

00:18:48.390 --> 00:18:52.680
Both outputs run in all browsers
that support script type

00:18:52.680 --> 00:18:54.780
module.

00:18:54.780 --> 00:18:57.810
And this works because instead
of converting modern syntax

00:18:57.810 --> 00:19:00.740
to older syntax to
avoid browser bugs,

00:19:00.740 --> 00:19:04.290
the preset fixes each
specific bug by transforming

00:19:04.290 --> 00:19:07.530
to the closest possible
[? none-broken ?] modern

00:19:07.530 --> 00:19:09.670
syntax.

00:19:09.670 --> 00:19:13.420
In our example, only one
browser bug affects our code,

00:19:13.420 --> 00:19:17.060
and its equivalent
syntax circumvents it.

00:19:17.060 --> 00:19:18.950
The result is that
modern code can

00:19:18.950 --> 00:19:25.150
be delivered nearly unmodified
to most of your users.

00:19:25.150 --> 00:19:27.160
If you're developing
for modern browsers

00:19:27.160 --> 00:19:29.980
or using the module
nomodule approach,

00:19:29.980 --> 00:19:33.040
we're interested in hearing
how Babel preset-modules can

00:19:33.040 --> 00:19:35.042
work for you.

00:19:35.042 --> 00:19:37.000
We're also going to be
working on incorporating

00:19:37.000 --> 00:19:40.450
these optimizations
back into preset-env,

00:19:40.450 --> 00:19:43.551
bringing the benefits
to even more developers.

00:19:48.630 --> 00:19:50.430
Another thing we
did was try improve

00:19:50.430 --> 00:19:55.900
how we track performance in
a framework like Next.js.

00:19:55.900 --> 00:19:58.850
And we did this by leveraging
the User Timing API

00:19:58.850 --> 00:20:02.210
to add marks and measures for
key points in the application

00:20:02.210 --> 00:20:04.780
lifecycle.

00:20:04.780 --> 00:20:06.760
This includes the time
it takes for hydration

00:20:06.760 --> 00:20:09.640
to begin after loading a
page and the time it takes

00:20:09.640 --> 00:20:13.020
for hydration to complete and
the time it takes for rendering

00:20:13.020 --> 00:20:15.840
to start once you
make a rule change,

00:20:15.840 --> 00:20:19.270
and similarly, how long it takes
for a page to finish rendering

00:20:19.270 --> 00:20:22.010
after navigating to it.

00:20:22.010 --> 00:20:23.780
By applying what we
thought were some

00:20:23.780 --> 00:20:26.180
of the most important
performance metrics

00:20:26.180 --> 00:20:29.335
that should be tracked in a
web framework like Next.js,

00:20:29.335 --> 00:20:30.710
we wanted to make
sure developers

00:20:30.710 --> 00:20:32.750
don't have to worry
about trying to measure

00:20:32.750 --> 00:20:35.195
these nitty-gritty
metrics themselves.

00:20:38.170 --> 00:20:41.320
And the amazing thing with
leveraging the User Timing API

00:20:41.320 --> 00:20:44.080
is that all these values
will now automatically show

00:20:44.080 --> 00:20:48.187
every single time you test the
Next.js page with Lighthouse.

00:20:52.760 --> 00:20:54.740
One other thing that
we're currently exploring

00:20:54.740 --> 00:20:57.740
is a conformance story so that
better errors and warnings

00:20:57.740 --> 00:21:01.070
can be surfaced to the developer
for many common footguns they

00:21:01.070 --> 00:21:01.880
may run into.

00:21:04.768 --> 00:21:06.310
Earlier in this
talk, Shubhie covered

00:21:06.310 --> 00:21:08.110
how there are many
things that developers

00:21:08.110 --> 00:21:10.360
need to be wary of
that could affect

00:21:10.360 --> 00:21:14.110
the performance of their site,
such as blocking scripts,

00:21:14.110 --> 00:21:18.313
web fonts, unoptimized
images, and so forth.

00:21:18.313 --> 00:21:19.730
Now all these
things are just some

00:21:19.730 --> 00:21:21.950
of the many common
problems that developers

00:21:21.950 --> 00:21:24.440
have to deal with when
building web pages.

00:21:27.750 --> 00:21:30.900
At Google, we began adopting
a conformance model for many

00:21:30.900 --> 00:21:33.510
of the internally built
web frameworks that we use

00:21:33.510 --> 00:21:36.990
to build many of our products.

00:21:36.990 --> 00:21:38.810
And the idea behind
this conformist model

00:21:38.810 --> 00:21:40.640
is that it doesn't
just statically analyze

00:21:40.640 --> 00:21:44.060
code but actually tests
for multiple checks

00:21:44.060 --> 00:21:46.880
after code has been compiled.

00:21:46.880 --> 00:21:49.460
By doing so, we're able to
catch a lot of potential issues

00:21:49.460 --> 00:21:51.380
with our final output
that we may not have

00:21:51.380 --> 00:21:54.280
noticed until it's too late.

00:21:54.280 --> 00:21:57.730
This feature has helped teams
build large scalable apps

00:21:57.730 --> 00:22:01.660
while ensuring that code remains
in check as much as possible.

00:22:05.310 --> 00:22:07.950
And we wanted to see
the same sort of concept

00:22:07.950 --> 00:22:13.330
can be applied to an open-source
framework like Next.js.

00:22:13.330 --> 00:22:16.780
For example, what if you
ran a Next.js build and then

00:22:16.780 --> 00:22:19.180
you see an error telling
you that you included

00:22:19.180 --> 00:22:22.060
a render-blocking script,
preventing you from actually

00:22:22.060 --> 00:22:23.520
submitting your changes?

00:22:27.100 --> 00:22:30.060
Now this concept builds on
top of the idea of regular

00:22:30.060 --> 00:22:32.550
build warnings and errors
by providing checks

00:22:32.550 --> 00:22:35.170
that are a lot more precise.

00:22:35.170 --> 00:22:37.470
It needs to be
enforced, but we also

00:22:37.470 --> 00:22:39.780
want developers to
have the flexibility

00:22:39.780 --> 00:22:42.780
to decide what's enforced
within their team,

00:22:42.780 --> 00:22:45.030
and we want to do this
by providing some API

00:22:45.030 --> 00:22:49.670
control for them to enable
and disable certain checks.

00:22:49.670 --> 00:22:52.510
This entire concept is
still very early stages,

00:22:52.510 --> 00:22:54.830
and there's a lot that
we need to think about.

00:22:54.830 --> 00:22:56.720
But we have an open
RFC, and we would

00:22:56.720 --> 00:22:59.030
love to hear any feedback
that you may have.

00:23:01.890 --> 00:23:05.110
SHUBHIE PANICKER: So going
back to our slide from before

00:23:05.110 --> 00:23:07.550
and looking at this
problem of this large chunk

00:23:07.550 --> 00:23:09.643
of JavaScript-blocking
interaction,

00:23:09.643 --> 00:23:11.810
we found that even after
all of these optimizations,

00:23:11.810 --> 00:23:15.380
we are still seeing 200 and
900k compressed JavaScript,

00:23:15.380 --> 00:23:16.970
and this still means
multiple seconds

00:23:16.970 --> 00:23:18.978
on the network and
the main thread.

00:23:18.978 --> 00:23:21.020
So the most obvious thing
that might come to mind

00:23:21.020 --> 00:23:23.150
is ship less JavaScript.

00:23:23.150 --> 00:23:25.712
But this means shipping
fewer features.

00:23:25.712 --> 00:23:27.170
So again, consider
putting yourself

00:23:27.170 --> 00:23:29.000
in the shoes of the
team responsible

00:23:29.000 --> 00:23:30.470
for a business-critical app.

00:23:30.470 --> 00:23:33.500
It's not practical for them
to drop all their JavaScript

00:23:33.500 --> 00:23:35.720
beyond the first
100 or 200 kilobytes

00:23:35.720 --> 00:23:39.680
and just remove all ads, tag
managers, and analytics and so

00:23:39.680 --> 00:23:41.770
forth.

00:23:41.770 --> 00:23:44.290
The point stands though that
features come at a cost,

00:23:44.290 --> 00:23:47.960
and JavaScript is particularly
expensive on the main thread.

00:23:47.960 --> 00:23:50.610
So we need to
fundamentally uncouple

00:23:50.610 --> 00:23:54.790
this trade-off between
features and performance.

00:23:54.790 --> 00:23:57.840
So in Next.js we are already
doing all of these things--

00:23:57.840 --> 00:24:02.650
compression, minification, tree
shaking, dead-code elimination.

00:24:02.650 --> 00:24:05.220
And then Houssein mentioned
the additional optimizations

00:24:05.220 --> 00:24:08.650
we add around polyfills,
optimized chunking.

00:24:08.650 --> 00:24:11.830
So even after tackling a lot
of this low-hanging fruit,

00:24:11.830 --> 00:24:14.830
we are still finding that
JavaScript is too expensive.

00:24:14.830 --> 00:24:17.670
So this is a DevTools
Timeline on a Next.js app,

00:24:17.670 --> 00:24:21.240
and it shows us what's going
on in the initial page load.

00:24:21.240 --> 00:24:24.550
There is this big long task
from setup and hydration,

00:24:24.550 --> 00:24:26.850
and that first user
interaction is still blocked

00:24:26.850 --> 00:24:30.970
until the script has finished.

00:24:30.970 --> 00:24:33.310
So you may have heard of
concurrent mode in React.

00:24:33.310 --> 00:24:36.310
It enables progressive
hydration by breaking up

00:24:36.310 --> 00:24:40.480
that long continuous task that
involves setup and hydration

00:24:40.480 --> 00:24:42.700
into lots of smaller tasks.

00:24:42.700 --> 00:24:44.530
It's not that it's
eliminating hydration.

00:24:44.530 --> 00:24:47.147
It's that it's breaking
it up and staggering it.

00:24:47.147 --> 00:24:49.480
And the idea here is now the
main thread is serviceable.

00:24:49.480 --> 00:24:52.370
It can respond to
user interaction.

00:24:52.370 --> 00:24:54.760
So we did some work to enable
concurrent mode in ZEIT, so

00:24:54.760 --> 00:24:57.340
let's look at the
results from that.

00:24:57.340 --> 00:25:02.190
The blocking time
reduced a lot by 53%.

00:25:02.190 --> 00:25:06.023
But why isn't it 100% better?

00:25:06.023 --> 00:25:07.440
So to understand
that, we're going

00:25:07.440 --> 00:25:10.620
to go back to that
original trace

00:25:10.620 --> 00:25:12.640
and see what's going on here.

00:25:12.640 --> 00:25:15.930
So on the left we are basically
seeing about one third

00:25:15.930 --> 00:25:18.150
or half of the slice.

00:25:18.150 --> 00:25:20.130
On the left is all
this kind of Webpack

00:25:20.130 --> 00:25:22.950
bookkeeping, module
initialization, and setup.

00:25:22.950 --> 00:25:26.040
And on the right, we have React
coming in, doing DOM work,

00:25:26.040 --> 00:25:29.210
and doing hydration.

00:25:29.210 --> 00:25:30.860
The problem is
that both of these

00:25:30.860 --> 00:25:33.590
depend on what happens
to be on that page.

00:25:33.590 --> 00:25:35.540
So it can vary arbitrarily.

00:25:35.540 --> 00:25:37.490
These are two very
different opportunities.

00:25:37.490 --> 00:25:39.110
Turning on concurrent
mode immediately

00:25:39.110 --> 00:25:42.020
fixed the problem on the right,
but we haven't done anything

00:25:42.020 --> 00:25:43.632
about the problem on the left.

00:25:43.632 --> 00:25:45.590
So we are actually just
starting to tackle this

00:25:45.590 --> 00:25:49.535
by looking at deferring model
initialization and setup.

00:25:49.535 --> 00:25:51.050
And the idea here
is that we want

00:25:51.050 --> 00:25:54.910
to get to getting that
startup time to be fixed

00:25:54.910 --> 00:25:59.030
or constant and decoupled
from the specific contents

00:25:59.030 --> 00:26:02.030
or the size of the page.

00:26:02.030 --> 00:26:06.070
So once we tackle that, we'll
achieve our fixed startup,

00:26:06.070 --> 00:26:08.320
but there's still a
missing piece here.

00:26:08.320 --> 00:26:10.060
We still need to be
able to prioritize

00:26:10.060 --> 00:26:11.890
the specific
features on the page

00:26:11.890 --> 00:26:17.500
that the user actively
interacts with or engages with.

00:26:17.500 --> 00:26:20.050
And this is where selective
hydration comes in.

00:26:20.050 --> 00:26:22.980
This was announced at
the recent React Conf.

00:26:22.980 --> 00:26:25.960
And the idea here is
as the user interacts

00:26:25.960 --> 00:26:28.090
with the image carousel
or the left bar

00:26:28.090 --> 00:26:29.950
or any of those
components or the top,

00:26:29.950 --> 00:26:33.370
those specific items
are prioritized

00:26:33.370 --> 00:26:35.155
over everything
else in the page.

00:26:37.667 --> 00:26:40.000
So finally I don't want to
leave you with the impression

00:26:40.000 --> 00:26:41.770
that turning on
concurrent mode was

00:26:41.770 --> 00:26:43.900
as easy as flipping a switch.

00:26:43.900 --> 00:26:46.840
This involved pretty
substantial changes to Next.js

00:26:46.840 --> 00:26:48.790
to update incompatible concepts.

00:26:48.790 --> 00:26:51.680
It required migration
of the target app.

00:26:51.680 --> 00:26:53.860
There's still the problem
of third-party npm apps

00:26:53.860 --> 00:26:55.223
that need to be upgraded.

00:26:55.223 --> 00:26:56.890
And even though this
is a bunch of work,

00:26:56.890 --> 00:27:01.600
we are on course to update the
ZEIT app to concurrent mode.

00:27:01.600 --> 00:27:04.630
And this is the first big
step towards uncoupling

00:27:04.630 --> 00:27:07.540
that fundamental
trade-off between features

00:27:07.540 --> 00:27:09.270
and performance.

00:27:09.270 --> 00:27:12.160
And you're already
seeing a 53% improvement

00:27:12.160 --> 00:27:16.090
in that first interactive
blocking time.

00:27:16.090 --> 00:27:18.480
So there's a lot more
beyond performance

00:27:18.480 --> 00:27:21.540
in terms of having a
compelling web framework that

00:27:21.540 --> 00:27:23.460
makes developers productive.

00:27:23.460 --> 00:27:25.140
And at this point,
I want to welcome

00:27:25.140 --> 00:27:27.120
our guest, Tim Neutkens--

00:27:27.120 --> 00:27:29.640
he's the lead
developer of Next.js--

00:27:29.640 --> 00:27:33.370
to talk about how Next.js
helps developers here.

00:27:33.370 --> 00:27:36.600
[APPLAUSE]

00:27:39.000 --> 00:27:42.050
TIM NEUTKENS: Good
morning, everyone.

00:27:42.050 --> 00:27:45.910
So Next solves two things
in the React ecosystem.

00:27:45.910 --> 00:27:51.140
It helps you with going to
production really fast but also

00:27:51.140 --> 00:27:54.120
with developer experience.

00:27:54.120 --> 00:27:58.900
So let's dive in what Next
actually helps you with.

00:27:58.900 --> 00:28:01.740
So it's easy to get
started with Next,

00:28:01.740 --> 00:28:06.150
but also it's easy to evolve
to larger applications.

00:28:06.150 --> 00:28:10.640
So we want to ensure that your
app or site is becoming bigger

00:28:10.640 --> 00:28:14.480
and more successful over time
and that your team can actually

00:28:14.480 --> 00:28:18.140
get great developer
experience in doing so,

00:28:18.140 --> 00:28:19.400
which leads to the next point.

00:28:19.400 --> 00:28:23.540
It is great for individuals
but also for teams.

00:28:23.540 --> 00:28:26.120
And you can actually do
static site generation

00:28:26.120 --> 00:28:28.560
or dynamic rendering per page.

00:28:28.560 --> 00:28:30.470
So you can choose
what you want to do

00:28:30.470 --> 00:28:33.980
per page as your project grows.

00:28:33.980 --> 00:28:37.100
So in short, Next is great
for really simple websites

00:28:37.100 --> 00:28:42.200
but also for the most demanding
apps like the largest websites

00:28:42.200 --> 00:28:44.880
in the world, for example.

00:28:44.880 --> 00:28:49.130
So let's look at what Next
helps you with currently.

00:28:49.130 --> 00:28:53.798
As Shubhie said before in
this talk, it was basically

00:28:53.798 --> 00:28:55.340
there's a lot of
things that you have

00:28:55.340 --> 00:29:00.650
to think about when you're
developing a website or a web

00:29:00.650 --> 00:29:01.750
app.

00:29:01.750 --> 00:29:05.690
It goes from backend logic
to unit testing, UI component

00:29:05.690 --> 00:29:07.820
models, and everything really.

00:29:07.820 --> 00:29:11.320
So Next helps you with
a subset of these things

00:29:11.320 --> 00:29:16.060
today, which is the backend
logic and server logic.

00:29:16.060 --> 00:29:19.030
So it actually helps
you with data fetching

00:29:19.030 --> 00:29:23.470
but also with writing API
routes if you want to.

00:29:23.470 --> 00:29:25.150
Then there is the
UI component model.

00:29:25.150 --> 00:29:28.290
Next obviously uses
React, as we said.

00:29:28.290 --> 00:29:30.520
And it helps you just
write React components

00:29:30.520 --> 00:29:33.890
and not worry about
all the other things.

00:29:33.890 --> 00:29:35.870
Then there is data
flow, and data flow

00:29:35.870 --> 00:29:41.240
means data fetching
but also, for example,

00:29:41.240 --> 00:29:44.290
how you get data into your app.

00:29:44.290 --> 00:29:46.730
Then there is CSS
encapsulation, which

00:29:46.730 --> 00:29:50.000
means how you write CSS in
a way that you don't have

00:29:50.000 --> 00:29:52.220
to go back and
rewrite everything

00:29:52.220 --> 00:29:55.700
later on as you get
encapsulation per component,

00:29:55.700 --> 00:29:56.600
for example.

00:29:56.600 --> 00:30:00.080
So Next ships with styled-jsx,
which is this library that we

00:30:00.080 --> 00:30:03.260
wrote that we think is
pretty great for writing

00:30:03.260 --> 00:30:07.490
encapsulated CSS,
but also we allow

00:30:07.490 --> 00:30:09.890
you to integrate with
any CSS ingest library

00:30:09.890 --> 00:30:11.390
that you would want to use.

00:30:11.390 --> 00:30:15.230
So that's styled-components
or Emotion, for example.

00:30:15.230 --> 00:30:17.450
Then there is
deployment and releases.

00:30:17.450 --> 00:30:21.680
So Next is a bold command that
outputs a production-ready web

00:30:21.680 --> 00:30:23.660
application for you.

00:30:23.660 --> 00:30:25.670
So you only give it
React components,

00:30:25.670 --> 00:30:29.240
and then we build it for
you in a way that actually

00:30:29.240 --> 00:30:30.980
is going to work in
production, and we

00:30:30.980 --> 00:30:34.460
optimize a lot of different
things in that way.

00:30:34.460 --> 00:30:36.380
And when it comes
to hosting Next.js,

00:30:36.380 --> 00:30:40.370
the company behind Next.js,
ZEIT, the company I work for,

00:30:40.370 --> 00:30:42.620
offers a hosting platform
that is specifically

00:30:42.620 --> 00:30:44.603
tailored to Next.js apps.

00:30:44.603 --> 00:30:46.020
So they optimize
a lot of things--

00:30:46.020 --> 00:30:46.820
[INAUDIBLE],,
obviously, [INAUDIBLE],,

00:30:46.820 --> 00:30:47.933
and that kind of thing.

00:30:47.933 --> 00:30:49.790
Then there is security.

00:30:49.790 --> 00:30:52.500
So security is a really
broad topic, of course,

00:30:52.500 --> 00:30:56.210
but Next specifically helps you
with enabling CSP in your app

00:30:56.210 --> 00:30:59.430
by default, for example.

00:30:59.430 --> 00:31:02.675
It also, through React, helps
you prevent XSS injection

00:31:02.675 --> 00:31:05.950
and other things.

00:31:05.950 --> 00:31:08.060
As you can see,
however, currently there

00:31:08.060 --> 00:31:10.870
are a few things that
Next doesn't cover,

00:31:10.870 --> 00:31:12.620
and those are the
things that you actually

00:31:12.620 --> 00:31:16.460
have to think about yourself
and investigate and figure out

00:31:16.460 --> 00:31:18.950
what you going to do there.

00:31:18.950 --> 00:31:22.560
And generally companies end
up writing their own solutions

00:31:22.560 --> 00:31:25.920
for this or implementing
their own solution.

00:31:25.920 --> 00:31:29.870
However, to give great
developer experience,

00:31:29.870 --> 00:31:33.960
we want to help you in
being better at this.

00:31:33.960 --> 00:31:36.620
So let's look at what is
currently being investigated

00:31:36.620 --> 00:31:40.440
to improve DX for you.

00:31:40.440 --> 00:31:42.960
So these sort of things that
we're currently working on

00:31:42.960 --> 00:31:48.160
to help you with building more
scalable web applications.

00:31:48.160 --> 00:31:49.660
So one of them is translation.

00:31:49.660 --> 00:31:53.760
So we're seeing a growth
in websites that are using

00:31:53.760 --> 00:31:56.220
a non-English--

00:31:56.220 --> 00:31:59.830
that's targeting non-English
speakers, for example.

00:31:59.830 --> 00:32:03.600
So that means that there need
to be good internationalization

00:32:03.600 --> 00:32:05.520
solutions out there
because otherwise it

00:32:05.520 --> 00:32:08.160
gets really hard for
teams to implement this.

00:32:08.160 --> 00:32:12.280
They might actually choose
to not implement it at all.

00:32:12.280 --> 00:32:13.400
Then there's unit testing.

00:32:13.400 --> 00:32:14.970
So unit testing,
integration testing

00:32:14.970 --> 00:32:18.570
is a really broad
topic also, but we're

00:32:18.570 --> 00:32:21.630
aiming to provide
good defaults for you

00:32:21.630 --> 00:32:26.130
to help you not have to
set up all the compilation

00:32:26.130 --> 00:32:30.090
and bundling involvement
that are needed

00:32:30.090 --> 00:32:32.970
to do unit testing and
integration testing for React,

00:32:32.970 --> 00:32:34.190
for example.

00:32:34.190 --> 00:32:36.320
There is image handling.

00:32:36.320 --> 00:32:38.970
So images make up
a large percentage

00:32:38.970 --> 00:32:41.550
of what you show on
a website, right?

00:32:41.550 --> 00:32:44.040
But we don't provide
an opinionated way

00:32:44.040 --> 00:32:45.930
to load images currently.

00:32:45.930 --> 00:32:47.430
So that means that
it's pretty easy

00:32:47.430 --> 00:32:51.570
to include images that
are too large or too small

00:32:51.570 --> 00:32:56.790
or something that is just
not optimized enough.

00:32:56.790 --> 00:32:58.540
So we're working on that also.

00:32:58.540 --> 00:33:00.990
Then there's analytics,
and analytics is something

00:33:00.990 --> 00:33:03.030
that you all probably
use in a website

00:33:03.030 --> 00:33:05.760
at least because you want
to know what your user are

00:33:05.760 --> 00:33:07.690
doing on the page.

00:33:07.690 --> 00:33:09.900
However, to correctly
implement and relay

00:33:09.900 --> 00:33:12.990
analytics in single-page
applications is really hard.

00:33:12.990 --> 00:33:16.110
You need to be very aware
of which route changes are

00:33:16.110 --> 00:33:18.700
happening and that
kind of thing.

00:33:18.700 --> 00:33:22.500
So we're starting to
investigate solutions that

00:33:22.500 --> 00:33:24.490
will help you with this also.

00:33:24.490 --> 00:33:26.220
Then there's error reporting.

00:33:26.220 --> 00:33:29.970
So you probably all have
written bugs before,

00:33:29.970 --> 00:33:36.210
and it's really hard to catch
bugs in production in websites

00:33:36.210 --> 00:33:40.650
because it runs on a browser
that is not your own browser.

00:33:40.650 --> 00:33:44.760
And because of that, you can't
see what users are doing.

00:33:44.760 --> 00:33:47.970
So error reporting is very
important in that way.

00:33:47.970 --> 00:33:50.640
So relaying errors
that happen is going

00:33:50.640 --> 00:33:53.490
to be easier very soon too.

00:33:53.490 --> 00:33:56.130
And all of these
improvements serve the goal

00:33:56.130 --> 00:33:59.760
of making you and your team more
productive with good defaults

00:33:59.760 --> 00:34:01.390
that can scale.

00:34:01.390 --> 00:34:04.860
Another thing that I didn't
mention in this slide but we're

00:34:04.860 --> 00:34:09.090
also working on
accessibility improvements

00:34:09.090 --> 00:34:11.579
that report
accessibility issues that

00:34:11.579 --> 00:34:12.704
help you solve them faster.

00:34:15.791 --> 00:34:17.730
And we're not doing this alone.

00:34:17.730 --> 00:34:20.969
As Shubhie and Houssein
have been explaining,

00:34:20.969 --> 00:34:23.320
the Chrome team is
helping us in this effort.

00:34:23.320 --> 00:34:25.830
So my team at ZEIT,
which is currently

00:34:25.830 --> 00:34:28.980
four people, including me,
is working on Next more so

00:34:28.980 --> 00:34:31.710
from the developer-experience
side of things.

00:34:31.710 --> 00:34:35.489
The Chrome team is doing a lot
of performance improvements.

00:34:35.489 --> 00:34:37.679
And besides that,
we're obviously

00:34:37.679 --> 00:34:39.600
an open-source
project, so you can all

00:34:39.600 --> 00:34:43.110
contribute to improving
the whole vision of Next.

00:34:43.110 --> 00:34:47.400
And there have been
already many contributors,

00:34:47.400 --> 00:34:52.719
over 830, that have been
involved in this project.

00:34:52.719 --> 00:34:55.230
So one of them that I would
like specifically called out

00:34:55.230 --> 00:34:58.410
is Giuseppe who has been
maintaining styled-jsx ever

00:34:58.410 --> 00:35:03.420
since it was released as
an open-source contributor.

00:35:03.420 --> 00:35:07.292
And I'd like to hand it back
to Shubhie now to end the talk.

00:35:07.292 --> 00:35:08.250
SHUBHIE PANICKER: Cool.

00:35:08.250 --> 00:35:11.370
I want to wrap up by saying
that all of this work

00:35:11.370 --> 00:35:13.770
actually helps the web
platform and web APIs

00:35:13.770 --> 00:35:16.170
as well because working
with these frameworks

00:35:16.170 --> 00:35:18.810
on pragmatic solutions for
production apps actually

00:35:18.810 --> 00:35:22.350
tells us what APIs are missing,
what APIs developers are

00:35:22.350 --> 00:35:23.040
struggling with.

00:35:23.040 --> 00:35:26.130
So this becomes a natural
funnel of use cases

00:35:26.130 --> 00:35:28.870
back to the web platform.

00:35:28.870 --> 00:35:30.420
And so this is the
end of our talk,

00:35:30.420 --> 00:35:33.150
and I just want to leave
you with a few messages.

00:35:33.150 --> 00:35:34.830
If you're an app
developer, please

00:35:34.830 --> 00:35:38.610
consider reaching for a
fuller-featured web framework

00:35:38.610 --> 00:35:42.070
instead of only thinking about
the bare-bones UI framework.

00:35:42.070 --> 00:35:44.490
This will enable your
team to focus on features

00:35:44.490 --> 00:35:47.270
and be more productive.

00:35:47.270 --> 00:35:49.990
If you're a UI framework
or a web developer--

00:35:49.990 --> 00:35:52.700
a web-framework developer,
please reach out

00:35:52.700 --> 00:35:55.710
and consider investing some
time in a partnership with us.

00:35:55.710 --> 00:35:59.510
We really want your input
on web platform APIs.

00:35:59.510 --> 00:36:01.840
Collaborations are
two-way efforts,

00:36:01.840 --> 00:36:04.280
and we're really seeking to
deepen our collaborations

00:36:04.280 --> 00:36:07.210
with Vue, Ember,
Svelte, et cetera.

00:36:17.220 --> 00:36:23.020
And anyway, finally if you
are in the tooling or bundling

00:36:23.020 --> 00:36:26.710
space like responsible for
bundler, compiler, linter,

00:36:26.710 --> 00:36:29.230
again, please consider
working with us closely.

00:36:29.230 --> 00:36:30.550
We want your feedback.

00:36:30.550 --> 00:36:32.260
And if it makes sense
for your project,

00:36:32.260 --> 00:36:35.200
please consider applying
for the framework fund.

00:36:35.200 --> 00:36:36.010
Thank you.

00:36:36.010 --> 00:36:36.910
[APPLAUSE]

00:36:36.910 --> 00:36:41.160
[MUSIC PLAYING]

