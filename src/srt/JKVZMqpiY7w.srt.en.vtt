WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.450
[MUSIC PLAYING]

00:00:04.900 --> 00:00:08.340
SAM RICHARD: Thanks for sticking
with us to the end of the day.

00:00:08.340 --> 00:00:10.440
The web is an incredibly
powerful platform,

00:00:10.440 --> 00:00:13.580
and with its reach and the
installability of PWAs,

00:00:13.580 --> 00:00:17.060
it's ideal for cross-device
software delivery.

00:00:17.060 --> 00:00:19.670
But it can't do everything
that native apps can do.

00:00:19.670 --> 00:00:21.470
We want to change that.

00:00:21.470 --> 00:00:23.870
We want the web to do
everything that native apps can,

00:00:23.870 --> 00:00:27.065
and be more secure and
user-friendly while doing it.

00:00:27.065 --> 00:00:29.690
My name is Sam Richard, and I'm
a developer advocate for Chrome

00:00:29.690 --> 00:00:32.630
OS, and I'm here to tell you a
story of software development

00:00:32.630 --> 00:00:36.360
on the web, and the work
Google, Microsoft, Intel,

00:00:36.360 --> 00:00:40.050
and others are doing to build
the future of the platform.

00:00:40.050 --> 00:00:41.660
This is the story
of how we're looking

00:00:41.660 --> 00:00:44.390
to bridge the native app gap.

00:00:44.390 --> 00:00:46.670
The story for me starts
fall of last year,

00:00:46.670 --> 00:00:48.660
setting up my new computer.

00:00:48.660 --> 00:00:50.270
I had previously
used a combination

00:00:50.270 --> 00:00:53.690
of native apps and command-line
tools to optimize images.

00:00:53.690 --> 00:00:56.880
Then I tried Squoosh.app,
a PWA from the Chrome Dev

00:00:56.880 --> 00:00:59.150
rel [? team. ?] It
worked on my Chromebook,

00:00:59.150 --> 00:01:01.580
it worked on my Mac, and
it worked on Windows.

00:01:01.580 --> 00:01:03.020
It's just a website.

00:01:03.020 --> 00:01:04.730
But with a simple
install prompt it

00:01:04.730 --> 00:01:07.610
found its way to
my app launchers,

00:01:07.610 --> 00:01:10.430
and replacing all
of my native tools.

00:01:10.430 --> 00:01:13.280
To me, it became
clear that PWAs should

00:01:13.280 --> 00:01:15.750
be the future of
software delivery.

00:01:15.750 --> 00:01:18.680
They're built using
modern APIs, enhanced

00:01:18.680 --> 00:01:22.520
to deliver native-like
installability, reliability,

00:01:22.520 --> 00:01:26.630
and capabilities, all while
reaching anyone, anywhere,

00:01:26.630 --> 00:01:29.150
on any device.

00:01:29.150 --> 00:01:31.960
There are still
some gaps, though.

00:01:31.960 --> 00:01:34.840
The web is super powerful
in its own right today.

00:01:34.840 --> 00:01:36.790
You can build a hyper
local video chat

00:01:36.790 --> 00:01:40.450
app with WebRTC, geolocation,
and push messaging.

00:01:40.450 --> 00:01:42.070
You can make that
app installable.

00:01:42.070 --> 00:01:44.120
You can add video
effects with Wasm,

00:01:44.120 --> 00:01:46.180
and you can even bring
it into new realities

00:01:46.180 --> 00:01:48.640
with WebGL and WebVR.

00:01:48.640 --> 00:01:51.190
But there's still gaps in
what we can solve with the web

00:01:51.190 --> 00:01:52.540
today.

00:01:52.540 --> 00:01:55.210
In the worst case, this
means that developers are not

00:01:55.210 --> 00:01:57.730
building for the web at all,
or they're relegating it

00:01:57.730 --> 00:02:00.048
to a second-class experience.

00:02:00.048 --> 00:02:01.840
For those that do want
to build for the web

00:02:01.840 --> 00:02:04.420
but need the
capabilities of native,

00:02:04.420 --> 00:02:07.630
they're forced to bundle
web apps in native wrappers.

00:02:07.630 --> 00:02:09.639
This often results in
developers effectively

00:02:09.639 --> 00:02:12.610
shipping their own
custom browsers to users,

00:02:12.610 --> 00:02:14.710
exploding the size
of their web apps

00:02:14.710 --> 00:02:17.710
and forcing them to take on
the security and maintenance

00:02:17.710 --> 00:02:19.990
burden of both
keeping the browser

00:02:19.990 --> 00:02:23.050
and their native
wrapper up to date.

00:02:23.050 --> 00:02:25.810
These native wrappers also
lose the reach of the web,

00:02:25.810 --> 00:02:28.000
forcing them to choose
what devices and operating

00:02:28.000 --> 00:02:30.250
systems to support,
often requiring

00:02:30.250 --> 00:02:32.230
different native
wrappers, all of which

00:02:32.230 --> 00:02:36.650
further expands the security
and maintenance burden.

00:02:36.650 --> 00:02:40.070
Filling these gaps is the key
to fixing this and enabling

00:02:40.070 --> 00:02:42.710
the web to be the software
platform of the future,

00:02:42.710 --> 00:02:45.300
like we believe it to be.

00:02:45.300 --> 00:02:47.220
What does this future look like?

00:02:47.220 --> 00:02:50.450
What do you think is missing
from the web platform today?

00:02:50.450 --> 00:02:53.480
What is the web you want?

00:02:53.480 --> 00:02:55.550
I'm going to tell you
two stories of two

00:02:55.550 --> 00:02:57.830
fictional developers,
Quinn, working

00:02:57.830 --> 00:03:01.610
on Fugujournal, and Sawyer,
working on Fuguedit.

00:03:01.610 --> 00:03:04.837
Both Quinn and Sawyer want to
solve problems for their users

00:03:04.837 --> 00:03:06.920
that have usually been
outside the scope of what's

00:03:06.920 --> 00:03:08.810
possible on the web.

00:03:08.810 --> 00:03:11.750
As you'll see, both will
leverage new capabilities

00:03:11.750 --> 00:03:16.870
that change what's possible
to build their applications.

00:03:16.870 --> 00:03:19.410
We start with Quinn, the lead
developer for a social media

00:03:19.410 --> 00:03:21.480
startup, Fugujournal.

00:03:21.480 --> 00:03:23.795
Social apps on mobile
devices have been hard,

00:03:23.795 --> 00:03:25.920
because they need to be
tightly integrated in order

00:03:25.920 --> 00:03:30.780
to be loved by their users
Quinn thinks to themself.

00:03:30.780 --> 00:03:33.240
Our users want to start a
journal entry from anywhere

00:03:33.240 --> 00:03:34.770
on their device,
and they want to be

00:03:34.770 --> 00:03:38.220
able to share those entries
to other social accounts.

00:03:38.220 --> 00:03:41.840
They also want to collaborate
on entries with their friends,

00:03:41.840 --> 00:03:45.060
so they need to be able to
invite them to do so easily.

00:03:45.060 --> 00:03:47.190
Until recently,
these capabilities

00:03:47.190 --> 00:03:49.530
would seem to rule out
building a web app.

00:03:49.530 --> 00:03:53.460
They just simply didn't exist
Both Web Share and the new Web

00:03:53.460 --> 00:03:56.160
Share Target V2
and Contacts APIs--

00:03:56.160 --> 00:03:58.260
that calculus has
changed, and Quinn

00:03:58.260 --> 00:04:02.490
can build a progressive web
app, instead of a native app.

00:04:02.490 --> 00:04:04.590
Let's see what Quinn
is looking to do.

00:04:04.590 --> 00:04:06.690
After a user navigates
to Fugujournal,

00:04:06.690 --> 00:04:09.420
they should be able to install
it to their home screen.

00:04:09.420 --> 00:04:13.270
Once installed, they should
be able to find media, images,

00:04:13.270 --> 00:04:16.140
video, and audio from
throughout their phone

00:04:16.140 --> 00:04:18.490
and share it to Fugujournal.

00:04:18.490 --> 00:04:21.269
Users should then be able
to share any entry using

00:04:21.269 --> 00:04:25.900
the native share sheet of their
phone to another application.

00:04:25.900 --> 00:04:28.530
Finally, they should be able to
find contacts from their phone

00:04:28.530 --> 00:04:31.560
to invite them to collaborate,
sending off invitations

00:04:31.560 --> 00:04:36.470
once they verify their
contacts' information.

00:04:36.470 --> 00:04:38.340
Diving into how Quinn
can make this work,

00:04:38.340 --> 00:04:41.330
let's start by looking
at Web Share Target V2.

00:04:41.330 --> 00:04:45.110
This allows installed PWAs to
both register as a share target

00:04:45.110 --> 00:04:47.870
and describe what
can be shared to it.

00:04:47.870 --> 00:04:50.030
To add it to
Fugujournal, Quinn needs

00:04:50.030 --> 00:04:53.270
to update the web app manifest
to include a share target.

00:04:53.270 --> 00:04:56.610
You can only have one share
target per web app manifest.

00:04:56.610 --> 00:04:58.130
And there are three parameters--

00:04:58.130 --> 00:05:02.008
action, which is the URL
to open when shared to.

00:05:02.008 --> 00:05:03.800
This should be pre-cached
when your service

00:05:03.800 --> 00:05:06.740
worker is installed, so
that it's always available.

00:05:06.740 --> 00:05:10.670
Method, which determines how
to share items to your PWA.

00:05:10.670 --> 00:05:13.070
If you want to use
POST instead of GET,

00:05:13.070 --> 00:05:16.360
you need an ENC-type parameter
as well for encoding.

00:05:16.360 --> 00:05:18.987
And then params, which is
what is allowed to be shared

00:05:18.987 --> 00:05:20.570
and what those items
should be called.

00:05:24.870 --> 00:05:28.030
Each of the parameters
inside of params is optional.

00:05:28.030 --> 00:05:31.650
You can have title, you can
have text, you can have url,

00:05:31.650 --> 00:05:34.560
and you can even have
an array of files,

00:05:34.560 --> 00:05:37.410
each with their own MIME
type and a different name

00:05:37.410 --> 00:05:39.270
for those MIME types.

00:05:39.270 --> 00:05:41.910
When shared, the data
is sent to the action

00:05:41.910 --> 00:05:48.080
URL as form data that can then
be parsed and used as needed.

00:05:48.080 --> 00:05:50.040
A neat trick you can
do for a share target

00:05:50.040 --> 00:05:52.830
is to register a route
directly in your service worker

00:05:52.830 --> 00:05:54.390
to handle the request.

00:05:54.390 --> 00:05:57.390
This will let you use it
even without a back end.

00:05:57.390 --> 00:05:59.700
Here, we're importing work
boxes, route register,

00:05:59.700 --> 00:06:02.040
and registering our
service or our share target

00:06:02.040 --> 00:06:04.530
as a route, a post
route, calling

00:06:04.530 --> 00:06:08.540
shareTargetHandler function,
which looks like this.

00:06:08.540 --> 00:06:11.250
The shareTargetHandler
is an async function

00:06:11.250 --> 00:06:14.400
that takes in the event
and awaits the form data,

00:06:14.400 --> 00:06:17.310
and peels off the
media files from that.

00:06:17.310 --> 00:06:19.600
You can then do whatever
you'd like with these files.

00:06:19.600 --> 00:06:20.650
You can cache them.

00:06:20.650 --> 00:06:23.070
You can send them somewhere
with a fetch request.

00:06:23.070 --> 00:06:25.740
You can even make use of
the rest of the options,

00:06:25.740 --> 00:06:28.560
maybe serving a page with
some query parameters

00:06:28.560 --> 00:06:31.590
for the other shared items or
storing the data and pointers

00:06:31.590 --> 00:06:33.660
to the media in indexed DB.

00:06:36.600 --> 00:06:39.030
Once the journal entry
is in Fugujournal,

00:06:39.030 --> 00:06:42.210
Quinn's users need to be
able to share it back out.

00:06:42.210 --> 00:06:44.250
To do so, when the
Share button is clicked,

00:06:44.250 --> 00:06:47.490
Quinn checks to see if
navigator.share is available.

00:06:47.490 --> 00:06:50.880
If so, it'll use the
native share sheet.

00:06:50.880 --> 00:06:55.610
If not, we can fall back
to custom sharing options.

00:06:55.610 --> 00:06:57.230
To activate the
native share sheet,

00:06:57.230 --> 00:07:00.140
Quinn calls
navigator.share, a promise,

00:07:00.140 --> 00:07:04.040
and passes it at least one
of the optional parameters--

00:07:04.040 --> 00:07:06.740
title, which is the title
of the item being shared;

00:07:06.740 --> 00:07:09.310
text, which is the
text to be shared;

00:07:09.310 --> 00:07:11.000
the URL that is being shared--

00:07:11.000 --> 00:07:12.980
and note, this doesn't
need to be the URL

00:07:12.980 --> 00:07:14.180
that you're currently on.

00:07:14.180 --> 00:07:16.040
It can be any URL.

00:07:16.040 --> 00:07:19.670
And then an array of files
to be shared out as well.

00:07:22.380 --> 00:07:25.230
With both Web Share and
Web Share Target in place,

00:07:25.230 --> 00:07:27.800
Quinn is ready to test
sharing to Fugujournal.

00:07:27.800 --> 00:07:31.170
They start by finding a file
to create an entry from.

00:07:31.170 --> 00:07:33.750
Opening the file, they
tap on the kabob menu,

00:07:33.750 --> 00:07:36.600
hit Send, find Fugujournal
in the share sheet,

00:07:36.600 --> 00:07:38.520
and then tap it.

00:07:38.520 --> 00:07:40.360
This opens the image
in Fugujournal,

00:07:40.360 --> 00:07:42.005
posted and ready to go.

00:07:42.005 --> 00:07:45.260
They then click the Share button
from an entry, and, hey, look!

00:07:45.260 --> 00:07:47.340
Android's native
share sheet pops up,

00:07:47.340 --> 00:07:51.060
ready to share Twitter's
PWA has also implemented

00:07:51.060 --> 00:07:53.430
Web Share and Web
Share Target V2,

00:07:53.430 --> 00:07:56.190
so Quinn can share their
entry over to Twitter.

00:07:56.190 --> 00:07:59.650
With a tap, Quinn's brought
over to the Twitter PWA,

00:07:59.650 --> 00:08:02.550
and their post is
ready to be tweeted out

00:08:02.550 --> 00:08:07.060
Quinn now turns their attention
to the contact picker.

00:08:07.060 --> 00:08:09.200
Contact picker is
also a promise,

00:08:09.200 --> 00:08:12.760
so we're going to wrap
it in an async function.

00:08:12.760 --> 00:08:14.950
When the function is run,
Quinn checks for support

00:08:14.950 --> 00:08:17.350
by making sure both
navigator.contacts

00:08:17.350 --> 00:08:20.210
and window.ContactsManager
exists.

00:08:20.210 --> 00:08:22.660
If not, the user will get
redirected to a manual contact

00:08:22.660 --> 00:08:24.430
entry form.

00:08:24.430 --> 00:08:28.340
If it does, then the contact
picker will be launched.

00:08:28.340 --> 00:08:31.170
The picker takes two
parameters, props,

00:08:31.170 --> 00:08:34.130
which is an array containing
the properties to be requested,

00:08:34.130 --> 00:08:37.610
and options, which is an object
specifying if multiple contacts

00:08:37.610 --> 00:08:39.590
can be selected.

00:08:39.590 --> 00:08:40.940
The results are an array.

00:08:40.940 --> 00:08:43.730
It's either empty if no
contacts were selected

00:08:43.730 --> 00:08:45.950
or the contact picker
couldn't be launched.

00:08:45.950 --> 00:08:48.903
Otherwise, it's
full of contacts.

00:08:48.903 --> 00:08:51.320
Quinn then takes those results
and passes it to a function

00:08:51.320 --> 00:08:54.650
to populate the invite form.

00:08:54.650 --> 00:08:57.350
Quinn gives the new
contact picker a test run.

00:08:57.350 --> 00:08:59.540
Navigating to the
Invite screen, Quinn

00:08:59.540 --> 00:09:02.480
clicks the Invite Friends button
and is presented with a contact

00:09:02.480 --> 00:09:03.265
picker.

00:09:03.265 --> 00:09:04.640
Now, there's been
lots of thought

00:09:04.640 --> 00:09:07.490
around user security put
into this contact picker.

00:09:07.490 --> 00:09:09.800
Apps aren't granted
permanent access.

00:09:09.800 --> 00:09:11.420
It's on demand.

00:09:11.420 --> 00:09:13.370
Users also aren't
required to provide all

00:09:13.370 --> 00:09:15.020
of the information requested.

00:09:15.020 --> 00:09:17.960
They choose what's
returned from the request.

00:09:17.960 --> 00:09:19.970
Quinn decides to
select a few contacts,

00:09:19.970 --> 00:09:22.800
but only share their
name and email address.

00:09:22.800 --> 00:09:26.840
Once selected, the contacts
now show up in Fugujournal.

00:09:26.840 --> 00:09:28.760
And with that, Quinn
can invite their friends

00:09:28.760 --> 00:09:31.890
to come try their
newly launched site.

00:09:31.890 --> 00:09:33.195
And so can you.

00:09:33.195 --> 00:09:35.040
Go try it yourself.

00:09:35.040 --> 00:09:38.930
On your Android device,
go to fugujournal.web.app,

00:09:38.930 --> 00:09:42.330
add it to your home screen, and
try out everything you've seen,

00:09:42.330 --> 00:09:46.490
inviting friends, adding
content, and sharing it out.

00:09:46.490 --> 00:09:49.450
While the Contacts API
isn't fully launched yet,

00:09:49.450 --> 00:09:51.822
I've enabled an origin
trial on Fugujournal

00:09:51.822 --> 00:09:54.030
so you can see how it works
without a special version

00:09:54.030 --> 00:09:57.630
of Chrome or toggling
any Chrome flags.

00:09:57.630 --> 00:09:59.830
As a demo site, it's not
hooked up to any back end,

00:09:59.830 --> 00:10:01.860
so no information
will be collected,

00:10:01.860 --> 00:10:04.020
and all files shared
are stored locally.

00:10:06.810 --> 00:10:09.060
We now move from
Quinn to Sawyer.

00:10:09.060 --> 00:10:11.340
Sawyer is developing a
new desktop-class web

00:10:11.340 --> 00:10:14.573
editor, Fuguedit, and
heard you like websites,

00:10:14.573 --> 00:10:15.990
so he wants to
build you a website

00:10:15.990 --> 00:10:18.200
to let you build websites.

00:10:18.200 --> 00:10:20.490
Sawyer has similar
concerns that Quinn had.

00:10:20.490 --> 00:10:21.680
Editors are hard to build.

00:10:21.680 --> 00:10:23.070
They really need
to be seamlessly

00:10:23.070 --> 00:10:26.730
integrated into an operating
system to feel useful.

00:10:26.730 --> 00:10:29.250
Sawyer thinks editors
are complicated.

00:10:29.250 --> 00:10:31.830
Our users want to be able
to pick a file or folder

00:10:31.830 --> 00:10:34.560
to work on and just work on it.

00:10:34.560 --> 00:10:36.435
Users get attached to
their favorite editors,

00:10:36.435 --> 00:10:38.185
so they'll want to be
able to quickly open

00:10:38.185 --> 00:10:39.990
files from their home
screen or their file

00:10:39.990 --> 00:10:42.690
system in the editor.

00:10:42.690 --> 00:10:44.940
These requirements,
much like Quinn's, used

00:10:44.940 --> 00:10:46.980
to be impossible with a web app.

00:10:46.980 --> 00:10:49.980
Previously on the web, in
order to edit files or folders,

00:10:49.980 --> 00:10:52.860
first you needed to upload
them, then make your edits,

00:10:52.860 --> 00:10:54.570
then download those files again.

00:10:54.570 --> 00:10:56.340
You couldn't just
change them in place.

00:10:56.340 --> 00:10:58.350
It was pretty cumbersome.

00:10:58.350 --> 00:11:01.080
And opening a file from the
file system into an app--

00:11:01.080 --> 00:11:04.200
simple for native apps,
previously impossible for web

00:11:04.200 --> 00:11:06.030
apps.

00:11:06.030 --> 00:11:09.030
Just like Quinn, Sawyer is
going to turn to new APIs.

00:11:09.030 --> 00:11:12.270
This time it's the Native File
System API and the File Handler

00:11:12.270 --> 00:11:14.660
API.

00:11:14.660 --> 00:11:16.880
Let's see what
Sawyer's looking to do.

00:11:16.880 --> 00:11:19.190
Navigating to Fuguedit
on their laptop,

00:11:19.190 --> 00:11:21.800
a user sees a notification
in the omnibar

00:11:21.800 --> 00:11:23.660
that they can install it.

00:11:23.660 --> 00:11:25.970
Clicking it, they
install Fuguedit,

00:11:25.970 --> 00:11:28.970
and it's now available alongside
all of their other applications

00:11:28.970 --> 00:11:31.130
on their computer.

00:11:31.130 --> 00:11:33.980
Once installed, they find
a file on their computer

00:11:33.980 --> 00:11:38.130
and open it directly
into Fuguedit.

00:11:38.130 --> 00:11:41.300
They can then make changes
that file using Fuguedit,

00:11:41.300 --> 00:11:43.520
save those changes,
and then confirm

00:11:43.520 --> 00:11:48.060
that those changes are real
by looking in the terminal.

00:11:48.060 --> 00:11:50.790
Finally, they can open
a whole folder's worth

00:11:50.790 --> 00:11:54.570
of files in Fuguedit, opening
individual files from the file

00:11:54.570 --> 00:11:56.700
tree as they need
to work on them.

00:12:00.003 --> 00:12:02.420
Sawyer is going to start with
opening a file from the file

00:12:02.420 --> 00:12:03.620
system.

00:12:03.620 --> 00:12:05.640
The native file
picker is a promise,

00:12:05.640 --> 00:12:09.050
so we're going to use async
when the Open button is clicked,

00:12:09.050 --> 00:12:10.580
or an async function.

00:12:10.580 --> 00:12:12.080
The first thing
Sawyer does is check

00:12:12.080 --> 00:12:14.330
to see if
chooseFileSystemEntries

00:12:14.330 --> 00:12:15.870
is available.

00:12:15.870 --> 00:12:20.480
If not, it'll fall back to
other file picker options.

00:12:20.480 --> 00:12:24.680
If available, Sawyer's going to
call chooseFileSystemEntries.

00:12:24.680 --> 00:12:26.922
One option is included
here, accepts,

00:12:26.922 --> 00:12:28.880
which here will narrow
down what kinds of files

00:12:28.880 --> 00:12:31.920
can be selected by MIME type.

00:12:31.920 --> 00:12:34.280
We can also choose to
allow multiple files,

00:12:34.280 --> 00:12:36.560
open directories
instead of files,

00:12:36.560 --> 00:12:38.510
or create new files
instead of opening

00:12:38.510 --> 00:12:40.970
a file that already exists.

00:12:40.970 --> 00:12:42.530
Selecting the file is step one.

00:12:42.530 --> 00:12:45.270
It provides basic
information, the file's name,

00:12:45.270 --> 00:12:48.380
whether it's a directory,
and whether it's a file.

00:12:48.380 --> 00:12:50.330
Calling getFile lets
Sawyer know when

00:12:50.330 --> 00:12:54.480
it was last modified, its
size, and its MIME type.

00:12:54.480 --> 00:12:58.160
Finally, in this case calling
.text is the final step,

00:12:58.160 --> 00:13:01.770
and it will read the stream
of the file as a UTF-8 encoded

00:13:01.770 --> 00:13:04.850
text, kind of like how
fetch's text method does.

00:13:07.410 --> 00:13:10.803
If users open a file, they need
to be able to save it as well.

00:13:10.803 --> 00:13:12.720
Sawyer is going to make
this feel more native,

00:13:12.720 --> 00:13:16.110
so they're going to override
Control or Command-S to save

00:13:16.110 --> 00:13:18.910
the file, instead of
saving the web page.

00:13:18.910 --> 00:13:22.230
This will kick off
writing a file to disk.

00:13:22.230 --> 00:13:25.710
To write a file, Sawyer
first creates a writer

00:13:25.710 --> 00:13:26.850
from the file handler.

00:13:26.850 --> 00:13:29.010
This creates a temporary file.

00:13:29.010 --> 00:13:31.290
And they write the
contents to the temp file,

00:13:31.290 --> 00:13:33.660
starting at the zeroth
character and including

00:13:33.660 --> 00:13:35.620
all of the content.

00:13:35.620 --> 00:13:37.380
Finally, they close
the temp file,

00:13:37.380 --> 00:13:42.100
which updates the
original file on disk.

00:13:42.100 --> 00:13:43.930
Loading up Fuguedit
on a Chromebook,

00:13:43.930 --> 00:13:48.100
Sawyer has got two options,
open a file or open a folder.

00:13:48.100 --> 00:13:50.890
Open a File feels very much
like the file upload form

00:13:50.890 --> 00:13:55.930
that they're already used to,
and once opened, it pops in.

00:13:55.930 --> 00:13:58.810
Opening a folder, however,
is a different story.

00:13:58.810 --> 00:14:01.030
Sawyer selects a folder
from their Linux environment

00:14:01.030 --> 00:14:04.065
on their Chromebook and sees
a notification warning them

00:14:04.065 --> 00:14:06.550
that they're about to
grant access to a site

00:14:06.550 --> 00:14:10.540
to view all files in that
folder until they close the tab.

00:14:10.540 --> 00:14:13.450
This is a double opt-in, because
much like the Contact Picker,

00:14:13.450 --> 00:14:16.820
this API was designed
with security in mind.

00:14:16.820 --> 00:14:19.692
With a folder open,
Fuguedit's adapted

00:14:19.692 --> 00:14:21.400
to include a folder
tree of all the files

00:14:21.400 --> 00:14:23.390
and folders in that directory.

00:14:23.390 --> 00:14:25.360
Sawyer can now move
around the folder tree,

00:14:25.360 --> 00:14:27.850
opening files as they go.

00:14:27.850 --> 00:14:31.300
Sawyer opens the README
file and makes some edits.

00:14:31.300 --> 00:14:35.490
This was edited from a PWA.

00:14:35.490 --> 00:14:38.270
Sawyer then hits Control-S
to save the file.

00:14:38.270 --> 00:14:41.320
They get a notification telling
them that if they agree,

00:14:41.320 --> 00:14:43.980
Fuguedit's going to have
write access to this file

00:14:43.980 --> 00:14:45.810
until the tab's closed.

00:14:45.810 --> 00:14:47.760
Again, an async block
to ensure the user

00:14:47.760 --> 00:14:49.260
doesn't accidentally
give permission

00:14:49.260 --> 00:14:51.520
to this functionality.

00:14:51.520 --> 00:14:53.370
After saving once,
Sawyer checks to see

00:14:53.370 --> 00:14:55.650
that the changes have stuck
by [? catting ?] the file

00:14:55.650 --> 00:14:58.030
in their terminal.

00:14:58.030 --> 00:14:59.640
The file's changed.

00:14:59.640 --> 00:15:00.510
Great.

00:15:00.510 --> 00:15:03.550
Going back to Fuguedit, Sawyer
makes some more changes,

00:15:03.550 --> 00:15:05.820
presses Control-S
again, and then

00:15:05.820 --> 00:15:09.240
checks again to see that
the changes have stuck.

00:15:09.240 --> 00:15:12.030
Now that they're ready to
use Fuguedit to edit Fuguedit

00:15:12.030 --> 00:15:14.520
itself, just one
more thing to do,

00:15:14.520 --> 00:15:16.290
opening files from
the file system.

00:15:19.015 --> 00:15:20.390
Doing so is similar
to what Quinn

00:15:20.390 --> 00:15:21.920
did with Web Share Target.

00:15:21.920 --> 00:15:23.842
Sawyer needs to update
their web app manifest.

00:15:23.842 --> 00:15:25.300
The first thing
they need to do is,

00:15:25.300 --> 00:15:28.420
they need to add a file handler
option to the web app manifest.

00:15:28.420 --> 00:15:31.420
This allows Sawyer to specify
the URL, which should be used

00:15:31.420 --> 00:15:34.740
when opening a given file type.

00:15:34.740 --> 00:15:37.730
Sawyer can specify multiple
file handlers here.

00:15:37.730 --> 00:15:40.330
One URL can accept
multiple file types,

00:15:40.330 --> 00:15:43.780
and for OSes that work with
MIME types, those will be used.

00:15:43.780 --> 00:15:46.870
Otherwise, it'll fall back
to specific extensions.

00:15:46.870 --> 00:15:48.957
This also means you can
use custom extensions

00:15:48.957 --> 00:15:49.540
with your PWA.

00:15:52.585 --> 00:15:53.960
The final thing
that Sawyer needs

00:15:53.960 --> 00:15:57.540
to do to get the file opened
is to actually get it.

00:15:57.540 --> 00:16:00.330
To do that, on load,
they set a consumer

00:16:00.330 --> 00:16:02.700
for the new launch queue.

00:16:02.700 --> 00:16:04.410
The launch parameters
in the consumer

00:16:04.410 --> 00:16:07.500
include an array of files
that are being launched with.

00:16:07.500 --> 00:16:14.380
They pick off the first file and
await opening it in Fuguedit.

00:16:14.380 --> 00:16:16.180
Loading up Fuguedit
on their Chromebook,

00:16:16.180 --> 00:16:19.750
we go to the Files app, find a
file in our Linux environment

00:16:19.750 --> 00:16:23.890
that Fuguedit can work with,
and open it with Fuguedit.

00:16:23.890 --> 00:16:25.180
Ta-da!

00:16:25.180 --> 00:16:26.800
Opened and ready to work with.

00:16:30.160 --> 00:16:32.950
And again, you can
try this out yourself.

00:16:32.950 --> 00:16:36.430
On your computer, go
to fuguedit.web.app,

00:16:36.430 --> 00:16:39.340
install it, and try to
open the files and folders

00:16:39.340 --> 00:16:42.820
and save them as
you normally would.

00:16:42.820 --> 00:16:45.460
The Native File System API
is also not fully launched

00:16:45.460 --> 00:16:47.930
yet, but just like
the Contacts API,

00:16:47.930 --> 00:16:49.930
I've enabled an
origin trial, so you

00:16:49.930 --> 00:16:52.270
can see how it works without
a special version of Chrome

00:16:52.270 --> 00:16:54.790
or toggling any flags.

00:16:54.790 --> 00:16:56.950
File handling isn't
available as an origin trial

00:16:56.950 --> 00:16:59.470
yet, so you need to
open it up in Chrome

00:16:59.470 --> 00:17:03.100
on either a Chromebook, a
Linux, or a Windows computer.

00:17:03.100 --> 00:17:08.650
Go to chrome://flags and
enable the file handling API.

00:17:08.650 --> 00:17:10.720
Support is coming for
Macs, and implementation

00:17:10.720 --> 00:17:14.260
on other operating systems
is still kind of ongoing.

00:17:14.260 --> 00:17:15.819
So you'll likely
run into some bugs

00:17:15.819 --> 00:17:18.859
while we finish our
initial implementation.

00:17:18.859 --> 00:17:21.369
If you want to see the source
code for both of these apps,

00:17:21.369 --> 00:17:24.069
check out the Bridging
the Native App Gap repo

00:17:24.069 --> 00:17:27.369
on github.com/chromeos,
one word.

00:17:29.798 --> 00:17:31.840
While Quinn and Sawyer
may be a glimpse of what's

00:17:31.840 --> 00:17:33.580
possible in the
future, teams are

00:17:33.580 --> 00:17:36.280
starting to use these
new capabilities today.

00:17:36.280 --> 00:17:38.020
But to do so, they
need to be confident

00:17:38.020 --> 00:17:41.586
that they can use
these APIs securely.

00:17:41.586 --> 00:17:44.850
These APIs that we're
exposing are really powerful,

00:17:44.850 --> 00:17:46.100
which can be really scary.

00:17:46.100 --> 00:17:48.110
And a lot of thinking
has gone into ensuring

00:17:48.110 --> 00:17:50.480
that going to a
website continues

00:17:50.480 --> 00:17:53.500
to be a safe proposition.

00:17:53.500 --> 00:17:55.840
They're all being designed
with a user-first permission

00:17:55.840 --> 00:17:59.320
model, where all permissions
are clearly defined and easily

00:17:59.320 --> 00:18:00.820
revocable.

00:18:00.820 --> 00:18:03.790
In fact, security and
privacy is so important

00:18:03.790 --> 00:18:07.390
that if a capability can't be
made private, safe, and secure,

00:18:07.390 --> 00:18:09.295
it won't be exposed.

00:18:09.295 --> 00:18:11.920
They're also being developed as
part of an open standardization

00:18:11.920 --> 00:18:12.617
process.

00:18:12.617 --> 00:18:14.200
Tomorrow morning,
there's a whole talk

00:18:14.200 --> 00:18:17.320
on this, intended to explain
demystifying the blank shipping

00:18:17.320 --> 00:18:21.490
process that you should watch
to learn more about that.

00:18:21.490 --> 00:18:23.290
All the APIs I've
talked about are

00:18:23.290 --> 00:18:25.090
in the stage where
they're publicized,

00:18:25.090 --> 00:18:27.970
and we're actively looking for
feedback to iterate on them.

00:18:27.970 --> 00:18:29.970
Or, we're looking for
public support and for you

00:18:29.970 --> 00:18:32.470
to try it out today using the
origin trial or the latest

00:18:32.470 --> 00:18:34.030
stable Chrome release.

00:18:34.030 --> 00:18:40.880
So with these APIs in the wild,
who's actually using them?

00:18:40.880 --> 00:18:45.350
Goibibo is a leading online
travel booking brand in India.

00:18:45.350 --> 00:18:47.510
While most users
book for themselves,

00:18:47.510 --> 00:18:50.720
15% of their bookings
are for other people.

00:18:50.720 --> 00:18:52.730
They've recently implemented
the Contact Picker

00:18:52.730 --> 00:18:55.220
API to allow users
to choose someone

00:18:55.220 --> 00:18:58.742
they'd like to book travel for,
smoothing out that process.

00:18:58.742 --> 00:19:00.950
They're also looking into
other ways of incorporating

00:19:00.950 --> 00:19:04.100
the Contact Picker API,
including sending referral

00:19:04.100 --> 00:19:08.210
links and codes over SMS
and incorporating goCash+,

00:19:08.210 --> 00:19:11.570
their system for rewarding users
when contacts they have synced

00:19:11.570 --> 00:19:12.230
make a booking.

00:19:15.020 --> 00:19:17.240
Google Earth Studio
is a browser based

00:19:17.240 --> 00:19:20.810
animation tool for Google's
3D and satellite imagery.

00:19:20.810 --> 00:19:23.360
It allows users to program
their camera's flight path

00:19:23.360 --> 00:19:26.850
and then render that animation
as an image sequence.

00:19:26.850 --> 00:19:30.020
It used to rely on the
old Chrome File System API

00:19:30.020 --> 00:19:31.940
to store files during render.

00:19:31.940 --> 00:19:34.820
This required generating a
zip of sometimes gigabytes

00:19:34.820 --> 00:19:37.400
of images that was then
downloaded to the Downloads

00:19:37.400 --> 00:19:38.870
folder.

00:19:38.870 --> 00:19:40.640
This posed significant
limitations

00:19:40.640 --> 00:19:43.970
on the length and size of
animations they could make.

00:19:43.970 --> 00:19:47.310
It also caused confusion and
frustration for their users.

00:19:47.310 --> 00:19:49.220
They couldn't find
the generated files.

00:19:49.220 --> 00:19:51.200
They couldn't save to
an external hard drive,

00:19:51.200 --> 00:19:53.780
and they would get out of
space errors when lots of space

00:19:53.780 --> 00:19:55.730
was available.

00:19:55.730 --> 00:19:58.340
The Native File System
API solved these problems.

00:19:58.340 --> 00:20:01.230
When users start, they choose
the folder to save the file to,

00:20:01.230 --> 00:20:04.610
and accepting the prompt
to allow the site to view

00:20:04.610 --> 00:20:07.230
files in that selected folder.

00:20:07.230 --> 00:20:09.860
Notice how the folder
just has the file

00:20:09.860 --> 00:20:12.315
we started with, nothing else.

00:20:12.315 --> 00:20:13.940
Once the user starts
to render, they're

00:20:13.940 --> 00:20:17.310
prompted to allow Google Earth
Studio to write to that folder.

00:20:17.310 --> 00:20:20.570
When allowed, Earth Studio
creates a working directory

00:20:20.570 --> 00:20:22.610
it will put the rendered
images in, as well

00:20:22.610 --> 00:20:25.323
as make a copy of the
camera's flight path.

00:20:25.323 --> 00:20:26.990
When the images start
to render, they're

00:20:26.990 --> 00:20:30.200
put in a new folder named
Footage that is easy for users

00:20:30.200 --> 00:20:33.530
to find and keep track of.

00:20:33.530 --> 00:20:36.080
By directly choosing the
output folder to render to,

00:20:36.080 --> 00:20:39.200
there's no zipping, no confusion
as to where the files are,

00:20:39.200 --> 00:20:42.470
and all of the user's
disk space is utilized.

00:20:42.470 --> 00:20:45.110
In short, it's a dream come
true for the Earth Studio

00:20:45.110 --> 00:20:46.430
team and their users.

00:20:49.170 --> 00:20:51.230
Finally, I want to
talk about avrgirl.

00:20:51.230 --> 00:20:53.630
Avrgirl is an
open-source project

00:20:53.630 --> 00:20:55.280
that talks to the
Arduino bootloader

00:20:55.280 --> 00:20:57.980
and writes a program from
the computer's hard drive

00:20:57.980 --> 00:20:59.750
to its memory.

00:20:59.750 --> 00:21:04.370
It's written by Suz
Hinton, aka noopkat,

00:21:04.370 --> 00:21:07.330
an open-source
embedded developer

00:21:07.330 --> 00:21:08.705
Suz does a lot of
code streaming,

00:21:08.705 --> 00:21:10.622
and at the end of
September, showed

00:21:10.622 --> 00:21:12.080
off something super
cool that she'd

00:21:12.080 --> 00:21:14.660
be working on for avrgirl.

00:21:14.660 --> 00:21:17.070
By leveraging another one
of these new capabilities,

00:21:17.070 --> 00:21:20.360
we've been working on,
the Web Serial API, Suz

00:21:20.360 --> 00:21:23.630
was able to program her
Arduino Uno to blink straight

00:21:23.630 --> 00:21:25.070
from her browser.

00:21:25.070 --> 00:21:26.715
Let's watch.

00:21:26.715 --> 00:21:27.382
[VIDEO PLAYBACK]

00:21:27.382 --> 00:21:29.730
- So this is the Upload-o-matic.

00:21:29.730 --> 00:21:31.728
What it does is, it
takes pre-compiled code

00:21:31.728 --> 00:21:33.270
for an Arduino
[INAUDIBLE],, and it's

00:21:33.270 --> 00:21:37.000
able to use Web Serial
in order to upload that.

00:21:37.000 --> 00:21:38.910
So I have some
pre-compiled code that I'm

00:21:38.910 --> 00:21:40.360
going to try this out with.

00:21:40.360 --> 00:21:43.980
I have an Arduino just
above me that you can watch.

00:21:43.980 --> 00:21:46.530
So I'm going to pick
my Arduino Uno board.

00:21:46.530 --> 00:21:48.087
I have some files here.

00:21:48.087 --> 00:21:49.920
Let's go with blink,
so that we can actually

00:21:49.920 --> 00:21:52.590
see that the code did
upload, and then we

00:21:52.590 --> 00:21:55.690
should see a light
blinking when that's done.

00:21:55.690 --> 00:21:58.710
I'm going to click Upload, which
allows me to give permission

00:21:58.710 --> 00:22:02.077
to access my serial device,
which is my Arduino here.

00:22:02.077 --> 00:22:03.660
And as soon as I
click Connect, that's

00:22:03.660 --> 00:22:05.142
going to start uploading.

00:22:08.380 --> 00:22:09.340
And then you have it.

00:22:09.340 --> 00:22:11.290
The light is now blinking.

00:22:11.290 --> 00:22:13.720
And as that was
being written, it

00:22:13.720 --> 00:22:15.760
was dumping out all
of the pages of memory

00:22:15.760 --> 00:22:17.560
that it was actually
writing to that device

00:22:17.560 --> 00:22:19.023
as well, which is pretty cool.

00:22:19.023 --> 00:22:19.606
[END PLAYBACK]

00:22:19.606 --> 00:22:20.520
SAM RICHARD: I agree.

00:22:20.520 --> 00:22:22.046
It is pretty cool.

00:22:22.046 --> 00:22:23.420
[LAUGHTER]

00:22:23.420 --> 00:22:27.430
So what's new, and what's next?

00:22:27.430 --> 00:22:32.323
What Twitter, Google
Earth, Goibibo and avrgirl

00:22:32.323 --> 00:22:34.240
have been able to do
with his new capabilities

00:22:34.240 --> 00:22:36.320
already is pretty impressive.

00:22:36.320 --> 00:22:37.910
But now it's your turn.

00:22:37.910 --> 00:22:41.590
What new capabilities can you
add to your web apps today?

00:22:41.590 --> 00:22:44.470
What can you experiment
with, what is in development,

00:22:44.470 --> 00:22:47.320
and what does the future hold.

00:22:47.320 --> 00:22:50.530
So things that have already
shipped as of Chrome 79--

00:22:50.530 --> 00:22:54.820
we've got Web Share, Web Share
Target V2, the Shape Detection

00:22:54.820 --> 00:22:59.040
API, which is for barcodes,
face, and text detection.

00:22:59.040 --> 00:23:00.910
And we've got
getInstalledRelatedApps

00:23:00.910 --> 00:23:02.410
for web apps that
have established

00:23:02.410 --> 00:23:04.327
a connection to a native
app through something

00:23:04.327 --> 00:23:05.518
like a digital asset link.

00:23:05.518 --> 00:23:07.810
They'll be able to query if
that related app is already

00:23:07.810 --> 00:23:08.771
installed.

00:23:14.550 --> 00:23:16.870
There are also a bunch
of stuff in origin trial.

00:23:16.870 --> 00:23:18.820
So things we've
talked about already--

00:23:18.820 --> 00:23:22.480
Native File System, Contact
Picker, File Handlers,

00:23:22.480 --> 00:23:24.700
and Web Serial.

00:23:24.700 --> 00:23:27.850
We're also going to have
a Badging API for app icon

00:23:27.850 --> 00:23:31.390
badges, as well as Wake Lock,
to prevent the screen from going

00:23:31.390 --> 00:23:35.230
to sleep, an SMS Receiver, to
enable SMS one-time password

00:23:35.230 --> 00:23:36.490
flows.

00:23:36.490 --> 00:23:39.160
Periodic Background Sync,
to run a service worker

00:23:39.160 --> 00:23:42.100
at designated intervals
while online, for instance,

00:23:42.100 --> 00:23:45.750
to update the status or
content in the background; Web

00:23:45.750 --> 00:23:48.700
HID, or Human Interface
Devices, great for getting

00:23:48.700 --> 00:23:51.460
the most functionality possible
out of things like gaming

00:23:51.460 --> 00:23:54.460
controllers; Notification
Triggers, which

00:23:54.460 --> 00:23:57.970
are notifications based on
events like timers or location,

00:23:57.970 --> 00:24:01.300
instead of push events; and then
Back Pressure for Web Sockets,

00:24:01.300 --> 00:24:03.562
to improve handling for
large amounts of data

00:24:03.562 --> 00:24:04.270
over web sockets.

00:24:07.080 --> 00:24:08.790
What are things that
are in development?

00:24:08.790 --> 00:24:13.030
Well, Font Enumeration, to get
a list of local system fonts;

00:24:13.030 --> 00:24:16.650
Font Table Access, to allow
TrueType and OpenType table

00:24:16.650 --> 00:24:21.000
access for fonts, to allow
custom font rendering; Raw

00:24:21.000 --> 00:24:23.400
Clipboard Access, to
extend async clipboard

00:24:23.400 --> 00:24:25.328
to allow unrestricted access.

00:24:25.328 --> 00:24:27.120
And two that I'm really
looking forward to,

00:24:27.120 --> 00:24:30.750
Screen Enumeration
and Window Placement.

00:24:30.750 --> 00:24:32.610
Screen enumeration
makes applications

00:24:32.610 --> 00:24:34.167
perform well across
multiple displays

00:24:34.167 --> 00:24:36.000
with different properties,
like presentation

00:24:36.000 --> 00:24:39.630
apps or financial dashboards,
and then Windows Placement

00:24:39.630 --> 00:24:41.970
allows you to create,
manipulate, and enumerate

00:24:41.970 --> 00:24:44.220
windows for an
application, including

00:24:44.220 --> 00:24:46.260
moving windows as a
group and moving windows

00:24:46.260 --> 00:24:47.195
to specific screens.

00:24:50.070 --> 00:24:53.510
Finally, what's
coming in the future?

00:24:53.510 --> 00:24:55.990
So we're looking into things
like Service Worker Launch

00:24:55.990 --> 00:24:58.765
Events, which control where
links open, if they open in

00:24:58.765 --> 00:25:04.570
a PWA, a tab, or a window; a
low-level audio API; User Idle

00:25:04.570 --> 00:25:08.260
Detection; a Tab
Application mode for PWAs;

00:25:08.260 --> 00:25:10.870
Native Sockets; Scheduled
Tasks; and being

00:25:10.870 --> 00:25:12.435
able to control
connected cameras.

00:25:16.132 --> 00:25:18.340
If you want to keep up to
date with all the work that

00:25:18.340 --> 00:25:23.650
we're doing, go to
goo.gle/fugu-api-tracker.

00:25:23.650 --> 00:25:26.710
And it's a really fun
URL to say out loud.

00:25:26.710 --> 00:25:29.185
The status of each
of the APIs that

00:25:29.185 --> 00:25:30.650
are being worked
on or considered

00:25:30.650 --> 00:25:33.520
is there; where the
API is targeted for,

00:25:33.520 --> 00:25:37.120
mobile, desktop, or both; and
links to the implementation

00:25:37.120 --> 00:25:41.590
tickets for each capability.

00:25:41.590 --> 00:25:44.630
We also need you to try these
APIs out and give us feedback.

00:25:44.630 --> 00:25:46.970
If you want to explore
more, come find us over

00:25:46.970 --> 00:25:48.830
in the sandbox
area, or we've got

00:25:48.830 --> 00:25:51.750
a booth dedicated to
these new capabilities,

00:25:51.750 --> 00:25:54.350
including code labs for
you to try out yourselves.

00:25:54.350 --> 00:25:57.307
I will be also be over
at the Chrome OS booth.

00:25:57.307 --> 00:25:59.015
You should also sign
up for origin trials

00:25:59.015 --> 00:26:02.180
so you can try these out
with your real users.

00:26:02.180 --> 00:26:03.650
Origin trials give
you the ability

00:26:03.650 --> 00:26:07.105
to try out experimental APIs
with real users of your site,

00:26:07.105 --> 00:26:09.230
without needing them to
change their Chrome version

00:26:09.230 --> 00:26:13.430
or toggle any flags for
a limited period of time.

00:26:13.430 --> 00:26:14.930
Features in origin
trial have what's

00:26:14.930 --> 00:26:17.785
called one week of
guaranteed breakage.

00:26:17.785 --> 00:26:19.160
This means that
you're guaranteed

00:26:19.160 --> 00:26:22.040
to have a feature
not work for a week

00:26:22.040 --> 00:26:24.110
before the feature
becomes stable,

00:26:24.110 --> 00:26:28.550
as origin trials aren't meant
to be early-launch mechanisms.

00:26:28.550 --> 00:26:30.710
Finally, origin
trials you can also

00:26:30.710 --> 00:26:33.740
give us direct feedback
on their implementation

00:26:33.740 --> 00:26:37.810
and your usage of
these features.

00:26:37.810 --> 00:26:40.300
Setting up an origin trial
can be done in four steps.

00:26:40.300 --> 00:26:43.330
Step one, choose
your origin trial.

00:26:43.330 --> 00:26:48.550
Step two, register your
domain for that origin trial.

00:26:48.550 --> 00:26:52.060
Step three, get the token
for your origin trial.

00:26:52.060 --> 00:26:56.200
And step four, add a metatag for
your origin trial with that key

00:26:56.200 --> 00:26:57.587
that you've gotten.

00:26:57.587 --> 00:26:59.170
With that, you can
try out the feature

00:26:59.170 --> 00:27:01.835
you'd like with your real users
and provide us with feedback.

00:27:05.330 --> 00:27:07.840
Finally, what's missing?

00:27:07.840 --> 00:27:10.510
All of these APIs, we're
developing because we're

00:27:10.510 --> 00:27:12.400
being asked for them.

00:27:12.400 --> 00:27:14.860
Participating in origin
trials and giving feedback

00:27:14.860 --> 00:27:16.930
there is great way
to help us shape APIs

00:27:16.930 --> 00:27:18.820
that we've started
working on, but we

00:27:18.820 --> 00:27:22.930
want to know what you need
before we get to that stage.

00:27:22.930 --> 00:27:25.390
Let us know what you need.

00:27:25.390 --> 00:27:28.540
Go to webwewant.fyi
to let us know

00:27:28.540 --> 00:27:31.030
what you'd like to see
added to the web platform

00:27:31.030 --> 00:27:34.540
to help you bridge
the native app gap.

00:27:34.540 --> 00:27:35.380
Thank you.

00:27:35.380 --> 00:27:37.180
[APPLAUSE]

00:27:38.680 --> 00:27:41.430
[MUSIC PLAYING]

