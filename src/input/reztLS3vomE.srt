1
00:00:00,000 --> 00:00:01,434
[MUSIC PLAYING]

2
00:00:01,434 --> 00:00:06,482


3
00:00:06,482 --> 00:00:08,065
KATIE HEMPERIUS:
Today, Houssein and I

4
00:00:08,065 --> 00:00:09,564
are going to talk
with you about how

5
00:00:09,564 --> 00:00:11,060
you can make your site fast.

6
00:00:11,060 --> 00:00:15,200
We're going to focus on
three things, images,

7
00:00:15,200 --> 00:00:18,550
web fonts, and JavaScript.

8
00:00:18,550 --> 00:00:20,560
We've chosen to focus
on these three things

9
00:00:20,560 --> 00:00:22,150
because they are
the three largest

10
00:00:22,150 --> 00:00:25,540
components of most websites.

11
00:00:25,540 --> 00:00:28,900
In addition, they're likely to
be the three largest components

12
00:00:28,900 --> 00:00:30,090
of your performance budget.

13
00:00:30,090 --> 00:00:32,980


14
00:00:32,980 --> 00:00:34,700
We hope that after
this presentation,

15
00:00:34,700 --> 00:00:37,310
you'll go home and make
changes to your website.

16
00:00:37,310 --> 00:00:38,860
Know that during
this process, you

17
00:00:38,860 --> 00:00:41,260
can lean on both
Lighthouse and web.dev

18
00:00:41,260 --> 00:00:43,090
for additional resources.

19
00:00:43,090 --> 00:00:46,360
Almost everything we cover today
can be audited by Lighthouse.

20
00:00:46,360 --> 00:00:50,650
In addition, at web.dev can find
guides, code samples, and demos

21
00:00:50,650 --> 00:00:53,850
of everything we cover today.

22
00:00:53,850 --> 00:00:56,800
So let's start by
talking about images.

23
00:00:56,800 --> 00:00:59,070
Images are taking over the web.

24
00:00:59,070 --> 00:01:01,750
On many sites, images
alone would consume

25
00:01:01,750 --> 00:01:04,720
the entire performance budget.

26
00:01:04,720 --> 00:01:08,200
On some sites, it
would far exceed that.

27
00:01:08,200 --> 00:01:10,450
I think the reason why
these numbers are so bad

28
00:01:10,450 --> 00:01:12,670
lies in the fact that
performant images are

29
00:01:12,670 --> 00:01:15,610
the result of many
steps and optimizations.

30
00:01:15,610 --> 00:01:20,150
As a result, they're not
going to happen accidentally.

31
00:01:20,150 --> 00:01:23,810
A performant image is
the appropriate format,

32
00:01:23,810 --> 00:01:29,200
is appropriately compressed,
is appropriate for the display,

33
00:01:29,200 --> 00:01:32,650
and is loaded only
when necessary.

34
00:01:32,650 --> 00:01:34,450
To be successful
with images, it's

35
00:01:34,450 --> 00:01:38,270
imperative that you automate
and systematize these things.

36
00:01:38,270 --> 00:01:40,030
Not only is this going
to save you time,

37
00:01:40,030 --> 00:01:44,310
but it's going to ensure that
these things actually get done.

38
00:01:44,310 --> 00:01:47,240
There's much more to
images than meets the eye.

39
00:01:47,240 --> 00:01:49,010
At a bits and bytes
level, an image

40
00:01:49,010 --> 00:01:51,320
is as much a byproduct
of its image format

41
00:01:51,320 --> 00:01:55,250
and its compression as
its visual subject matter.

42
00:01:55,250 --> 00:01:56,840
You can think
about image formats

43
00:01:56,840 --> 00:01:59,439
as choosing the right
tool for the job.

44
00:01:59,439 --> 00:02:00,980
The image format
that you choose will

45
00:02:00,980 --> 00:02:03,540
determine what features and
image has, for instance,

46
00:02:03,540 --> 00:02:06,290
whether it supports
transparency or animation,

47
00:02:06,290 --> 00:02:09,770
as well as how it
can be compressed.

48
00:02:09,770 --> 00:02:12,290
The first image format that
I want to talk about today

49
00:02:12,290 --> 00:02:14,210
is the animated GIF.

50
00:02:14,210 --> 00:02:17,200
You should not be fooled by
their crappy image quality.

51
00:02:17,200 --> 00:02:20,700
They're actually
huge in file size.

52
00:02:20,700 --> 00:02:25,970
This 1 and 1/2 second
clip is 6.8 mgs as a GIF.

53
00:02:25,970 --> 00:02:32,660
As a video, however, is 16
times smaller, at 420 megabytes.

54
00:02:32,660 --> 00:02:34,220
This is not uncommon.

55
00:02:34,220 --> 00:02:37,280
Animated GIFs can be anywhere
from five to 20 times

56
00:02:37,280 --> 00:02:42,280
larger than the same
content served as a video.

57
00:02:42,280 --> 00:02:44,610
This is why if you've ever
inspected your Twitter feed,

58
00:02:44,610 --> 00:02:46,590
you may have noticed
that the content labeled

59
00:02:46,590 --> 00:02:49,200
as GIF is not actually a GIF.

60
00:02:49,200 --> 00:02:51,120
Twitter does not
serve animated GIFs.

61
00:02:51,120 --> 00:02:53,370
If you upload an animated
GIF, they will automatically

62
00:02:53,370 --> 00:02:55,930
convert it to video.

63
00:02:55,930 --> 00:02:57,490
The reason for the
drastic difference

64
00:02:57,490 --> 00:03:00,220
in file sizes between
videos and animated GIFs

65
00:03:00,220 --> 00:03:03,100
lies in the differences between
their compression algorithms.

66
00:03:03,100 --> 00:03:06,040
Video compression algorithms
are far more sophisticated.

67
00:03:06,040 --> 00:03:08,350
Not only do they compress
the contents of each frame,

68
00:03:08,350 --> 00:03:10,644
what they do what is known
as inner frame compression.

69
00:03:10,644 --> 00:03:12,310
And you can think of
this as compression

70
00:03:12,310 --> 00:03:14,476
that looks at the difs
between the different frames.

71
00:03:14,476 --> 00:03:17,010


72
00:03:17,010 --> 00:03:19,890
The first step in switching
from animated GIFs to video

73
00:03:19,890 --> 00:03:21,510
is to convert your content.

74
00:03:21,510 --> 00:03:25,980
You can use the ffmpeg
command line tool for this.

75
00:03:25,980 --> 00:03:27,870
Next, you'll need
to update your HTML,

76
00:03:27,870 --> 00:03:30,300
and replace image
tags with video tags.

77
00:03:30,300 --> 00:03:33,160
The code I have up on the
screen is technically correct,

78
00:03:33,160 --> 00:03:35,727
but it's probably not
what you want to use.

79
00:03:35,727 --> 00:03:38,310
Instead, you want to make sure
to add the four attributes I've

80
00:03:38,310 --> 00:03:40,110
highlighted up on the screen.

81
00:03:40,110 --> 00:03:42,450
That's going to give
your video that GIF look

82
00:03:42,450 --> 00:03:44,175
and feel even though
it's not a GIF.

83
00:03:44,175 --> 00:03:48,830


84
00:03:48,830 --> 00:03:51,620
Now, we'll switch gears and talk
about a much more modern image

85
00:03:51,620 --> 00:03:55,060
format, and that,
of course, is WebP.

86
00:03:55,060 --> 00:03:58,970
WebP is no longer a
Chrome only technology.

87
00:03:58,970 --> 00:04:03,230
Last month, Microsoft Edge
shipped support for WebP.

88
00:04:03,230 --> 00:04:06,230
In addition, Mozilla Firefox
announced their intent

89
00:04:06,230 --> 00:04:08,600
to ship WebP.

90
00:04:08,600 --> 00:04:15,410
Currently, 72% of global web
users have support for WebP.

91
00:04:15,410 --> 00:04:16,910
And given these
recent developments,

92
00:04:16,910 --> 00:04:18,785
you can expect this
number to only increase.

93
00:04:18,785 --> 00:04:23,470


94
00:04:23,470 --> 00:04:25,490
This is a big deal
because WebP images

95
00:04:25,490 --> 00:04:30,570
are 25% to 35% smaller than
the equivalent JPEG or PNG.

96
00:04:30,570 --> 00:04:33,590
And this translates into some
really awesome improvements

97
00:04:33,590 --> 00:04:35,030
in page speed.

98
00:04:35,030 --> 00:04:36,860
When the Trib united
support for WebP,

99
00:04:36,860 --> 00:04:40,520
they found there was a 30%
improvement in page load times

100
00:04:40,520 --> 00:04:41,795
on WebP supported browsers.

101
00:04:41,795 --> 00:04:45,320


102
00:04:45,320 --> 00:04:48,350
By far the biggest hesitation
I see around adopting WebP

103
00:04:48,350 --> 00:04:51,200
is a fear that you can't
both serve WebP and support

104
00:04:51,200 --> 00:04:52,370
non-WebP browsers.

105
00:04:52,370 --> 00:04:54,170
And this is not true.

106
00:04:54,170 --> 00:04:56,130
The picture and the
source tags make it

107
00:04:56,130 --> 00:04:58,400
possible to do precisely this.

108
00:04:58,400 --> 00:05:01,430
You can think of the picture tag
as a container for the source

109
00:05:01,430 --> 00:05:04,010
and image tags that it contains.

110
00:05:04,010 --> 00:05:07,340
The source tag is used
to specify multiple image

111
00:05:07,340 --> 00:05:09,140
formats of the same image.

112
00:05:09,140 --> 00:05:12,200
The browser will download the
first, and only the first,

113
00:05:12,200 --> 00:05:14,660
image that is in a
format that it supports.

114
00:05:14,660 --> 00:05:16,520
So in this example I
have up on the screen,

115
00:05:16,520 --> 00:05:19,220
the Chrome browser would
download the WebP version,

116
00:05:19,220 --> 00:05:22,970
a Safari browser would
download the JPEG version.

117
00:05:22,970 --> 00:05:24,920
The great thing about
this is that even

118
00:05:24,920 --> 00:05:28,670
though all major browsers have
supported picture and source

119
00:05:28,670 --> 00:05:32,560
tag since 2015, however,
if say, a 2014 browser were

120
00:05:32,560 --> 00:05:34,310
to encounter this,
it would still work,

121
00:05:34,310 --> 00:05:35,684
because those
browsers would just

122
00:05:35,684 --> 00:05:37,730
download the image
specified by the image tag.

123
00:05:37,730 --> 00:05:39,815


124
00:05:39,815 --> 00:05:41,190
If you haven't
noticed, I've been

125
00:05:41,190 --> 00:05:42,379
talking about image formats.

126
00:05:42,379 --> 00:05:43,920
But I want to kind
of go on a tangent

127
00:05:43,920 --> 00:05:47,007
and squeeze in a mention
of the AV1 video format.

128
00:05:47,007 --> 00:05:48,840
And the reason why I
wanted to squeeze it in

129
00:05:48,840 --> 00:05:53,010
is that it is the future
of video on the web.

130
00:05:53,010 --> 00:05:55,290
The reason why it's the
future of video on the web

131
00:05:55,290 --> 00:05:59,760
is that it compresses video
45% to 50% better than what

132
00:05:59,760 --> 00:06:02,640
is currently typically
used on the web.

133
00:06:02,640 --> 00:06:05,670
It is still fairly new, so
it's not really practical

134
00:06:05,670 --> 00:06:07,840
for you to be implementing
it on your site yet.

135
00:06:07,840 --> 00:06:10,170
However, I encourage you to
attend Francois and Angie's

136
00:06:10,170 --> 00:06:11,730
talk at 3:30 today,
where they're

137
00:06:11,730 --> 00:06:13,635
going to be diving into
AV1 in more detail.

138
00:06:13,635 --> 00:06:16,610


139
00:06:16,610 --> 00:06:18,170
Image compression
is a topic that's

140
00:06:18,170 --> 00:06:20,420
tightly coupled
to image formats.

141
00:06:20,420 --> 00:06:23,460
Image compression algorithms
are specific to the image format

142
00:06:23,460 --> 00:06:25,960
that they compress.

143
00:06:25,960 --> 00:06:27,850
However, all image
compression algorithms

144
00:06:27,850 --> 00:06:31,570
can be broken down into
lossless and lossy compression.

145
00:06:31,570 --> 00:06:34,495
Lossless compression
results no loss of data.

146
00:06:34,495 --> 00:06:37,160
Lossy compression does
result in loss of data,

147
00:06:37,160 --> 00:06:40,690
however can achieve
greater file size savings.

148
00:06:40,690 --> 00:06:43,840
At a minimum, all sites should
be using lossless compression,

149
00:06:43,840 --> 00:06:45,200
no questions asked.

150
00:06:45,200 --> 00:06:46,837
However, for most
people, it's going

151
00:06:46,837 --> 00:06:48,670
to make sense to be
slightly more aggressive

152
00:06:48,670 --> 00:06:52,110
and use lossy
compression instead.

153
00:06:52,110 --> 00:06:53,610
The trick with
lossy compression is

154
00:06:53,610 --> 00:06:56,310
finding that sweet spot
between file size savings

155
00:06:56,310 --> 00:07:00,180
and image quality for
your particular use case.

156
00:07:00,180 --> 00:07:03,810
Many lossy compression tools
use the scale of zero to 100

157
00:07:03,810 --> 00:07:06,750
to represent the image quality
of the compressed image,

158
00:07:06,750 --> 00:07:10,047
with zero being the worst,
and 100 being the best.

159
00:07:10,047 --> 00:07:12,630
If you're looking for a place
to start with lossy compression,

160
00:07:12,630 --> 00:07:16,710
we recommend trying out a
quality level of 80 to 85.

161
00:07:16,710 --> 00:07:20,190
This typically reduces
file size by 30% to 40%,

162
00:07:20,190 --> 00:07:22,205
while having a minimal
effect on image quality.

163
00:07:22,205 --> 00:07:25,290


164
00:07:25,290 --> 00:07:27,750
By far, the most popular
tool for image compression

165
00:07:27,750 --> 00:07:32,460
is Imagemin, and it can be used
with just about everything.

166
00:07:32,460 --> 00:07:35,724
Imagemin is used in conjunction
with various Imagemin plugins.

167
00:07:35,724 --> 00:07:37,140
And you can think
of these plugins

168
00:07:37,140 --> 00:07:40,590
as implementations of different
image compression algorithms.

169
00:07:40,590 --> 00:07:43,560
Up on the screen, I've put the
most popular Imagemin plugins

170
00:07:43,560 --> 00:07:45,120
for various use cases.

171
00:07:45,120 --> 00:07:47,520
However, these are by no means
the only Imagemin plugins

172
00:07:47,520 --> 00:07:50,890
available.

173
00:07:50,890 --> 00:07:53,080
Image sizing is something
I think many sites could

174
00:07:53,080 --> 00:07:55,030
be doing a much better job at.

175
00:07:55,030 --> 00:07:57,130
We have so many
types of devices,

176
00:07:57,130 --> 00:07:59,320
and specifically sizes
of devices that access

177
00:07:59,320 --> 00:08:00,570
the web these days.

178
00:08:00,570 --> 00:08:03,235
However, we insist on serving
them all the exact same size

179
00:08:03,235 --> 00:08:04,999
of image.

180
00:08:04,999 --> 00:08:06,790
Not only does this have
transmission costs,

181
00:08:06,790 --> 00:08:11,492
but it also creates
additional work for the CPU.

182
00:08:11,492 --> 00:08:13,160
A solution, of
course, is to serve

183
00:08:13,160 --> 00:08:15,030
multiple sizes of an image.

184
00:08:15,030 --> 00:08:16,790
Most sites find success
serving anywhere

185
00:08:16,790 --> 00:08:19,190
from three to five
sizes of an image.

186
00:08:19,190 --> 00:08:23,820
And in fact, this is
exactly what Instagram does.

187
00:08:23,820 --> 00:08:26,260
Instagram uses this technique
throughout their site.

188
00:08:26,260 --> 00:08:29,190
However, one use case where they
were able to measure its impact

189
00:08:29,190 --> 00:08:31,110
was with their Instagram embeds.

190
00:08:31,110 --> 00:08:34,110
For context, Instagram embeds
allow third-party sites

191
00:08:34,110 --> 00:08:37,169
to display Instagram
content on their own site.

192
00:08:37,169 --> 00:08:39,360
As a result of serving
multiple image sizes,

193
00:08:39,360 --> 00:08:41,520
Instagram was able to
reduce image transfer

194
00:08:41,520 --> 00:08:43,950
size by 20% for their
Instagram embeds.

195
00:08:43,950 --> 00:08:48,910


196
00:08:48,910 --> 00:08:52,697
Two popular tools for imagery
resizing are Sharp and Jimp.

197
00:08:52,697 --> 00:08:54,280
The biggest difference
between the two

198
00:08:54,280 --> 00:08:56,840
is that Sharp is faster,
and when I say faster,

199
00:08:56,840 --> 00:08:58,940
I mean faster at
image processing.

200
00:08:58,940 --> 00:09:02,390
However, it requires that you
compile C and C++ to install

201
00:09:02,390 --> 00:09:02,890
it.

202
00:09:02,890 --> 00:09:05,820


203
00:09:05,820 --> 00:09:08,550
In addition to creating
multiple sizes of your images,

204
00:09:08,550 --> 00:09:11,340
you'll need to update your HTML.

205
00:09:11,340 --> 00:09:14,730
You'll want to add the source
set and sizes attributes.

206
00:09:14,730 --> 00:09:16,530
The source set
attribute allows you

207
00:09:16,530 --> 00:09:19,230
to list multiple versions
of the same image.

208
00:09:19,230 --> 00:09:21,210
In addition to
including the file path,

209
00:09:21,210 --> 00:09:23,737
you'll also want to include
the width of the image.

210
00:09:23,737 --> 00:09:26,070
This saves the browser from
having to download the image

211
00:09:26,070 --> 00:09:28,890
to figure out how large it is.

212
00:09:28,890 --> 00:09:31,220
The size attribute tells
the browser the width

213
00:09:31,220 --> 00:09:33,150
that the image will
be displayed at.

214
00:09:33,150 --> 00:09:35,560
By using the information
contained in the source set

215
00:09:35,560 --> 00:09:37,950
and sizes attribute, the
browser can then figure out

216
00:09:37,950 --> 00:09:39,285
which image to download.

217
00:09:39,285 --> 00:09:44,240


218
00:09:44,240 --> 00:09:46,020
Lazy loading is the
last image technique

219
00:09:46,020 --> 00:09:48,030
that I'll be
talking about today.

220
00:09:48,030 --> 00:09:50,370
Lazy loading is a strategy
of waiting to download

221
00:09:50,370 --> 00:09:52,510
a resource until it is needed.

222
00:09:52,510 --> 00:09:55,110
In addition to images, it can
be applied to resource types

223
00:09:55,110 --> 00:09:57,060
like JavaScript.

224
00:09:57,060 --> 00:09:58,870
Image lazy loading
helps performance

225
00:09:58,870 --> 00:10:01,950
by using that bottleneck that
occurs on initial page load.

226
00:10:01,950 --> 00:10:04,470
In addition, it saves user
data by not downloading

227
00:10:04,470 --> 00:10:06,840
images that may never be used.

228
00:10:06,840 --> 00:10:08,730
Spotify is an
example of a website

229
00:10:08,730 --> 00:10:10,920
that uses this technique
very effectively.

230
00:10:10,920 --> 00:10:12,889
On this particular
page that I pulled up,

231
00:10:12,889 --> 00:10:14,430
image lazy loading
was the difference

232
00:10:14,430 --> 00:10:17,400
between loading a mg of
images on initial page load

233
00:10:17,400 --> 00:10:20,100
and 18 mgs of an image
on initial page load.

234
00:10:20,100 --> 00:10:24,050
That's a huge difference.

235
00:10:24,050 --> 00:10:26,660
Two tools to look into
for image lazy loading

236
00:10:26,660 --> 00:10:28,490
are lazysizes and lozad.

237
00:10:28,490 --> 00:10:31,700
And you implement them both
more or less the same way.

238
00:10:31,700 --> 00:10:33,290
Add the script
your site, and then

239
00:10:33,290 --> 00:10:36,410
indicate which images
should be lazy loaded.

240
00:10:36,410 --> 00:10:40,010
However, just because this is a
fairly simple to use technique

241
00:10:40,010 --> 00:10:42,710
does not mean that's
not important.

242
00:10:42,710 --> 00:10:46,580
In fact, it is so important
that native lazy loading

243
00:10:46,580 --> 00:10:48,161
is coming to Chrome.

244
00:10:48,161 --> 00:10:49,103
[APPLAUSE]

245
00:10:49,103 --> 00:10:54,599


246
00:10:54,599 --> 00:10:56,140
Native lazy loading
means that you'll

247
00:10:56,140 --> 00:10:57,880
be able to take
advantage of lazy loading

248
00:10:57,880 --> 00:11:00,250
without having to add
third-party scripts

249
00:11:00,250 --> 00:11:01,600
on your site.

250
00:11:01,600 --> 00:11:03,340
It'll be available
for both images

251
00:11:03,340 --> 00:11:06,520
and cross origin I-frames.

252
00:11:06,520 --> 00:11:09,790
And you can truly be lazy when
it comes to implementing it.

253
00:11:09,790 --> 00:11:11,680
If you make no
changes to your HTML,

254
00:11:11,680 --> 00:11:13,840
the browser will simply
decide which resources

255
00:11:13,840 --> 00:11:15,220
should be lazy loaded.

256
00:11:15,220 --> 00:11:18,280
If you do care, however, you
can use the lazy load attribute

257
00:11:18,280 --> 00:11:20,830
to specify which attributes
should or should not

258
00:11:20,830 --> 00:11:21,660
be lazy loaded.

259
00:11:21,660 --> 00:11:25,330


260
00:11:25,330 --> 00:11:26,994
Fonts can cause
performance problems

261
00:11:26,994 --> 00:11:29,410
because they are typically
large files that are downloaded

262
00:11:29,410 --> 00:11:31,090
from third-party sites.

263
00:11:31,090 --> 00:11:34,294
As a result, they can
take a while to load.

264
00:11:34,294 --> 00:11:35,710
This leads to the
phenomenon known

265
00:11:35,710 --> 00:11:37,690
as the flash of invisible text.

266
00:11:37,690 --> 00:11:40,630
And shockingly, this affects two
out of every five mobile sites.

267
00:11:40,630 --> 00:11:43,190


268
00:11:43,190 --> 00:11:45,110
Flash of invisible
text looks like this.

269
00:11:45,110 --> 00:11:47,530
Instead of a user being
greeted with text on your site,

270
00:11:47,530 --> 00:11:50,360
they're greater
with invisibleness.

271
00:11:50,360 --> 00:11:53,294
Not only is this frustrating,
but it also looks bad.

272
00:11:53,294 --> 00:11:54,710
What you want to
encourage instead

273
00:11:54,710 --> 00:11:57,240
is the flash of unstyled text.

274
00:11:57,240 --> 00:11:59,420
And this is when the
browser initially displays

275
00:11:59,420 --> 00:12:02,210
text using a system
font and then

276
00:12:02,210 --> 00:12:05,540
swaps it out for the custom
font once it has arrived.

277
00:12:05,540 --> 00:12:09,050
The good news here is that this
fix is literally a one-liner.

278
00:12:09,050 --> 00:12:11,720
Everywhere in your CSS where
you declare a font face,

279
00:12:11,720 --> 00:12:13,940
add the line font display swap.

280
00:12:13,940 --> 00:12:16,250
This tells the browser to
use that swapping behavior

281
00:12:16,250 --> 00:12:19,924
that I just talked about
in the previous slide.

282
00:12:19,924 --> 00:12:21,340
Now I'm going to
hand the mic over

283
00:12:21,340 --> 00:12:23,650
to Houssein who's going to
talk with you about techniques

284
00:12:23,650 --> 00:12:25,025
you can use with
your JavaScript.

285
00:12:25,025 --> 00:12:25,782
[MUSIC PLAYING]

286
00:12:25,782 --> 00:12:33,825


287
00:12:33,825 --> 00:12:35,200
HOUSSEIN DJIRDEH:
So Katie showed

288
00:12:35,200 --> 00:12:36,575
a number of
techniques that could

289
00:12:36,575 --> 00:12:39,930
be quite useful for the images
and web fonts in your site,

290
00:12:39,930 --> 00:12:43,570
as well the few exciting things
coming to the Chrome platform

291
00:12:43,570 --> 00:12:47,024
in the near future, like
native lazy loading.

292
00:12:47,024 --> 00:12:48,690
For the rest of this
talk, we'll go over

293
00:12:48,690 --> 00:12:50,273
some other important
things you should

294
00:12:50,273 --> 00:12:54,232
be doing before the JavaScript
that makes up your application.

295
00:12:54,232 --> 00:12:57,540


296
00:12:57,540 --> 00:12:59,010
Earlier in this
session, we saw how

297
00:12:59,010 --> 00:13:02,340
images can make up the
majority of a site with regards

298
00:13:02,340 --> 00:13:04,750
to number of bytes sent.

299
00:13:04,750 --> 00:13:06,900
However, we also send
a significant amount

300
00:13:06,900 --> 00:13:10,040
of JavaScript to browsers.

301
00:13:10,040 --> 00:13:12,130
If we take a look
at HTTP archive data

302
00:13:12,130 --> 00:13:16,060
once again, as of last
month, the median amount

303
00:13:16,060 --> 00:13:19,270
of JavaScript that we
shipped to mobile web pages

304
00:13:19,270 --> 00:13:23,170
was about 370 kilobytes.

305
00:13:23,170 --> 00:13:27,910
For desktop, the
number was about 420.

306
00:13:27,910 --> 00:13:31,780
Now JavaScript code still needs
to be uncompressed, parsed,

307
00:13:31,780 --> 00:13:34,340
and executed by the browser.

308
00:13:34,340 --> 00:13:37,030
So in reality, we're
looking at about a megabyte

309
00:13:37,030 --> 00:13:40,220
of uncompressed code
that needs to be sent--

310
00:13:40,220 --> 00:13:43,120
that needs to be for an
application of this size.

311
00:13:43,120 --> 00:13:46,780
Users who try to access this
with low-end mobile devices

312
00:13:46,780 --> 00:13:49,855
will notice a much
poorer performance.

313
00:13:49,855 --> 00:13:52,830


314
00:13:52,830 --> 00:13:55,500
But why are we, as
developers, shipping way more

315
00:13:55,500 --> 00:13:58,930
JavaScript code than
we've ever done before?

316
00:13:58,930 --> 00:14:00,400
There are a number of reasons.

317
00:14:00,400 --> 00:14:02,910
One of them being the
amount of dependencies

318
00:14:02,910 --> 00:14:04,770
that we pull into
our applications

319
00:14:04,770 --> 00:14:08,880
and how easy that
process has become.

320
00:14:08,880 --> 00:14:11,940
Front-end tooling has come a
long way in the past decade,

321
00:14:11,940 --> 00:14:13,680
but there has been some cost.

322
00:14:13,680 --> 00:14:17,140


323
00:14:17,140 --> 00:14:19,780
So what can we do to
continue to try and build

324
00:14:19,780 --> 00:14:22,300
robust and fully
fledged applications,

325
00:14:22,300 --> 00:14:26,050
but not at the expense
of user experience?

326
00:14:26,050 --> 00:14:29,410
The very first thing we can
and should consider doing is

327
00:14:29,410 --> 00:14:31,510
splitting our bundle .

328
00:14:31,510 --> 00:14:33,190
The idea behind
code splitting is

329
00:14:33,190 --> 00:14:36,190
instead of sending all the
JavaScript code to your users

330
00:14:36,190 --> 00:14:39,710
as soon as they load the very
first page of your application,

331
00:14:39,710 --> 00:14:43,250
is to only send them what they
need for their initial state.

332
00:14:43,250 --> 00:14:45,790
And then allow them to fetch
future chunks on demand.

333
00:14:45,790 --> 00:14:49,130


334
00:14:49,130 --> 00:14:51,620
The easiest way to get
started with code splitting

335
00:14:51,620 --> 00:14:54,330
is by using dynamic imports.

336
00:14:54,330 --> 00:14:56,180
Now dynamic imports
has been supported

337
00:14:56,180 --> 00:14:58,600
in Webpack for quite some time.

338
00:14:58,600 --> 00:15:01,600
And it allows you to import
a module asynchronously

339
00:15:01,600 --> 00:15:04,400
where a promise gets returned.

340
00:15:04,400 --> 00:15:06,980
Once that promise
finishes resolving,

341
00:15:06,980 --> 00:15:11,560
you can do what you need to
do with that piece of code.

342
00:15:11,560 --> 00:15:13,450
The idea behind
dynamic imports is

343
00:15:13,450 --> 00:15:16,210
you want to make sure that
it fires on certain user

344
00:15:16,210 --> 00:15:17,530
interactions.

345
00:15:17,530 --> 00:15:20,980
And you want to do this to make
sure that you only fetch code

346
00:15:20,980 --> 00:15:23,890
when it's actually needed.

347
00:15:23,890 --> 00:15:26,560
If you happen to be using
another module bundler,

348
00:15:26,560 --> 00:15:29,470
like parcel or roll
up, you can still

349
00:15:29,470 --> 00:15:32,840
use dynamic import to code
split where you see fit.

350
00:15:32,840 --> 00:15:36,510


351
00:15:36,510 --> 00:15:38,990
Now, a number of JavaScript
libraries and frameworks

352
00:15:38,990 --> 00:15:42,440
have provided abstractions
on top of dynamic imports

353
00:15:42,440 --> 00:15:44,090
to make the process
of code splitting

354
00:15:44,090 --> 00:15:47,450
easier with your
current tooling.

355
00:15:47,450 --> 00:15:51,260
With view, for example, you
can define async components.

356
00:15:51,260 --> 00:15:53,960
And they're just functions
that return a promise that

357
00:15:53,960 --> 00:15:56,900
resolve to the set components.

358
00:15:56,900 --> 00:15:58,970
By using that with
dynamic imports,

359
00:15:58,970 --> 00:16:01,160
you can attach
async opponents into

360
00:16:01,160 --> 00:16:03,230
your routing configurations.

361
00:16:03,230 --> 00:16:05,510
So that only when a
certain route is reached,

362
00:16:05,510 --> 00:16:08,540
only then will the code
and lives in that component

363
00:16:08,540 --> 00:16:09,210
be fetched.

364
00:16:09,210 --> 00:16:12,010


365
00:16:12,010 --> 00:16:14,920
Angular has a very
similar pattern.

366
00:16:14,920 --> 00:16:17,800
In its router, you can use
the load children attribute

367
00:16:17,800 --> 00:16:19,480
and you can use it
to connect a feature

368
00:16:19,480 --> 00:16:23,050
module to a specific route.

369
00:16:23,050 --> 00:16:26,410
With load children, you
can define a dynamic import

370
00:16:26,410 --> 00:16:27,280
with Ivy.

371
00:16:27,280 --> 00:16:29,830
And Ivy's a new rendering
engine that the Angular team

372
00:16:29,830 --> 00:16:31,900
is working on.

373
00:16:31,900 --> 00:16:35,260
When you do this approach, all
the code, all the components,

374
00:16:35,260 --> 00:16:37,720
all the services that
live in the feature module

375
00:16:37,720 --> 00:16:40,810
will only get loaded when
that route is reached.

376
00:16:40,810 --> 00:16:43,090
In the meantime, you
can use load children,

377
00:16:43,090 --> 00:16:44,800
but you just need to
use a relative file

378
00:16:44,800 --> 00:16:46,390
path to the feature module.

379
00:16:46,390 --> 00:16:49,280


380
00:16:49,280 --> 00:16:52,070
With React, libraries
like React Loadable

381
00:16:52,070 --> 00:16:54,080
and loadable
components have allowed

382
00:16:54,080 --> 00:16:56,504
us to code split on
the component level

383
00:16:56,504 --> 00:16:57,920
while taking care
of other things,

384
00:16:57,920 --> 00:17:01,220
like showing a loading
indicator, or an error state,

385
00:17:01,220 --> 00:17:03,140
where applicable.

386
00:17:03,140 --> 00:17:08,500
However, with React 16.6, the
lazy method was introduced.

387
00:17:08,500 --> 00:17:12,540
And this allows you to code
split while using suspense.

388
00:17:12,540 --> 00:17:15,260
Now suspense is a feature
that the react team has been

389
00:17:15,260 --> 00:17:17,460
working on for quite some time.

390
00:17:17,460 --> 00:17:20,660
And it allows you to suspend how
certain component trees update

391
00:17:20,660 --> 00:17:23,119
your state or update
the DOM, depending

392
00:17:23,119 --> 00:17:25,241
on how all of its
children components

393
00:17:25,241 --> 00:17:26,240
have fetched their data.

394
00:17:26,240 --> 00:17:30,890


395
00:17:30,890 --> 00:17:33,637
Another very useful technique
that ties in well to code

396
00:17:33,637 --> 00:17:37,960
splitting your bundle
is by using preload.

397
00:17:37,960 --> 00:17:39,850
Preload allows us
to tell the browser

398
00:17:39,850 --> 00:17:42,820
that if we have a late
discovered resource

399
00:17:42,820 --> 00:17:46,480
or a resource that's fetched
late in the request chain

400
00:17:46,480 --> 00:17:50,770
that we'd like to download it
sooner because it's important.

401
00:17:50,770 --> 00:17:53,280
So by doing this, we're telling
the browser to prioritize.

402
00:17:53,280 --> 00:17:56,410


403
00:17:56,410 --> 00:17:59,060
To use preload, you only
need to add a link element

404
00:17:59,060 --> 00:18:01,560
to the head of
your HTML document

405
00:18:01,560 --> 00:18:03,530
and you need to
have a rel attribute

406
00:18:03,530 --> 00:18:05,530
with a value of preload.

407
00:18:05,530 --> 00:18:09,230
The as attribute is used
to define what type of file

408
00:18:09,230 --> 00:18:10,050
you'd like to load.

409
00:18:10,050 --> 00:18:14,050


410
00:18:14,050 --> 00:18:16,680
Now as developers, it's
also important to make sure

411
00:18:16,680 --> 00:18:19,020
that the code that
we write works well

412
00:18:19,020 --> 00:18:23,460
in all the browsers people
use to access our site.

413
00:18:23,460 --> 00:18:29,280
So if we happen to include ES
2015, 2016, or later syntax,

414
00:18:29,280 --> 00:18:32,250
we also want to include
backwards compatible formats

415
00:18:32,250 --> 00:18:36,610
so all the browsers can
still understand them.

416
00:18:36,610 --> 00:18:39,610
This usually involves adding
transforms for any newer syntax

417
00:18:39,610 --> 00:18:44,330
that we use and polyfills
for any newer features.

418
00:18:44,330 --> 00:18:46,210
Now because
transpiling means we're

419
00:18:46,210 --> 00:18:48,510
adding code on
top of our bundle,

420
00:18:48,510 --> 00:18:50,199
or application ends
up being larger

421
00:18:50,199 --> 00:18:51,490
than it was originally written.

422
00:18:51,490 --> 00:18:55,320


423
00:18:55,320 --> 00:18:57,960
One way to make sure that
we only transpile the code

424
00:18:57,960 --> 00:19:02,520
that's actually needed is
by using babel/preset-EMV.

425
00:19:02,520 --> 00:19:05,100
This preset takes
the hassle out of us

426
00:19:05,100 --> 00:19:08,850
trying to micromanage
which plugins and polyfills

427
00:19:08,850 --> 00:19:10,330
we need to add.

428
00:19:10,330 --> 00:19:12,750
And it does this by
allowing us to specify

429
00:19:12,750 --> 00:19:18,560
a target list of browsers and
letting babel handle the rest.

430
00:19:18,560 --> 00:19:21,250
You can add this preset
into your list of presets

431
00:19:21,250 --> 00:19:24,320
in your babel
configuration, and you

432
00:19:24,320 --> 00:19:27,920
can use the target's attributes
to define that set of browsers

433
00:19:27,920 --> 00:19:29,930
that you'd like to reach.

434
00:19:29,930 --> 00:19:32,700
Now this is a
browser list query.

435
00:19:32,700 --> 00:19:35,360
So if you use tools like
order auto prefix or before,

436
00:19:35,360 --> 00:19:38,630
you may already be
familiar with it.

437
00:19:38,630 --> 00:19:41,390
Using a percentage, like
here, is one type of query

438
00:19:41,390 --> 00:19:42,440
you can use.

439
00:19:42,440 --> 00:19:44,990
And it allows you to
target browsers that cross

440
00:19:44,990 --> 00:19:46,450
a certain global market share.

441
00:19:46,450 --> 00:19:49,450


442
00:19:49,450 --> 00:19:52,520
The use built-in attribute
allows us to tell babel

443
00:19:52,520 --> 00:19:55,580
how to handle adding polyfills.

444
00:19:55,580 --> 00:19:58,930
The usage value means that
babel only automatically

445
00:19:58,930 --> 00:20:01,900
include polyfills to
files when it's actually

446
00:20:01,900 --> 00:20:05,820
needed for features that
need to be transpiled.

447
00:20:05,820 --> 00:20:10,419
Now this is the behavior we all
want, to only transpile code

448
00:20:10,419 --> 00:20:11,210
when it's required.

449
00:20:11,210 --> 00:20:16,930


450
00:20:16,930 --> 00:20:20,050
So although babel/preset-EMV
means that we can limit

451
00:20:20,050 --> 00:20:23,200
the amount of transpiled code
that we have to make sure that

452
00:20:23,200 --> 00:20:26,650
we only include what's necessary
for all the browsers we plan

453
00:20:26,650 --> 00:20:30,580
to target, what if there was a
way to differentially serve two

454
00:20:30,580 --> 00:20:32,600
different types of bundles?

455
00:20:32,600 --> 00:20:35,110
One, that's largely
un-transpiled,

456
00:20:35,110 --> 00:20:39,100
for newer browsers that don't
need nearly as many polyfills,

457
00:20:39,100 --> 00:20:42,370
and another legacy bundle,
that contains more polyfills,

458
00:20:42,370 --> 00:20:47,060
is a bit larger, but is
needed for older browsers.

459
00:20:47,060 --> 00:20:50,780
We can do this by using
JavaScript modules.

460
00:20:50,780 --> 00:20:53,410
Now JavaScript
modules or ES modules

461
00:20:53,410 --> 00:20:56,590
allow us to write blocks of
code that import and export

462
00:20:56,590 --> 00:20:58,420
from other modules.

463
00:20:58,420 --> 00:21:00,700
But the amazing thing
about using modules with

464
00:21:00,700 --> 00:21:04,690
babel/present-EMV is that
we can have it as a target,

465
00:21:04,690 --> 00:21:09,350
instead of a specific
browser query.

466
00:21:09,350 --> 00:21:13,460
One site that's actually using
this module approach today

467
00:21:13,460 --> 00:21:15,219
is "The New York Times."

468
00:21:15,219 --> 00:21:17,510
And they're using it for one
of their flagship articles

469
00:21:17,510 --> 00:21:22,990
of the year, piling in real time
for the 2018 midterm elections.

470
00:21:22,990 --> 00:21:25,900
They're using Sapper as their
client-side framework, which

471
00:21:25,900 --> 00:21:28,780
contains a number of progressive
enhancements baked in,

472
00:21:28,780 --> 00:21:30,850
like automatic code splitting.

473
00:21:30,850 --> 00:21:35,820
But they're also using roll up
to emit module chunks as well.

474
00:21:35,820 --> 00:21:37,680
They're using a fairly
simple heuristic

475
00:21:37,680 --> 00:21:41,610
to make sure that users who
have older browsers download

476
00:21:41,610 --> 00:21:44,550
a larger more polyfilled
bundle, but users who

477
00:21:44,550 --> 00:21:46,740
are using newer browsers
can only download

478
00:21:46,740 --> 00:21:48,750
smaller and slimmer module.

479
00:21:48,750 --> 00:21:53,110


480
00:21:53,110 --> 00:21:56,160
A very simple way to
make sure that users

481
00:21:56,160 --> 00:21:59,370
who access your app only
download one or the other

482
00:21:59,370 --> 00:22:03,680
is by using the module,
no module technique.

483
00:22:03,680 --> 00:22:06,890
When you define a script
element with type module,

484
00:22:06,890 --> 00:22:11,020
browsers that understand modules
will download that normally.

485
00:22:11,020 --> 00:22:13,700
But they'll know to ignore
any script element that

486
00:22:13,700 --> 00:22:16,980
has the no module attribute.

487
00:22:16,980 --> 00:22:20,700
Similarly, browsers that
don't understand modules

488
00:22:20,700 --> 00:22:24,570
will ignore any script
elements that have type module.

489
00:22:24,570 --> 00:22:27,480
But since they can't identify
what no module means,

490
00:22:27,480 --> 00:22:30,340
they'll download
that bundle as well.

491
00:22:30,340 --> 00:22:32,640
So here, we can get the
best of both worlds.

492
00:22:32,640 --> 00:22:34,960
Shipping the right
bundle to our users,

493
00:22:34,960 --> 00:22:36,990
depending on what
browser they use.

494
00:22:36,990 --> 00:22:41,290


495
00:22:41,290 --> 00:22:43,680
If you happen to have
critical modules that you'd

496
00:22:43,680 --> 00:22:45,940
like to download sooner,
you could do that

497
00:22:45,940 --> 00:22:48,930
by also preloading them as well.

498
00:22:48,930 --> 00:22:52,030
And you just need to specify
a module preload value

499
00:22:52,030 --> 00:22:53,468
to the rel attribute.

500
00:22:53,468 --> 00:22:56,574


501
00:22:56,574 --> 00:22:57,990
So we've talked
about a few things

502
00:22:57,990 --> 00:23:02,370
you can do to improve the code
that you ship to your users,

503
00:23:02,370 --> 00:23:05,280
but if you're thinking of adding
any of these optimizations,

504
00:23:05,280 --> 00:23:08,519
it could be useful to try
and keep an eye on things.

505
00:23:08,519 --> 00:23:10,560
And there are tools out
there that could actually

506
00:23:10,560 --> 00:23:12,810
make this easier.

507
00:23:12,810 --> 00:23:15,990
The code coverage tab
within Chrome DevTools

508
00:23:15,990 --> 00:23:18,900
allows you to see the
size of all your bundles,

509
00:23:18,900 --> 00:23:23,060
as well as how much of it
is actually being used.

510
00:23:23,060 --> 00:23:25,550
You can access it by
opening the Command menu

511
00:23:25,550 --> 00:23:27,606
and just typing in coverage.

512
00:23:27,606 --> 00:23:30,870


513
00:23:30,870 --> 00:23:33,870
If you're using Webpack,
Webpack bundle analyzer

514
00:23:33,870 --> 00:23:36,280
can be a very handy tool.

515
00:23:36,280 --> 00:23:38,880
And it gives you a nice
heat map visualization

516
00:23:38,880 --> 00:23:40,470
of your entire bundle.

517
00:23:40,470 --> 00:23:43,680
You can zoom in, see which
parts of your bundle are larger

518
00:23:43,680 --> 00:23:45,540
and which parts of your
bundle are smaller.

519
00:23:45,540 --> 00:23:49,890


520
00:23:49,890 --> 00:23:51,330
And if you've ever
wanted to find

521
00:23:51,330 --> 00:23:55,800
the cost of a specific library,
you can use bundle phobia.

522
00:23:55,800 --> 00:23:58,110
You could type the
name of a package

523
00:23:58,110 --> 00:24:01,710
and see how large it is, as
well as how much of an impact

524
00:24:01,710 --> 00:24:06,180
it can make to your application
in terms of download time.

525
00:24:06,180 --> 00:24:09,000
You can also scan
your packages on file

526
00:24:09,000 --> 00:24:11,970
to see how much of an impact
all your packages make.

527
00:24:11,970 --> 00:24:16,760


528
00:24:16,760 --> 00:24:20,180
Now as useful as it is to
use tools to manually keep

529
00:24:20,180 --> 00:24:23,180
an eye on how things are
doing with your bundle size,

530
00:24:23,180 --> 00:24:26,510
it can be especially useful to
also include checks into your

531
00:24:26,510 --> 00:24:28,460
build workflow.

532
00:24:28,460 --> 00:24:30,140
One tool that could
actually help here,

533
00:24:30,140 --> 00:24:32,770
that can allow you to
set performance budgets,

534
00:24:32,770 --> 00:24:34,920
is the Lighthouse CI.

535
00:24:34,920 --> 00:24:38,360
So instead of only running a
Lighthouse in the Chrome audits

536
00:24:38,360 --> 00:24:41,120
panel, or as a
Chrome extension, you

537
00:24:41,120 --> 00:24:44,180
can also run Lighthouse
in CI and have

538
00:24:44,180 --> 00:24:48,030
it included as a status
check into your workflow.

539
00:24:48,030 --> 00:24:51,050
You could specify certain
Lighthouse categories and set

540
00:24:51,050 --> 00:24:54,920
scores for them so that
merges and pull requests only

541
00:24:54,920 --> 00:24:57,440
get included if
those scores are met.

542
00:24:57,440 --> 00:25:01,940


543
00:25:01,940 --> 00:25:03,760
Now a site that's
actually taking steps

544
00:25:03,760 --> 00:25:07,250
to add a number of these
optimizations is UniQlo.

545
00:25:07,250 --> 00:25:09,620
They're a clothing
retailer base out of Japan.

546
00:25:09,620 --> 00:25:12,250
And they're taking steps
to improve their entire web

547
00:25:12,250 --> 00:25:16,600
architecture, beginning
with their Canadian site.

548
00:25:16,600 --> 00:25:19,450
They've identified a number
of critical resources

549
00:25:19,450 --> 00:25:22,420
and decided to try and
download them sooner,

550
00:25:22,420 --> 00:25:24,730
and they're doing this
by preloading them.

551
00:25:24,730 --> 00:25:26,200
They've done this
with some images,

552
00:25:26,200 --> 00:25:31,260
some core fonts, as well as a
number of cross origin fetches.

553
00:25:31,260 --> 00:25:32,940
They then also
identified that they

554
00:25:32,940 --> 00:25:37,810
can code split and try to get
some wins that way as well.

555
00:25:37,810 --> 00:25:40,320
They took the correct first
step of code splitting

556
00:25:40,320 --> 00:25:41,790
at the route level.

557
00:25:41,790 --> 00:25:43,640
And just by doing
that alone, they

558
00:25:43,640 --> 00:25:48,390
noticed an almost half size
reduction in their bundle size.

559
00:25:48,390 --> 00:25:51,600
They also moved on to code split
their localization package.

560
00:25:51,600 --> 00:25:53,790
And noticed that they can
get their bundle size down

561
00:25:53,790 --> 00:25:56,110
to 200 kilobytes.

562
00:25:56,110 --> 00:25:58,900
After this, they even
added more optimizations,

563
00:25:58,900 --> 00:26:00,880
such as using a
pre-act compatibility

564
00:26:00,880 --> 00:26:03,970
layer for the react bindings,
to get their bundle size

565
00:26:03,970 --> 00:26:06,117
to about 170 kilobytes.

566
00:26:06,117 --> 00:26:09,664


567
00:26:09,664 --> 00:26:11,080
While doing all
of this, they made

568
00:26:11,080 --> 00:26:14,020
sure to also set budgets
so their whole team can

569
00:26:14,020 --> 00:26:15,480
stay in sync.

570
00:26:15,480 --> 00:26:17,820
And they're using another
open source tool to help here,

571
00:26:17,820 --> 00:26:20,020
called Bundle Size.

572
00:26:20,020 --> 00:26:23,540
They've set 80 kilobyte budgets
for each one of the chunks,

573
00:26:23,540 --> 00:26:26,920
and then allowed them to stay
under a 200 kilobyte total

574
00:26:26,920 --> 00:26:28,480
for all of their scripts.

575
00:26:28,480 --> 00:26:33,566


576
00:26:33,566 --> 00:26:34,940
While adding these
optimizations,

577
00:26:34,940 --> 00:26:38,450
they noticed a two-second
time to interactive reduction

578
00:26:38,450 --> 00:26:41,210
for users that use
low-end mobile devices

579
00:26:41,210 --> 00:26:43,280
and have weak connections.

580
00:26:43,280 --> 00:26:46,560
Now you might think two
seconds is not that much.

581
00:26:46,560 --> 00:26:51,090
But it can make an impact
for your customers.

582
00:26:51,090 --> 00:26:52,860
After these
optimizations were added,

583
00:26:52,860 --> 00:26:56,790
they notice a 14%
reduction in bounce rate,

584
00:26:56,790 --> 00:27:00,390
a 31% increase in
average duration,

585
00:27:00,390 --> 00:27:04,980
and a 25% increase in
pages viewed per session.

586
00:27:04,980 --> 00:27:06,660
Now there were other
things also being

587
00:27:06,660 --> 00:27:09,090
added to the site
at the same time,

588
00:27:09,090 --> 00:27:12,300
but they know that performance
played a very huge factor here.

589
00:27:12,300 --> 00:27:18,070


590
00:27:18,070 --> 00:27:19,840
So we've talked about
quite a few things

591
00:27:19,840 --> 00:27:24,320
that you can do today to
improve how your site performs.

592
00:27:24,320 --> 00:27:28,450
But what can Chrome do
as a browser as well?

593
00:27:28,450 --> 00:27:31,870
For users that opt in
to Data Saver mode,

594
00:27:31,870 --> 00:27:35,260
Chrome will try show a
lightweight version of the page

595
00:27:35,260 --> 00:27:36,730
where possible.

596
00:27:36,730 --> 00:27:39,460
And it does this by
minimizing data used

597
00:27:39,460 --> 00:27:43,740
as well as showing cache
content whenever it can.

598
00:27:43,740 --> 00:27:47,310
Now as developers, you can
also tap into this as well.

599
00:27:47,310 --> 00:27:52,180
And you could do this by using
the network information API.

600
00:27:52,180 --> 00:27:54,490
If you look at the navigator
connection save data

601
00:27:54,490 --> 00:27:57,880
attribute you can identify
whether your users actually

602
00:27:57,880 --> 00:27:59,580
have data saver enabled.

603
00:27:59,580 --> 00:28:02,320
And you could try and serve a
slightly different experience

604
00:28:02,320 --> 00:28:06,820
to make sure things are
fast for them as well.

605
00:28:06,820 --> 00:28:09,990
You can also use the
effective type attribute,

606
00:28:09,990 --> 00:28:13,650
and use that to actually be
able to serve different assets

607
00:28:13,650 --> 00:28:17,580
conditionally depending on what
connection your user is having.

608
00:28:17,580 --> 00:28:21,810


609
00:28:21,810 --> 00:28:23,820
The very last thing that
I do want to mention

610
00:28:23,820 --> 00:28:25,680
is although me and
Katie have talked

611
00:28:25,680 --> 00:28:27,100
about a lot of the
things that you

612
00:28:27,100 --> 00:28:30,970
can do to improve your
site, every application

613
00:28:30,970 --> 00:28:32,660
is built differently.

614
00:28:32,660 --> 00:28:34,290
Every team is different.

615
00:28:34,290 --> 00:28:36,112
Every tool chain is different.

616
00:28:36,112 --> 00:28:37,820
So this isn't something
you need to start

617
00:28:37,820 --> 00:28:41,480
doing wholesale and
including everything at once.

618
00:28:41,480 --> 00:28:44,280
By setting budgets and keeping
an eye on your bundle size

619
00:28:44,280 --> 00:28:47,420
from the very beginning,
you can include performance

620
00:28:47,420 --> 00:28:50,600
enhancements as a
step by step procedure

621
00:28:50,600 --> 00:28:53,060
and make sure your
site never regresses.

622
00:28:53,060 --> 00:28:56,007
Performance doesn't need
to be an afterthought.

623
00:28:56,007 --> 00:28:59,210


624
00:28:59,210 --> 00:29:02,660
Almost everything we've
talked about is in web.dev,

625
00:29:02,660 --> 00:29:06,320
so I highly suggest you take
a look if you haven't already.

626
00:29:06,320 --> 00:29:09,110
We hope you enjoyed this talk
as much as we enjoyed giving it.

627
00:29:09,110 --> 00:29:09,920
Thank you.

628
00:29:09,920 --> 00:29:12,070
[MUSIC PLAYING]

629
00:29:12,070 --> 00:29:20,210