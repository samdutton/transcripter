<!DOCTYPE html>

<!--
Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="Chrome Dev Summit">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>kZrl91SPSpc</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/kZrl91SPSpc?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p></p>
</section>

<section>
<p><span data-start="5.238" data-end="6.53"><span class="speaker">Thomas Nattestad</span>: Hi, everyone.</span> <span data-start="6.53" data-end="9.43">My name is Thomas and together with my colleague Ingvar here,</span> <span data-start="9.43" data-end="11.83">we're going to show you how using WebAssembly</span> <span data-start="11.83" data-end="14.05">can speed up your computationally intensive</span> <span data-start="14.05" data-end="16.45">workloads by more than 10x.</span> <span data-start="16.45" data-end="19.15">And how using modern WebAssembly tooling</span> <span data-start="19.15" data-end="22.58">can let you take advantage of WebAssembly more easily.</span> <span data-start="22.58" data-end="25.12">We'll start by reminding everyone what WebAssembly is</span> <span data-start="25.12" data-end="26.62">and showing some of the improvements</span> <span data-start="26.62" data-end="29.472">we've been making to Chrome's implementation.</span> <span data-start="29.472" data-end="31.93">Then we're going to get into some of the different language</span> <span data-start="31.93" data-end="35.44">features that are starting to ship as part of WebAssembly.</span> </p>
<p><span data-start="35.44" data-end="36.88">And then finally, we'll close out</span> <span data-start="36.88" data-end="39.34">by covering some of the new tooling updates that</span> <span data-start="39.34" data-end="42.13">have been coming as well.</span> <span data-start="42.13" data-end="43.63">So let's start by reminding everyone</span> <span data-start="43.63" data-end="46.69">what WebAssembly actually is.</span> <span data-start="46.69" data-end="49.21">WebAssembly is a new language for the web that</span> <span data-start="49.21" data-end="51.58">is designed as a compilation target</span> <span data-start="51.58" data-end="54.902">to offer maximized and reliable performance.</span> </p>
<p><span data-start="54.902" data-end="56.36">It's important to remember, though,</span> <span data-start="56.36" data-end="59.92">that WebAssembly is in no way meant to replace JavaScript.</span> <span data-start="59.92" data-end="62.65">Rather, it's meant to augment the things that JavaScript</span> <span data-start="62.65" data-end="64.568">was never designed to do.</span> <span data-start="64.568" data-end="66.61">So let's look at some of the different advantages</span> <span data-start="66.61" data-end="69.81">of WebAssembly and why you might want to use it.</span> <span data-start="69.81" data-end="73.84">First, because WebAssembly offers strong type guarantees,</span> <span data-start="73.84" data-end="76.34">it gives you more consistent and reliable performance</span> <span data-start="76.34" data-end="77.77">than JavaScript.</span> <span data-start="77.77" data-end="80.65">Then, with additional features like threads and Cindy,</span> <span data-start="80.65" data-end="82.3">which will get more into later, you</span> <span data-start="82.3" data-end="84.73">can also achieve speeds that are truly higher than what</span> <span data-start="84.73" data-end="87.73">you can with JavaScript.</span> </p>
<p><span data-start="87.73" data-end="90.58">When thinking about comparing baseline performance</span> <span data-start="90.58" data-end="94.39">WebAssembly to JavaScript, I find this metaphor</span> <span data-start="94.39" data-end="97.48">which my colleague [? Sama ?] came up with really useful.</span> <span data-start="97.48" data-end="99.94">JavaScript is like running along a tightrope.</span> <span data-start="99.94" data-end="102.79">It's possible to go fast, but it requires a lot of skill</span> <span data-start="102.79" data-end="105.68">and it's possible to fall off the fast path.</span> <span data-start="105.68" data-end="108.43">Whereas baseline WebAssembly is more like running along a train</span> <span data-start="108.43" data-end="109.28">track.</span> <span data-start="109.28" data-end="113.6">You don't have to be as careful in order to go fast.</span> <span data-start="113.6" data-end="116.98">Another advantage of WebAssembly is its amazing portability.</span> </p>
<p><span data-start="116.98" data-end="120.01">Because you can compile from other languages,</span> <span data-start="120.01" data-end="122.98">you can bring not only your own code bases and libraries</span> <span data-start="122.98" data-end="125.47">to the web, but also the incredible wealth of open</span> <span data-start="125.47" data-end="130.703">source libraries built in languages like C++.</span> <span data-start="130.703" data-end="132.87">Lastly, and potentially most exciting to many of you</span> <span data-start="132.87" data-end="135.368">out there, is the possibility of more flexibility</span> <span data-start="135.368" data-end="136.41">when writing for the web.</span> <span data-start="136.41" data-end="139.2">Specifically, the ability to write in other languages.</span> <span data-start="139.2" data-end="141.21">Since the web's inception, JavaScript</span> <span data-start="141.21" data-end="143.4">has been the only fully supported option.</span> <span data-start="143.4" data-end="147.78">And now through WebAssembly, you get more choice.</span> <span data-start="147.78" data-end="149.25">Most exciting though, is the fact</span> <span data-start="149.25" data-end="152.07">that WebAssembly is now shipping in all major browsers,</span> <span data-start="152.07" data-end="155.46">making it the first new language to ship in every major browser</span> <span data-start="155.46" data-end="160.06">since JavaScript was created more than 20 years ago.</span> </p>
<p><span data-start="160.06" data-end="162.72">So now that we all are reminded of what WebAssembly actually</span> <span data-start="162.72" data-end="164.73">is, I want to cover some of the improvements</span> <span data-start="164.73" data-end="167.9">that we've been making directly in Chrome.</span> <span data-start="167.9" data-end="170.75">One of the biggest requests that we've heard from our developers</span> <span data-start="170.75" data-end="173.21">is the desire for faster startup time.</span> <span data-start="173.21" data-end="175.94">To improve startup time for WebAssembly modules,</span> <span data-start="175.94" data-end="177.44">we're starting to roll out something</span> <span data-start="177.44" data-end="180.48">we're calling implicit caching.</span> </p>
<p><span data-start="180.48" data-end="183.33">To recap, when a site loads a WebAssembly module,</span> <span data-start="183.33" data-end="185.46">it first goes into the lift off compiler</span> <span data-start="185.46" data-end="187.76">to start executing immediately.</span> <span data-start="187.76" data-end="190.38">It then is further optimized off the main thread</span> <span data-start="190.38" data-end="192.96">through the turbo fan optimizing compiler,</span> <span data-start="192.96" data-end="197.16">and then the result is hot swapped in when ready.</span> <span data-start="197.16" data-end="199.98">Now, with implicit caching, we also</span> <span data-start="199.98" data-end="203.04">cache that optimized WebAssembly module directly</span> <span data-start="203.04" data-end="205.76">in the HTTP cache.</span> <span data-start="205.76" data-end="208.28">Then, after the user leaves the page and comes back,</span> <span data-start="208.28" data-end="210.32">we load that optimized module directly</span> <span data-start="210.32" data-end="215.03">from the cache, resulting in immediate top tier performance.</span> <span data-start="215.03" data-end="218.18">As the name suggests, implicit caching happens automatically.</span> <span data-start="218.18" data-end="221.4">But there are two tips worth knowing and keeping in mind.</span> </p>
<p><span data-start="221.4" data-end="223.82">The first, is that code caching in WebAssembly</span> <span data-start="223.82" data-end="225.53">works off of the streaming APIs.</span> <span data-start="225.53" data-end="228.02">So make sure it's always used compile streaming</span> <span data-start="228.02" data-end="230.678">or instantiate streaming.</span> </p>
<p><span data-start="230.678" data-end="232.22">The second thing is just to make sure</span> <span data-start="232.22" data-end="233.93">that you're being cache friendly.</span> <span data-start="233.93" data-end="236.39">WebAssembly keeps the cache based on the URL</span> <span data-start="236.39" data-end="237.96">of the WebAssembly module.</span> <span data-start="237.96" data-end="239.595">So if this changes on each load, you</span> <span data-start="239.595" data-end="240.845">won't see any of the benefits.</span> <span data-start="243.49" data-end="245.95">In addition to new features like implicit caching,</span> <span data-start="245.95" data-end="247.84">we're also always making improvements</span> <span data-start="247.84" data-end="249.73">to our WebAssembly engine.</span> <span data-start="249.73" data-end="251.89">Here you can see how commit by commit,</span> <span data-start="251.89" data-end="254.08">we've cut startup time by almost half</span> <span data-start="254.08" data-end="257.381">since just the start of this last year.</span> <span data-start="257.381" data-end="259.839">OK, so now that we've covered some of the improvements that</span> <span data-start="259.839" data-end="261.52">have been made in Chrome, I want to get</span> <span data-start="261.52" data-end="263.02">into some of the actual new language</span> <span data-start="263.02" data-end="265.518">features of WebAssembly.</span> </p>
<p><span data-start="265.518" data-end="267.31">The first feature that I want to talk about</span> <span data-start="267.31" data-end="269.09">is WebAssembly threads.</span> <span data-start="269.09" data-end="272.32">Threads are a key part of practically all CPUs,</span> <span data-start="272.32" data-end="274.15">and utilizing them fully and effectively</span> <span data-start="274.15" data-end="276.58">has been one of the great challenges for the web</span> <span data-start="276.58" data-end="279.07">until now.</span> <span data-start="279.07" data-end="281.14">WebAssembly threads work by relying</span> <span data-start="281.14" data-end="282.94">on three specific things — </span> </p>
<p><span data-start="282.94" data-end="287.53">Web Workers, SharedArrayBuffer, and atomic operations.</span> <span data-start="287.53" data-end="291.76">Web Workers allows WebAssembly to run on different CPU cores.</span> <span data-start="291.76" data-end="295.15">Then SharedArrayBuffer allows WebAssembly to operate</span> <span data-start="295.15" data-end="297.4">on the same piece of memory.</span> <span data-start="297.4" data-end="300.1">Lastly, atomic operations, specifically</span> <span data-start="300.1" data-end="303.122">atomic.wake and atomic.notify, let</span> <span data-start="303.122" data-end="305.08">you synchronize your WebAssembly so that things</span> <span data-start="305.08" data-end="308.32">happen in the right order.</span> </p>
<p><span data-start="308.32" data-end="311.63">Google Earth adapted WebAssembly threads with great success.</span> <span data-start="311.63" data-end="313.89">They saw their frame rate almost double</span> <span data-start="313.89" data-end="316.57">and their number of dropped frames cut by more than half.</span> <span data-start="320.87" data-end="322.79">Soundation, a music editing studio,</span> <span data-start="322.79" data-end="325.1">similarly adopted threads to enable</span> <span data-start="325.1" data-end="327.77">highly efficient paralization.</span> </p>
<p><span data-start="327.77" data-end="329.69">As they increased their number of threads,</span> <span data-start="329.69" data-end="333.85">they saw their performance more than triple.</span> <span data-start="333.85" data-end="336.25">One application that I'm particularly excited to share</span> <span data-start="336.25" data-end="340.27">is coming to the web through WebAssembly threads, is VLC.</span> <span data-start="340.27" data-end="342.53">They were able to originally compile their code base</span> <span data-start="342.53" data-end="343.995">to baseline WebAssembly.</span> <span data-start="343.995" data-end="345.37">But without threads, they weren't</span> <span data-start="345.37" data-end="347.5">able to achieve anything close to the performance</span> <span data-start="347.5" data-end="348.95">that they needed.</span> <span data-start="348.95" data-end="351.79">Now thanks to threads, they have a working prototype</span> <span data-start="351.79" data-end="354.98">working directly in Chrome.</span> <span data-start="354.98" data-end="356.818">So going back to our analogy from earlier,</span> <span data-start="356.818" data-end="359.11">if baseline WebAssembly it's like running along a train</span> <span data-start="359.11" data-end="362.39">track, WebAssembly with threads is like an actual train.</span> </p>
<p><span data-start="362.39" data-end="367.03">You're achieving speeds that were previously impossible.</span> <span data-start="367.03" data-end="369.52">Threads have been available in Chrome desktop</span> <span data-start="369.52" data-end="371.35">since version 74.</span> <span data-start="371.35" data-end="374.96">In Android, Chrome, and Firefox, threads are implemented,</span> <span data-start="374.96" data-end="377.02">but not enabled by default. We're</span> <span data-start="377.02" data-end="379.03">actively working with other browser vendors</span> <span data-start="379.03" data-end="381.64">and the WebAssembly community to make threads</span> <span data-start="381.64" data-end="383.94">available in more places.</span> <span data-start="383.94" data-end="385.99">[? Send ?] threads are not supported everywhere.</span> <span data-start="385.99" data-end="388.03">It's critical to use feature detection</span> <span data-start="388.03" data-end="391.06">before relying on their presence, which Ingvar will now</span> <span data-start="391.06" data-end="393.4">show you how to do.</span> </p>
</section>

<section>
<p><span data-start="393.4" data-end="395.872"><span class="speaker">Ingvar Stepanyan</span>: Thank you, Thomas.</span> <span data-start="395.872" data-end="397.33">Unfortunately, WebAssembly does not</span> <span data-start="397.33" data-end="399.497">have a built-in feature detection yet, although it's</span> <span data-start="399.497" data-end="400.85">being actively worked on.</span> <span data-start="400.85" data-end="402.97">For now, we created a JavaScript library instead</span> <span data-start="402.97" data-end="405.345">that you can use to detect WebAssembly features supported</span> <span data-start="405.345" data-end="406.038">by your browser.</span> <span data-start="406.038" data-end="408.58">This allows you to build several versions of your WebAssembly</span> <span data-start="408.58" data-end="410.038">module, for different feature sets,</span> <span data-start="410.038" data-end="411.747">just like you would for modern JavaScript</span> <span data-start="411.747" data-end="414.34">bundles and dynamically choose the ones that your browser can</span> <span data-start="414.34" data-end="416.11">handle.</span> </p>
<p><span data-start="416.11" data-end="419.02">For example, you can use threads function in order to detect</span> <span data-start="419.02" data-end="420.895">[INAUDIBLE] [? browse ?] [? simple ?] threads</span> <span data-start="420.895" data-end="421.85">in WebAssembly.</span> <span data-start="421.85" data-end="424.312">Then you can use dynamic input to load</span> <span data-start="424.312" data-end="426.02">either version of your WebAssembly module</span> <span data-start="426.02" data-end="427.85">and the JavaScript binded set makes</span> <span data-start="427.85" data-end="430.79">user threads for optimizations, or regular one for the older</span> <span data-start="430.79" data-end="433.45">browsers.</span> </p>
<p><span data-start="433.45" data-end="436.645">How do you build a version for threads, in the first place?</span> <span data-start="436.645" data-end="439.02">If you're using a script and you need to pass an argument</span> <span data-start="439.02" data-end="441.11">-pthread during compilation, like you would</span> <span data-start="441.11" data-end="442.95">to regular, native C compilers.</span> <span data-start="445.615" data-end="447.99">And it will automatically generate the WebAssembly module</span> <span data-start="447.99" data-end="450.24">and the JavaScript necessary for creating, managing,</span> <span data-start="450.24" data-end="453.96">and communicating with the Web Workers under the hood.</span> <span data-start="453.96" data-end="455.7">If you aren't in C [INAUDIBLE] allows</span> <span data-start="455.7" data-end="457.5">you to use common POSIX thread APIs,</span> <span data-start="457.5" data-end="460.26">just like those available on native Unix platforms.</span> <span data-start="460.26" data-end="462.21">For example, you can use pthread_create</span> <span data-start="462.21" data-end="464.13">with the handler function and arguments,</span> <span data-start="464.13" data-end="467.13">in order to start a new thread and [? writing ?] the code</span> <span data-start="467.13" data-end="469.85">pthread_join in order to wait for it to finish and read</span> <span data-start="469.85" data-end="472.45">the results back.</span> </p>
<p><span data-start="472.45" data-end="474.323">If you write in C++, good news has it,</span> <span data-start="474.323" data-end="476.74">Emscripten [? implemented ?] an implementation of standard</span> <span data-start="476.74" data-end="480.07">thread APIs, just like in Unix makes use of POSIX threads</span> <span data-start="480.07" data-end="481.51">under the hood.</span> <span data-start="481.51" data-end="484.54">And other high level APIs, such as std::async,</span> <span data-start="484.54" data-end="487.48">makes use of std::thread at the C++ standard level.</span> <span data-start="487.48" data-end="490.03">So they all just work.</span> <span data-start="490.03" data-end="493.15">This means that, for example, you can use std::thread with</span> <span data-start="493.15" data-end="494.94">closures in the C++ code.</span> </p>
<p><span data-start="494.94" data-end="497.01">And it will [? lower ?] to the same pthread goals</span> <span data-start="497.01" data-end="499.23">and handled by Emscripten.</span> <span data-start="499.23" data-end="502.95">Similarly, you can use std::async APIs to spawn</span> <span data-start="502.95" data-end="505.29">futures, which are quite similar to JavaScript promises,</span> <span data-start="505.29" data-end="507.42">but allow you to spawn tasks on your threads.</span> <span data-start="509.995" data-end="511.37">And the [INAUDIBLE] this stories,</span> <span data-start="511.37" data-end="512.953">not just [? been ?] [? fleshed ?] out,</span> <span data-start="512.953" data-end="514.73">as you need to maybe create Web Workers,</span> <span data-start="514.73" data-end="517.188">send them to WebAssembly module and [? memories ?] that you</span> <span data-start="517.188" data-end="519.62">want to share, as well as rebuild the standard library</span> <span data-start="519.62" data-end="521.328">with thread support.</span> </p>
<p><span data-start="521.328" data-end="523.12">However, after jumping through a few hoops,</span> <span data-start="523.12" data-end="525.67">you are able to even use popular multi-threading libraries,</span> <span data-start="525.67" data-end="529.21">like [? Ryan, ?] like in this demo by Rust WebAssembly team.</span> <span data-start="529.21" data-end="531.69">Here, they [? brought ?] [? in ?] a ray tracer to split</span> <span data-start="531.69" data-end="535.247">and read into several threads and compiled it to WebAssembly.</span> <span data-start="535.247" data-end="536.83">You can see how, with a single thread,</span> <span data-start="536.83" data-end="540.32">it takes 1.7 seconds to render the entire image.</span> <span data-start="540.32" data-end="542.33">But if you split working, to say, four threads,</span> <span data-start="542.33" data-end="544.66">it takes only 0.8 seconds, making it</span> <span data-start="544.66" data-end="548.007">more than two times faster.</span> </p>
<p><span data-start="548.007" data-end="550.09">Another performance feature that is making its way</span> <span data-start="550.09" data-end="551.615">into WebAssembly is SIMD.</span> <span data-start="551.615" data-end="553.99">And I'd like to invite Thomas back, to tell us what it is</span> <span data-start="553.99" data-end="556.24">and how it can help us.</span> </p>
</section>

<section>
<p><span data-start="556.24" data-end="558.34"><span class="speaker">Thomas Nattestad</span>: Thank you, so much, Ingvar So,</span> <span data-start="558.34" data-end="561.85">SIMD stands for Single Instruction Multiple Data.</span> <span data-start="561.85" data-end="564.7">And while this may not be a term that most web developers are</span> <span data-start="564.7" data-end="567.1">familiar with, it's an absolutely key part</span> <span data-start="567.1" data-end="570.67">of modern CPU architectures.</span> </p>
<p><span data-start="570.67" data-end="574.18">So to explain SIMD, let's take this simple example</span> <span data-start="574.18" data-end="576.82">of adding two arrays together into a third array,</span> <span data-start="576.82" data-end="579.64">using a simple for loop.</span> <span data-start="579.64" data-end="582.49">Without SIMD, the CPU goes through this loop</span> <span data-start="582.49" data-end="585.25">and adds the different elements together, one by one,</span> <span data-start="585.25" data-end="588.31">taking four full steps.</span> <span data-start="588.31" data-end="592.54">Now, with SIMD, the CPU is able to vectorize these elements</span> <span data-start="592.54" data-end="597.71">and then take just a single CPU operation to add them together.</span> <span data-start="597.71" data-end="600.13">This may seem simple, but it can have dramatic impacts</span> <span data-start="600.13" data-end="601.33">on performance.</span> <span data-start="601.33" data-end="603.233">To show the power that SIMD can deliver,</span> <span data-start="603.233" data-end="605.65">I want to show off some of the work done by our colleagues</span> <span data-start="605.65" data-end="608.27">at Google Research.</span> <span data-start="608.27" data-end="611.21">They've developed several real-time ML models</span> <span data-start="611.21" data-end="614.39">that can do everything from letting you try on fake glasses</span> <span data-start="614.39" data-end="617.63">or puppet masks, doing dynamic background removal, and much</span> <span data-start="617.63" data-end="619.46">more.</span> </p>
<p><span data-start="619.46" data-end="622.52">One of the coolest demos is this hand tracking system.</span> <span data-start="622.52" data-end="626.21">And here, you can really see the difference that SIMD makes.</span> <span data-start="626.21" data-end="628.43">Without SIMD, you're only getting about three frames</span> <span data-start="628.43" data-end="630.65">per second, while with SIMD, you've</span> <span data-start="630.65" data-end="633.15">got a much smoother 15 frames per second,</span> <span data-start="633.15" data-end="634.883">which makes all the difference.</span> <span data-start="634.883" data-end="636.8">You can visit this link to check these out for</span> <span data-start="636.8" data-end="640.93">yourself or come by the sandbox to play with them.</span> <span data-start="640.93" data-end="644.02">The Google research team looked at a bunch of their models</span> <span data-start="644.02" data-end="647.83">and found that, in general, SIMD offered a 3x improvement</span> <span data-start="647.83" data-end="651.13">on overall speed.</span> <span data-start="651.13" data-end="652.93">The next example that I want to show off</span> <span data-start="652.93" data-end="655.87">is OpenCV and some of the work done by our friends</span> <span data-start="655.87" data-end="658.09">at Intel and UC Irvine.</span> <span data-start="658.09" data-end="661.72">OpenCV is an extremely popular image analysis library</span> <span data-start="661.72" data-end="666.25">that has tons of performance dependent functionality.</span> </p>
<p><span data-start="666.25" data-end="668.38">OpenCV can be compiled to WebAssembly</span> <span data-start="668.38" data-end="670.7">and run directly in the browser.</span> <span data-start="670.7" data-end="673.33">It can be used for doing things, like card reading,</span> <span data-start="673.33" data-end="675.607">replacing real emotions with emojis,</span> <span data-start="675.607" data-end="677.44">and for all the Harry Potter fans out there,</span> <span data-start="677.44" data-end="681.67">you can now have your very own web-powered invisibility cloak.</span> </p>
<p><span data-start="681.67" data-end="683.47">You can visit this link to try them out.</span> <span data-start="683.47" data-end="688.45">Or again, come by the sandbox to check and see them there.</span> <span data-start="688.45" data-end="691.48">This work has actually been fully upstreamed into OpenCV.</span> <span data-start="691.48" data-end="693.07">And they even have a tutorial on how</span> <span data-start="693.07" data-end="695.272">to setup OpenCV with the Emscripten,</span> <span data-start="695.272" data-end="697.48">so that you can all play with this yourself, at home.</span> <span data-start="699.99" data-end="702.93">And all of this functionality can take advantage of threads</span> <span data-start="702.93" data-end="705.63">and SIMD to dramatically improve performance.</span> <span data-start="705.63" data-end="707.46">Here we can see the visual difference</span> <span data-start="707.46" data-end="712.36">of first adding SIMD and then SIMD plus threads.</span> <span data-start="712.36" data-end="714.79">And our benchmarking backs up this visually noticeable</span> <span data-start="714.79" data-end="715.78">difference.</span> </p>
<p><span data-start="715.78" data-end="718.15">When using both threads and SIMD together,</span> <span data-start="718.15" data-end="721.81">common tasks in OpenCV can be improved by around 15x.</span> <span data-start="724.54" data-end="727.6">And some of the benchmarks show even more dramatic improvements</span> <span data-start="727.6" data-end="729.07">from threads and SIMD.</span> <span data-start="729.07" data-end="731.74">For the OpenCV kernel performance test,</span> <span data-start="731.74" data-end="736.03">using threads gives you a 3.5x improvement.</span> <span data-start="736.03" data-end="739.87">And using SIMD gives you an even more impressive 9x improvement,</span> <span data-start="739.87" data-end="741.73">just by itself.</span> <span data-start="741.73" data-end="743.5">And then when you take these together,</span> <span data-start="743.5" data-end="746.32">it results in an overall 30x improvement</span> <span data-start="746.32" data-end="750.2">to this performance test, which is truly staggering.</span> <span data-start="750.2" data-end="752.29">So coming back to our train analogy,</span> <span data-start="752.29" data-end="755.56">because who doesn't love trains, if WebAssembly threads is</span> <span data-start="755.56" data-end="758.77">like an old-style train, using threads and SIMD together</span> <span data-start="758.77" data-end="760.72">is like a modern bullet train.</span> </p>
<p><span data-start="760.72" data-end="763.6">So to show you how to actually take advantage of this in code,</span> <span data-start="763.6" data-end="766.56">I'd like to hand it back to Ingvar.</span> </p>
</section>

<section>
<p><span data-start="766.56" data-end="769.3"><span class="speaker">Ingvar Stepanyan</span>: Thanks, Thomas.</span> <span data-start="769.3" data-end="771">To build code with SIMD and Emscripten,</span> <span data-start="771" data-end="773.183">you need to pass a special parameter -m, which</span> <span data-start="773.183" data-end="774.85">tells Dandelion's [? sealant ?] compiler</span> <span data-start="774.85" data-end="778.232">to enable a specific feature, followed by simd128,</span> <span data-start="778.232" data-end="780.44">which is the feature name for the currently supported</span> <span data-start="780.44" data-end="785.14">128-bit SIMD operations in WebAssembly.</span> </p>
<p><span data-start="785.14" data-end="787.54">In Rust, you need to pass the same feature name, by a -C</span> <span data-start="787.54" data-end="789.61">target-feature compiler flag.</span> <span data-start="789.61" data-end="791.73">The easiest way to do this on a real project,</span> <span data-start="791.73" data-end="793.81">using cargo wasm-pac is currently</span> <span data-start="793.81" data-end="795.87">[? serene ?] environment variable RUSTFLAGS,</span> <span data-start="795.87" data-end="798.56">passed during compilation.</span> <span data-start="798.56" data-end="801">Now that we've covered how to compile our code,</span> <span data-start="801" data-end="804.408">let's see what it takes to actually use SIMD in our code.</span> <span data-start="804.408" data-end="806.2">The good news has it, in the simplest case,</span> <span data-start="806.2" data-end="808.14">the answer is nothing.</span> <span data-start="808.14" data-end="810.99">That is, unlike with threads, SIMD [INAUDIBLE] compiler</span> <span data-start="810.99" data-end="813.69">can often make advantage of, and take care of,</span> <span data-start="813.69" data-end="817.31">without you having to modify any code at all.</span> <span data-start="817.31" data-end="820.01">This compiler feature is called auto-vectorization.</span> </p>
<p><span data-start="820.01" data-end="821.54">And it detects loops that perform</span> <span data-start="821.54" data-end="824.09">[? same ?] mathematical operations on array items,</span> <span data-start="824.09" data-end="826.05">independently.</span> <span data-start="826.05" data-end="831.08">For example, let's take a look at this simple code in C.</span> <span data-start="831.08" data-end="836.4">On [INAUDIBLE] one in C++ All the same one, in Rust.</span> <span data-start="836.4" data-end="838.66">Such a loop operates on an array of numbers.</span> <span data-start="838.66" data-end="839.89">Check.</span> <span data-start="839.89" data-end="841.9">It performs arithmetic operations.</span> </p>
<p><span data-start="841.9" data-end="843.34">Also, check.</span> <span data-start="843.34" data-end="846.1">And it clearly operates as an independent [INAUDIBLE]</span> <span data-start="846.1" data-end="846.807">Also, check.</span> <span data-start="846.807" data-end="848.89">So the compiler should be able to make use of SIMD</span> <span data-start="848.89" data-end="851.56">to process several elements at once —  [? Ryzen ?] handles them</span> <span data-start="851.56" data-end="855.22">by one-to-one —  and make it faster.</span> <span data-start="855.22" data-end="857.59">Let's see if it does.</span> <span data-start="857.59" data-end="862.7">First, let's compile this code, in any of the source languages,</span> <span data-start="862.7" data-end="864.5">without SIMD enabled and take a look</span> <span data-start="864.5" data-end="867.32">at the interactive WebAssembly.</span> </p>
<p><span data-start="867.32" data-end="870.5">We can see that our function gets compiled to a loop.</span> <span data-start="870.5" data-end="873.38">Set loads an item from an array, multiplies it by 10,</span> <span data-start="873.38" data-end="875.6">and stores the result back.</span> <span data-start="875.6" data-end="877.77">No surprises here.</span> <span data-start="877.77" data-end="880.86">Now, let's get our compiler to be SIMD enabled.</span> <span data-start="880.86" data-end="884.39">We can see is that, aside from our regular boilerplate,</span> <span data-start="884.39" data-end="886.44">there is now another loop that loads</span> <span data-start="886.44" data-end="888.38">four items out of an array, multiplies them</span> <span data-start="888.38" data-end="891.33">by four instances of number 10, and stores the result</span> <span data-start="891.33" data-end="894.375">back, also in just one operation.</span> </p>
<p><span data-start="894.375" data-end="896.5">While this improvement [? is an ?] example, and not</span> <span data-start="896.5" data-end="898.458">a real-world benchmark, it's interesting to see</span> <span data-start="898.458" data-end="899.98">how such implicit optimization can</span> <span data-start="899.98" data-end="901.66">help to achieve a consistent three times</span> <span data-start="901.66" data-end="903.89">increase in performance of the generated code.</span> <span data-start="906.307" data-end="907.89">In some situations, however, you don't</span> <span data-start="907.89" data-end="910.14">want to leave it to chance to have your code optimized</span> <span data-start="910.14" data-end="912.48">this way or your data has a specific layout</span> <span data-start="912.48" data-end="916.32">or you just want more control over which features are used.</span> </p>
<p><span data-start="916.32" data-end="918.9">This is where intrinsics can come in helpful.</span> <span data-start="918.9" data-end="920.73">Intrinsics are special helpers that</span> <span data-start="920.73" data-end="923.37">look like regular functions but correspond</span> <span data-start="923.37" data-end="925.92">to specific instructions on the target.</span> <span data-start="925.92" data-end="927.75">For SIMD in Emscripten they [? leave ?]</span> <span data-start="927.75" data-end="930.48">in wasm_simd128 header and content</span> <span data-start="930.48" data-end="932.67">all basic operations for creating, loading,</span> <span data-start="932.67" data-end="934.89">and storing, and operating at once the supported</span> <span data-start="934.89" data-end="937.62">SIMD vector types.</span> <span data-start="937.62" data-end="940.67">In Rust, the easiest way to use them is [INAUDIBLE] external</span> <span data-start="940.67" data-end="942.93">packets in [? the ?] crate, which is intended to be</span> <span data-start="942.93" data-end="944.61">a prototype for a future [? Standard ?] [? Library ?]</span> <span data-start="944.61" data-end="945.11">API.</span> <span data-start="948.385" data-end="950.76">One important thing to keep in mind is that SIMD is still</span> <span data-start="950.76" data-end="952.98">experimental and available only in Chrome [? under ?]</span> <span data-start="952.98" data-end="954.92">[? flag. ?] So just like with threads,</span> <span data-start="954.92" data-end="958.013">you need to make a separate build that makes use of SIMD.</span> </p>
<p><span data-start="958.013" data-end="960.18">And then use a feature detection library to load it,</span> <span data-start="960.18" data-end="963.8">only if it's supported.</span> <span data-start="963.8" data-end="966.365">Now that we've covered new WebAssembly features,</span> <span data-start="966.365" data-end="967.99">we've got some exciting tool implements</span> <span data-start="967.99" data-end="971.1">to share with you, too.</span> <span data-start="971.1" data-end="974.07">First if all, earlier this year, [? LLVM, ?]</span> <span data-start="974.07" data-end="976.02">the compelling infrastructure behind projects,</span> <span data-start="976.02" data-end="979.17">such as Clang and Rust and lots of others,</span> <span data-start="979.17" data-end="982.428">has stabilized and finished support for WebAssembly target.</span> <span data-start="982.428" data-end="984.72">This includes both compilation of separate source files</span> <span data-start="984.72" data-end="987.12">into WebAssembly object files, as well as linking them</span> <span data-start="987.12" data-end="991.09">together into the final module.</span> <span data-start="991.09" data-end="993.37">It's not very usable on its own.</span> <span data-start="993.37" data-end="999.3">For example, while it allows you to compile a separate C/C++</span> <span data-start="999.3" data-end="1002.52">files into WebAssembly, it doesn't include any standard</span> <span data-start="1002.52" data-end="1003.02">library.</span> </p>
<p><span data-start="1003.02" data-end="1005.24">And it expects you to bring your own.</span> <span data-start="1005.24" data-end="1007.94">However, it does provide a solid foundation for other compilers</span> <span data-start="1007.94" data-end="1010.85">to build on.</span> <span data-start="1010.85" data-end="1013.4">Let's take a look at Emscripten.</span> <span data-start="1013.4" data-end="1016.31">Before this, Emscripten had to maintain a complex, custom</span> <span data-start="1016.31" data-end="1020.21">compilation pipeline and a fork of LLVM, called fastcomp.</span> <span data-start="1020.21" data-end="1022.46">In order to parse an intermediate representation</span> <span data-start="1022.46" data-end="1026.63">from Clang, compile it to asm.js,</span> <span data-start="1026.63" data-end="1030.65">and when WebAssembly came along, also converted to WebAssembly.</span> <span data-start="1030.65" data-end="1032.524">Having to work around LLVMs, this way, led</span> <span data-start="1032.524" data-end="1033.774">to various incompatibilities — </span> <span data-start="1033.774" data-end="1034.2">[COUGH]</span> <span data-start="1034.2" data-end="1036.575">[?  — reported, ?] [? such ?] [? as ?] difficulties during</span> <span data-start="1036.575" data-end="1040.855">upgrades and suboptimal compilation performance.</span> <span data-start="1040.855" data-end="1042.23">Now since the WebAssembly support</span> <span data-start="1042.23" data-end="1045.89">has been properly integrated into the LLVM,</span> </p>
<p><span data-start="1045.89" data-end="1048.92">Emscripten can leverage it to simplify the compilation</span> <span data-start="1048.92" data-end="1052.1">process and focus on providing a great development</span> <span data-start="1052.1" data-end="1054.98">experience, custom features, and a standard library,</span> <span data-start="1054.98" data-end="1058.36">while all core work, for the features and optimizations,</span> <span data-start="1058.36" data-end="1060.11">can be continued to be developed upstream.</span> <span data-start="1062.697" data-end="1064.53">As an example of improvements [? reaching ?]</span> <span data-start="1064.53" data-end="1067.35">to the native backend allowed Emscripten to significantly</span> <span data-start="1067.35" data-end="1070.11">improve linking times, with a small extra cost</span> <span data-start="1070.11" data-end="1072.45">to its initial compilation.</span> </p>
<p><span data-start="1072.45" data-end="1075.848">This particularly helps on incremental development,</span> <span data-start="1075.848" data-end="1077.64">where you usually modify and recompile only</span> <span data-start="1077.64" data-end="1079.77">like one, two files, at a time.</span> <span data-start="1079.77" data-end="1083.1">And all you need is a fast linking step.</span> <span data-start="1083.1" data-end="1085.98">Some projects have seen as much as seven times improvement</span> <span data-start="1085.98" data-end="1087.75">in recompilation times, in such cases.</span> <span data-start="1093.39" data-end="1096">However, there were some compile-time features,</span> <span data-start="1096" data-end="1098.28">unique to Emscripten, that were previously</span> <span data-start="1098.28" data-end="1101.16">handled by the earlier mentioned fork of LLVM,</span> <span data-start="1101.16" data-end="1103.17">and could be lost in transition.</span> </p>
<p><span data-start="1103.17" data-end="1106.78">One of such features is Asyncify.</span> <span data-start="1106.78" data-end="1109.33">Normally, when calling from JavaScript to WebAssembly,</span> <span data-start="1109.33" data-end="1112.09">and then from WebAssembly to some Web APIs,</span> <span data-start="1112.09" data-end="1114.55">you expect to read the result back, continue execution,</span> <span data-start="1114.55" data-end="1117.1">and eventually return to JavaScript.</span> <span data-start="1117.1" data-end="1122.75">However, many long, [? grinding, ?] and expensive</span> </p>
<p><span data-start="1122.75" data-end="1125.58">Web APIs tend to spawn asynchronous tasks,</span> <span data-start="1125.58" data-end="1128.08">to avoid blocking the [? main ?] [? thread. ?] This includes</span> <span data-start="1128.08" data-end="1130.85">[? Timeless, ?] Fetch API, Web Crypto API,</span> <span data-start="1130.85" data-end="1133.907">and lots of [? others. ?]</span> <span data-start="1133.907" data-end="1136.24">Because WebAssembly does not have a notion of event loop</span> <span data-start="1136.24" data-end="1138.045">promises or synchronous tasks, [INAUDIBLE]</span> <span data-start="1138.045" data-end="1139.42">would look like the external API,</span> <span data-start="1139.42" data-end="1141.25">as soon as it finished execution.</span> <span data-start="1141.25" data-end="1143.97">So it can continue running users code, immediately,</span> <span data-start="1143.97" data-end="1146.85">while the async task is still running in the background,</span> <span data-start="1146.85" data-end="1149.14">with no handlers attached.</span> </p>
<p><span data-start="1149.14" data-end="1151.19">This is not what we normally want.</span> <span data-start="1151.19" data-end="1154.09">We want to not only be able to start an asynchronous task,</span> <span data-start="1154.09" data-end="1157.15">but also wait for it to finish, read the results back,</span> <span data-start="1157.15" data-end="1160.16">and continuous execution afterwards.</span> <span data-start="1160.16" data-end="1162.273">This is where I Asyncify comes in.</span> <span data-start="1162.273" data-end="1164.44">I wont go too much into implementation details here.</span> <span data-start="1164.44" data-end="1166.898">But what it does is compiles the WebAssembly module in such</span> <span data-start="1166.898" data-end="1169.59">a way that you can suspend execution,</span> <span data-start="1169.59" data-end="1172.12">remember the state, and later, resume</span> <span data-start="1172.12" data-end="1174.61">from the exact same point, when an asynchronous task</span> <span data-start="1174.61" data-end="1176.196">has finished its execution.</span> <span data-start="1179.32" data-end="1181.48">This is quite similar to await, in JavaScript,</span> <span data-start="1181.48" data-end="1184.36">but applied to native functions and with no changes</span> <span data-start="1184.36" data-end="1186.4">to your own code.</span> </p>
<p><span data-start="1186.4" data-end="1188.26">In order to use it from Emscripten,</span> <span data-start="1188.26" data-end="1190.33">you need to pass a special parameter,</span> <span data-start="1190.33" data-end="1192.61">-s asyncify, and specify which [? imports ?] should</span> <span data-start="1192.61" data-end="1196.18">be treated as asynchronous.</span> <span data-start="1196.18" data-end="1197.31">The great news are — </span> <span data-start="1200.82" data-end="1204.01">so in your code, you can use regular function imports.</span> <span data-start="1204.01" data-end="1205.76">And it evokes them as any other functions,</span> <span data-start="1205.76" data-end="1208.13">while Asyncify does magic under the hood.</span> <span data-start="1208.13" data-end="1210.74">The great news was that, with the transition to the upstream</span> <span data-start="1210.74" data-end="1213.54">LLVM [INAUDIBLE] the backend, this feature has not gone</span> <span data-start="1213.54" data-end="1217.31">but was extracted as a separate transform and can be now used</span> <span data-start="1217.31" data-end="1220.64">from any languages and not just C/C++,</span> <span data-start="1220.64" data-end="1223.25">as long as they compile to WebAssembly.</span> </p>
<p><span data-start="1223.25" data-end="1224.76">For example, you can simply invoke</span> <span data-start="1224.76" data-end="1226.135">asynchronous JavaScript functions</span> <span data-start="1226.135" data-end="1228.35">from Rust, which is particularly helpful for</span> <span data-start="1228.35" data-end="1230.84">[? both ?] [INAUDIBLE] standard synchronous system APIs,</span> <span data-start="1230.84" data-end="1234.242">available on other platforms.</span> </p>
<p><span data-start="1234.242" data-end="1235.7">Since you are not using Emscripten,</span> <span data-start="1235.7" data-end="1237.83">in this case, after you have compiled</span> <span data-start="1237.83" data-end="1242.48">your module into [INAUDIBLE] using wasm-tool, instead</span> <span data-start="1242.48" data-end="1245.07">and it will add all the necessary magic for spending</span> <span data-start="1245.07" data-end="1246.755">[INAUDIBLE] execution.</span> <span data-start="1249.73" data-end="1252.73">Then, you'd need some loop on the JavaScript side, as well.</span> <span data-start="1252.73" data-end="1254.04">We have [INAUDIBLE] for use.</span> <span data-start="1254.04" data-end="1256.53">It mimics our regular WebAssembly API.</span> <span data-start="1256.53" data-end="1258.33">But [? it allows ?] instantiates modules</span> <span data-start="1258.33" data-end="1261.1">with asynchronous imports and exports.</span> <span data-start="1261.1" data-end="1265.02">To use it, first, import is from asyncify-wasm [INAUDIBLE]</span> <span data-start="1265.02" data-end="1267.44">module.</span> <span data-start="1267.44" data-end="1270.22">And then, you can use regular instantiation APIs.</span> <span data-start="1270.22" data-end="1273.08">But we use asynchronous imports and exports, in addition to</span> <span data-start="1273.08" data-end="1273.82">the regular ones.</span> <span data-start="1278.14" data-end="1279.58">Since now your WebAssembly module</span> <span data-start="1279.58" data-end="1282.2">might invoke asynchronous APIs in arbitrary points,</span> <span data-start="1282.2" data-end="1284.7">all the exports need to become asynchronous, too.</span> </p>
<p><span data-start="1284.7" data-end="1286.24">So you need to [? prefix ?] [? calls ?] to your exports</span> <span data-start="1286.24" data-end="1287.99">[? with a write. ?] And you're good to go.</span> <span data-start="1291.37" data-end="1293.52">One particularly interesting use case for Asyncify,</span> <span data-start="1293.52" data-end="1297.71">aside from external APIs, is in Emscripten.</span> <span data-start="1297.71" data-end="1300.87">Emscripten allows you to mark parts of your code, that's</span> <span data-start="1300.87" data-end="1303.9">rarely used, and splits them to a separate WebAssembly module,</span> <span data-start="1303.9" data-end="1305.88">during compilation.</span> <span data-start="1305.88" data-end="1308.94">[? add-lazy ?] loads them, only when it's invoked.</span> <span data-start="1308.94" data-end="1311.76">This allows us to keep your initial bundle small,</span> <span data-start="1311.76" data-end="1315.335">without any breakage to your own code and with minimal changes.</span> <span data-start="1318.1" data-end="1321.22">To use it, you need to call a special function,</span> <span data-start="1321.22" data-end="1323.73">emscripten_lazy_load_code.</span> <span data-start="1323.73" data-end="1326.17">During compilation, it will extract any following code</span> <span data-start="1326.17" data-end="1329.02">into a separate WebAssembly module.</span> <span data-start="1329.02" data-end="1333.31">[? Send ?] during runtime when, or if, that code is actually</span> <span data-start="1333.31" data-end="1336.31">reached during execution, Emscripten</span> <span data-start="1336.31" data-end="1339.85">will use Asyncify to dynamically load the missing pieces</span> <span data-start="1339.85" data-end="1342.298">and continue as if there was never split,</span> <span data-start="1342.298" data-end="1343.09">in the first place.</span> </p>
<p><span data-start="1347.76" data-end="1348.76">This all great features.</span> <span data-start="1348.76" data-end="1350.677">And it's amazing to see how our WebAssembly is</span> <span data-start="1350.677" data-end="1351.82">growing over time.</span> <span data-start="1351.82" data-end="1354.06">However, with this feature [? course, ?]</span> <span data-start="1354.06" data-end="1358.24">the surface area of potential boxes expanded, as well.</span> <span data-start="1358.24" data-end="1359.9">When things go wrong, and we all know,</span> <span data-start="1359.9" data-end="1364.25">they often do, you want to be able to track where</span> <span data-start="1364.25" data-end="1367.28">the problem occurred, reproduce it step by step,</span> <span data-start="1367.28" data-end="1369.73">track the inputs that led to the issue in the first place,</span> <span data-start="1369.73" data-end="1370.23">and so on.</span> <span data-start="1370.23" data-end="1372.9">You want to be able to debug a application.</span> <span data-start="1372.9" data-end="1375">Until recently, you had two options</span> <span data-start="1375" data-end="1376.77">for debugging WebAssembly.</span> </p>
<p><span data-start="1376.77" data-end="1379.5">First, you could get [? your ?] stack traces,</span> <span data-start="1379.5" data-end="1381.45">as well as step over individual instructions</span> <span data-start="1381.45" data-end="1384.7">in that WebAssembly text format.</span> <span data-start="1384.7" data-end="1388.12">This helps somewhat with debugging of small isolated</span> <span data-start="1388.12" data-end="1389.51">functions.</span> <span data-start="1389.51" data-end="1391.93">But it's not very practical for larger ops, where</span> <span data-start="1391.93" data-end="1394.45">the mapping between the disassembled source</span> <span data-start="1394.45" data-end="1398.32">and your original sources is less obvious.</span> <span data-start="1398.32" data-end="1400.78">To work around this problem, Emscripten DevTools</span> <span data-start="1400.78" data-end="1404.19">have initially adapted the existing source maps format,</span> <span data-start="1404.19" data-end="1406.84">which was designed for languages that compile</span> <span data-start="1406.84" data-end="1409.5">to JavaScript for WebAssembly.</span> <span data-start="1409.5" data-end="1411.21">This allowed to map binary offsets,</span> <span data-start="1411.21" data-end="1414.51">in the compiled module, to the locations in original sources</span> <span data-start="1414.51" data-end="1416.32">files.</span> </p>
<p><span data-start="1416.32" data-end="1421.22">However, this format was designed for text languages.</span> <span data-start="1421.22" data-end="1423.24">We use clear mapping to JavaScript's concepts</span> <span data-start="1423.24" data-end="1425.43">and values, and not for binary formats,</span> <span data-start="1425.43" data-end="1428.82">like WebAssembly, using a memory arbitrary source languages</span> <span data-start="1428.82" data-end="1431.68">and arbitrary type systems.</span> <span data-start="1431.68" data-end="1433.26">This makes the integration hacky,</span> <span data-start="1433.26" data-end="1435.03">limited, and not widely supported</span> <span data-start="1435.03" data-end="1437.83">outside of Emscripten.</span> <span data-start="1437.83" data-end="1441.46">On the other hand, many native languages already</span> <span data-start="1441.46" data-end="1443.14">have a common debugging format that</span> <span data-start="1443.14" data-end="1445.69">contains all the necessary information for the debugger</span> <span data-start="1445.69" data-end="1448.93">to resolve locations, variable names, type layouts, and much</span> <span data-start="1448.93" data-end="1450.42">more.</span> <span data-start="1450.42" data-end="1452.93">This format is called DWARF.</span> <span data-start="1452.93" data-end="1455.96">While there's still some WebAssembly-specific features,</span> <span data-start="1455.96" data-end="1458.21">that need to be edited for full compatibility,</span> <span data-start="1458.21" data-end="1460.24">compilers like Clang and Rust already</span> <span data-start="1460.24" data-end="1461.79">support emitting DWARF information</span> <span data-start="1461.79" data-end="1464.3">in a WebAssembly modules, which allows us to start</span> <span data-start="1464.3" data-end="1467.27">using directly in DevTools.</span> </p>
<p><span data-start="1467.27" data-end="1469.97">As a first step, we went ahead and implemented native source</span> <span data-start="1469.97" data-end="1471.12">method.</span> <span data-start="1471.12" data-end="1473.69">So you can start debugging the WebAssembly modules produced</span> <span data-start="1473.69" data-end="1475.55">by any of these compilers, without having</span> <span data-start="1475.55" data-end="1478.7">to resort to disassembled format or [INAUDIBLE] scripts</span> <span data-start="1478.7" data-end="1481.71">for source [? map ?] generation.</span> </p>
<p><span data-start="1481.71" data-end="1484.55">This integration only covers stepping in and offers a code</span> <span data-start="1484.55" data-end="1486.92">in any of these language, set in breakpoints,</span> <span data-start="1486.92" data-end="1488.965">and resolving stacks traces.</span> <span data-start="1488.965" data-end="1490.34">There's still much more we can do</span> <span data-start="1490.34" data-end="1494.11">though, such as [? preprinting ?] types</span> <span data-start="1494.11" data-end="1499.28">or even evaluating expressions in the source languages.</span> <span data-start="1499.28" data-end="1500.85">We are actively working on bringing</span> <span data-start="1500.85" data-end="1504.197">this and many other improvements to the WebAssembly experience.</span> </p>
<p><span data-start="1504.197" data-end="1506.03">So please stay tuned for the future updates.</span> <span data-start="1506.03" data-end="1507.53">And thank you, for your time, today.</span> <span data-start="1507.53" data-end="1508.88">[APPLAUSE]</span> <span data-start="1509.38" data-end="1512.43">[MUSIC PLAYING]</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
